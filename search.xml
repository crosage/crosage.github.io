<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ubuntu22.04配置pppoe</title>
      <link href="/2025/03/27/ubuntu22-04%E9%85%8D%E7%BD%AEpppoe/"/>
      <url>/2025/03/27/ubuntu22-04%E9%85%8D%E7%BD%AEpppoe/</url>
      
        <content type="html"><![CDATA[<p>默认是没有pppoeconf的<br>使用nmcli配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection add <span class="built_in">type</span> pppoe con-name <span class="string">&quot;你的PPPOE连接名称&quot;</span> ifname <span class="string">&quot;你的以太网接口名称&quot;</span> username <span class="string">&quot;你的PPPOE用户名&quot;</span> password <span class="string">&quot;你的PPPOE密码&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show</span><br><span class="line">NAME                UUID                                  TYPE      DEVICE          </span><br><span class="line">pppoe               b1d4da79-01ee-4b4c-902d-3082b66f350b  pppoe     eno1            </span><br><span class="line">br-2cd7e89ad872     f2d2ae34-ac97-4685-8b38-12982ec42eae  bridge    br-2cd7e89ad872 </span><br><span class="line">docker0             2007d6eb-6049-44de-b79c-4966f6035b33  bridge    docker0         </span><br><span class="line">DSL connection 1    c3e03394-bc07-45d9-bcb0-c32f15c0fb2d  pppoe     --              </span><br><span class="line">Wired connection 1  86160ea3-202f-39b2-b07a-046ce6ea82f5  ethernet  --              </span><br><span class="line">Wired connection 2  847627ce-9f0f-32a1-90b1-ce61c5e86d8f  ethernet  -- </span><br></pre></td></tr></table></figure><p>设置自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify pppoe connection.autoconnect <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>查看所有启动状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@server118-Super-Server:/home/server118# nmcli -f NAME,AUTOCONNECT connection show</span><br><span class="line">NAME                AUTOCONNECT </span><br><span class="line">pppoe               <span class="built_in">yes</span>         </span><br><span class="line">br-2cd7e89ad872     no          </span><br><span class="line">docker0             no          </span><br><span class="line">DSL connection 1    no          </span><br><span class="line">Wired connection 1  <span class="built_in">yes</span>         </span><br><span class="line">Wired connection 2  <span class="built_in">yes</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>致歉</title>
      <link href="/2025/03/14/%E8%87%B4%E6%AD%89/"/>
      <url>/2025/03/14/%E8%87%B4%E6%AD%89/</url>
      
        <content type="html"><![CDATA[<p>归档于  2020-07-03 22:48</p><p>之前很多题解有不负责，瞎讲的情况，已经删了部分题解</p><p>一年没碰奥赛，肯定不会做了，最多只能删掉题解</p><p>如果您被我题解误导，我对您表示深深的歉意</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指路</title>
      <link href="/2025/03/14/%E6%8C%87%E8%B7%AF/"/>
      <url>/2025/03/14/%E6%8C%87%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>归档于  2021-07-23 19:47</p><p>这里是znsbc的博客</p><p>常用id是znsbc，如果看到叫crosa那多半也是我（znsbc读不出来好别扭a 后来有的网站就改成crosa了）</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>衡中2018级学生，曾经也是个oier，不过和其他大佬不一样我只学到了noip就不学了，省一丢脸</p><p>现在在西北工业大学被新的一批大佬暴踩</p><h2 id="关于我的博客"><a href="#关于我的博客" class="headerlink" title="关于我的博客"></a>关于我的博客</h2><p>所有oi时期的博文都隐藏了，如果你想找某个题解可以在侧边栏里搜索</p><p>以后可能会加点日记类的杂文</p><p>分类基本弃了中间有段时间所有题解都没分类也懒得再分了</p><h2 id="关于博客样式"><a href="#关于博客样式" class="headerlink" title="关于博客样式"></a>关于博客样式</h2><p>抄的大佬的</p><p><a href="https://www.cnblogs.com/guangzan/">guangzan - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>折半搜索[世界冰球模拟赛,cow balance,prime gift]</title>
      <link href="/2025/03/14/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%5B%E4%B8%96%E7%95%8C%E5%86%B0%E7%90%83%E6%A8%A1%E6%8B%9F%E8%B5%9B,cow%20balance,prime%20gift%5D/"/>
      <url>/2025/03/14/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%5B%E4%B8%96%E7%95%8C%E5%86%B0%E7%90%83%E6%A8%A1%E6%8B%9F%E8%B5%9B,cow%20balance,prime%20gift%5D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-14 12:17</p><p>好歹做了几道题,</p><p>算是一种套路,</p><p>看到可以搜索做,然而范围比较大,指数上&#x2F;2刚好可以,那么无脑折半搜索就可以了</p><p>一般来说难点在拼接上,主要讲拼接</p><h2 id="世界冰球模拟赛"><a href="#世界冰球模拟赛" class="headerlink" title="世界冰球模拟赛"></a>世界冰球模拟赛</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n&lt;&#x3D;40,c&lt;&#x3D;1e18$的背包,</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>算是一道裸题,</p><p>前20搜索出来,后20搜索出来,</p><p>拼接的话,设前一段代价x,后一段代价y,所有(x+y)&lt;&#x3D;c都可以组成一种方案</p><p>排序后lower_bound一下就好了</p><pre><code>    for(ll i=1;i&lt;=cnta;i++)&#123;        ans+=1ll*(upper_bound(sumb+1,sumb+cntb+1,m-suma[i])-sumb-1);    &#125;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 11111111ll n,m,cnta=0,cntb=0,ans=0;ll suma[A],sumb[A],a[A];void dfs(ll x,ll sum,ll opt)&#123;//    printf(&quot;x=%lld sum=%lld opt=%lld n/2=%lld\n&quot;,x,sum,opt,n/2);    if(opt==0)&#123;        if(x&gt;n/2)&#123;            suma[++cnta]=sum;            return ;        &#125;    &#125;    if(opt)&#123;        if(x&gt;n)&#123;            sumb[++cntb]=sum;            return ;        &#125;    &#125;    dfs(x+1,sum+a[x],opt);    dfs(x+1,sum,opt);&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    dfs(1,0,0);    dfs(n/2+1,0,1);    sort(suma+1,suma+cnta+1);    sort(sumb+1,sumb+cntb+1);/*    for(ll i=1;i&lt;=cnta;i++)        printf(&quot;suma=%lld\n&quot;,suma[i]);    for(ll i=1;i&lt;=cntb;i++)        printf(&quot;sumb=%lld\n&quot;,sumb[i]);*/        for(ll i=1;i&lt;=cnta;i++)&#123;        ans+=1ll*(upper_bound(sumb+1,sumb+cntb+1,m-suma[i])-sumb-1);    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="prime-gift"><a href="#prime-gift" class="headerlink" title="prime gift"></a>prime gift</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个大小为n的素数集合</p><p>求出分解后只含这些质数因子的第k小整数</p><p>$n&lt;&#x3D;16$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>暴力$n!$</p><p>折半搜索,+二分答案,看到第k小就二分答案吧</p><p>拼接比较简单</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 11111111ll cnta,cntb,q,k,n;ll suma[A],sumb[A],a[A];void dfs1(ll x,ll s)&#123;    if(x&gt;n)&#123;suma[++cnta]=s;return;&#125;    for(ll w=1;;w*=a[x])&#123;dfs1(x+2,s*w);if(1e18/a[x]&lt;w*s)break;&#125;&#125;void dfs2(ll x,ll s)&#123;    if(x&gt;n)&#123;sumb[++cntb]=s;return;&#125;    for(ll w=1;;w*=a[x])&#123;dfs2(x+2,s*w);if(1e18/a[x]&lt;w*s)break;&#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    dfs1(1,1);    dfs2(2,1);    sort(suma+1,suma+cnta+1);    sort(sumb+1,sumb+cntb+1);    scanf(&quot;%lld&quot;,&amp;k);    ll l=0,r=1e18,ans;    while(l&lt;=r)&#123;        ll mid=(l+r)&gt;&gt;1,tot=0;        for(ll i=1,p=cntb;i&lt;=cnta;i++,tot+=p)            while(p&amp;&amp;mid/suma[i]&lt;sumb[p])p--;        if(tot&lt;k)l=mid+1;        else&#123;ans=mid;r=mid-1;&#125;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="cow-balance"><a href="#cow-balance" class="headerlink" title="cow balance"></a>cow balance</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有多少非空子集能划分成相等两部分</p><p>$n&lt;&#x3D;20$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>折半搜索比较简单,但拼接不好拼接,你可能会算少</p><p>例如a[1]&#x3D;15 a[2]&#x3D;15 a[3]&#x3D;3</p><p>分成可以1划分成一组2,3划分成一组,1,3划分成一组,2划分成一组</p><p>这样会有两个贡献,如果再用之前思想只会算一遍</p><p>,用状压思想,记录口那些用了,口那些没用,</p><p>之后再进行拼接得到最终结果,</p><p>拼接部分可以hash表或者双指针</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 11111111ll n,m,cnta=0,cntb=0,ans=0;ll a[A];bool vis[A];struct node&#123;    ll state,x;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b)&#123;state=a,x=b;&#125;&#125;suma[A],sumb[A];bool cmp1(const node &amp;a,const node &amp;b)&#123;    return a.x&lt;b.x;&#125;bool cmp2(const node &amp;a,const node &amp;b)&#123;    return a.x&gt;b.x;&#125;void dfs(ll x,ll sum,ll now,ll opt)&#123;    if(opt==0)&#123;        if(x&gt;n/2)&#123;            suma[++cnta]=node(now,sum);            return ;        &#125;    &#125;    if(opt)&#123;        if(x&gt;n)&#123;            sumb[++cntb]=node(now,sum);            return ;        &#125;    &#125;    dfs(x+1,sum,now,opt);    dfs(x+1,sum+a[x],now|(1&lt;&lt;(x-1)),opt);    dfs(x+1,sum-a[x],now|(1&lt;&lt;(x-1)),opt);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    dfs(1,0,0,0);    dfs(n/2+1,0,0,1);    sort(suma+1,suma+cnta+1,cmp1);    sort(sumb+1,sumb+cntb+1,cmp2);/*    for(ll i=1;i&lt;=cnta;i++)&#123;        printf(&quot;1%lld\n&quot;,suma[i].x);    &#125;    for(ll i=1;i&lt;=cntb;i++)&#123;        printf(&quot;2%lld\n&quot;,sumb[i].x);    &#125;*/        ll r=1;    for(ll l=1;l&lt;=cnta;l++)&#123;        while(-suma[l].x&lt;sumb[r].x&amp;&amp;r&lt;=cntb) r++;        ll now=r;        while(r&lt;=cntb&amp;&amp;-suma[l].x==sumb[r].x)&#123;            if(!vis[suma[l].state|sumb[r].state])&#123;                vis[suma[l].state|sumb[r].state]=1;//                printf(&quot;vis[%lld]=%lld\n&quot;,suma[l].state|sumb[r].state,1ll*vis[suma[l].state|sumb[r].state]);                ans++;            &#125;            r++;        &#125;        if(l&lt;cnta&amp;&amp;suma[l].x==suma[l+1].x) r=now;    &#125;    printf(&quot;%lld\n&quot;,ans-1);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宅男计划</title>
      <link href="/2025/03/14/%E5%AE%85%E7%94%B7%E8%AE%A1%E5%88%92/"/>
      <url>/2025/03/14/%E5%AE%85%E7%94%B7%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-19 21:47</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$dp$不行考虑三分</p><p>发现单峰</p><p>1.理性打表,得到单峰</p><p>2.感性思考,你会发现你买食物次数越多,你钱数越少,你买的好食品更多,你买食物次数越少,你钱数越多,然而你必须买一些价格贵保质期长弥补次数少.</p><p>单峰,我们三分就完了(其实也可以模拟退火,然而我参数爆炸了一直60分)</p><p>那么$check$怎么写?</p><p>贪心,</p><p>考虑排序</p><p>考虑先以保质期排序,然后再以价格排序去掉垃圾(在保质期相同不需要买更贵的,那么它就是垃圾完全没必要买它)</p><p>考虑以价格排序,在保质期相同时买保质期长的</p><p>用保质期排序那么先买保质期长的,还是保质期短的难以确定,所以尝试以价格为基础排序</p><p>我的贪心先贪每一次送外卖都买的,再贪不能全买的,两个相加</p><pre><code>ll check(ll x)&#123;    ll left=m-x*f;//计算还剩多少钱    ll w=left/x;//计算每一轮吃了多少    ll left2=left-w*x;//计算当无法再每一伦都吃情况下剩多少钱    ll now=0,ans=0,j;//now每一轮活的天数,ans计算剩余不能每一轮都吃能活多少天    if(left&lt;0) return 0;//若所有钱全用来买外卖了return 0     for(ll i=1;i&lt;=n;i++)&#123;        ll fen;        if(a[i].t&gt;=now&amp;&amp;(w-a[i].val&gt;=0))&#123;            fen=min(a[i].t-now+1,w/a[i].val);//能买多少,注意和(a[i].t-now+1)            w-=fen*a[i].val;//剩下钱数减少            now+=fen;//每一轮活了now天        &#125;        j=i;        if(w-a[i].val&lt;0) break;    &#125;    left2+=w*x;//剩下钱累加在left2上    ll p;  //和上文类似    for(ll i=j;i&lt;=n;i++) &#123;        if((a[i].t&gt;=now)&amp;&amp;(left2-a[i].val&gt;=0)) &#123;            p=min(left2/a[i].val,x);               ans+=p;            left2-=p*a[i].t;            &#125;            if(ans&gt;0)break;        &#125;    return ans+now*x;&#125;</code></pre><p>总代码我就不放了,我的AC代码有些问题,等改了再放</p><h4 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h4><p>一开始以为是dp,然后愉快的推式子,一看范围</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190819211842916-1074893229.png"></p><p>好像$dp$不行,我推的dp以M为基础,总觉得$dp$很玄学</p><p>最裸的$dp$ :$f[i][j]$表示运了$i$趟食物,剩余钱$j$</p><p>$f[i][j]&#x3D;f[i-1][j-?]+?$总算写出来,然而样例过不了.假设你每买一个你就多活一天</p><p>$f[i][j]$表示不了过期然后</p><p>$f[i][j][k]$表示$i趟j容积k保质期$这样可以推了</p><p>$f[i][j][k]&#x3D;f[i][j-w][k-1]$ $f[i+1][j][0]&#x3D;f[i][j-w][last]$</p><p>本来就时空双爆</p><p>考虑二分答案?,不是单调的,模拟退火?</p><p>于是我开始愉快的退火了,</p><p>然而$check$又非常难写,总算过了样例然而交上去</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190819213242645-651927001.png"></p><p>我以为我调参不行然而我改了也还是$10$分发现$check$写错了,交一发$10$</p><p>改成三分$30$分</p><p>奇妙的是改了改三分变成了$50$,我认为我三分板子错了,去看三分板子,然而并不是三分错了</p><p>觉得$check$太恶心了換了种写法在洛谷上交突然$70$分,然后我忘了我改了哪里突然就又变成了$90$分,那时是$19:27$我觉得胜利在望</p><p>然后改了很多地方仍然$90$,觉得很玄学,开始觉得自己爆$long long$事实上它确实爆了$long<br>long$,我$check$写法太$丑$三个*连在一起爆炸了</p><p>然后又改回原来$check$一直$50$ $50$ $50$ $50$,最后还是写法丑挂掉了</p><p>我的比较函数挂掉了</p><p>我不知道应该买先过期,还是保质期长的,然而我又以时间排序,然后他就挂了</p><p>改成买便宜的,$AC$了</p><p>事实上以时间排序可以$AC$</p><p>去掉垃圾食品就完了,我又图省事没去掉垃圾,</p><p>你先以时间排序,再以价值排序也可以然而我没采取任何一种方案</p><p>然后我就一直挂一直挂</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190820140708454-1115911091.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>约会Rendezvous</title>
      <link href="/2025/03/14/%E7%BA%A6%E4%BC%9ARendezvous/"/>
      <url>/2025/03/14/%E7%BA%A6%E4%BC%9ARendezvous/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-17 17:35</p><h1 id="约会-Rendezvous"><a href="#约会-Rendezvous" class="headerlink" title="约会 Rendezvous"></a>约会 Rendezvous</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个有 nnn 个顶点的有向图，每个顶点有且仅有一条出边。每次询问给出两个顶点 aia_ia​i​​ 和 bib_ib​i​​，求满足以下条件的<br>xix_ix​i​​ 和 yiy_iy​i​​：</p><ul><li>从顶点 aia_ia​i​​ 沿出边走 xix_ix​i​​ 步与从顶点 bib_ib​i​​ 沿出边走 yiy_iy​i​​ 步到达的顶点相同。</li><li>max(xi,yi)\max(x_i, y_i)max(x​i​​,y​i​​) 最小。</li><li>满足以上条件的情况下 min(xi,yi)\min(x_i, y_i)min(x​i​​,y​i​​) 最小。</li><li>如果以上条件没有给出一个唯一的解，则还需要满足 xi≥yix_i \ge y_ix​i​​≥y​i​​.</li></ul><p>如果不存在这样的 xix_ix​i​​ 和 yiy_iy​i​​，则 xi&#x3D;yi&#x3D;−1x_i &#x3D; y_i &#x3D; -1x​i​​&#x3D;y​i​​&#x3D;−1.</p><p>Q：这题是不是非常简单？</p><p>A：毒瘤题。</p><p>Q：毒瘤出题人？</p><p>A：毒瘤出题人。</p><p>Q：是不是比较考验码力，打完想对就能A？</p><p>A：毒瘤卡常，你没有一点卡常技巧是过不了的。</p><p>Q：我卡卡常就能A了是吗？</p><p>A：卡dfs 卡你空间，卡你时间，还特别容易爆栈 你需要特别的姿势！</p><p>34个测试点，让你绝望</p><p>没有看题解过了的毒瘤题</p><p>对于我这个蒟蒻，我调了一天，整整一天，</p><p>day1 晚上开始码 没有看题解 大约想了想，好像可以建反边跑lca</p><p>然后思考它有什么性质，首先题目里保证了只有一个出边，那么相当与保证了每个图都有一个环</p><p>想到可以缩点然后无脑lca 然后又想了想 好像环上比较难处理</p><p>day1 晚上码完 得了 38分 稍微改了改 28分</p><p>day2 重新理了理思路，想到环上可以预处理，但没想到怎么处理，随手打了个单调队列发现不行</p><p>得到了3分的好成绩</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 600000using namespace std;ll head[A],nxt[A],belong[A],ver[A],tot=0,deep[A],dis[A],t,n,m,dfn[A],sta[A],otp=0,num=0,top=0,low[A],f[A][30],cnt=0,ins[A],sum[A],rt[A],bl[A],zuzong[A],fa[A],bl4[A];vector &lt;ll&gt; scc[251001];bool flag[A];void add(ll x,ll y)&#123;nxt[++tot]=head[x];ver[tot]=y;head[x]=tot;&#125;inline ll lca(ll x,ll y)&#123;    if(deep[x]&gt;deep[y])swap(x,y);    for(ll i=t;i&gt;=0;i--)    &#123;        if(deep[x]==deep[y]) break;        if(deep[x]&lt;=deep[f[y][i]]) y=f[y][i];    &#125;    if(x==y) return x;    for(ll i=t;i&gt;=0;i--)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];&#125;void dfs(ll x,ll st,ll t)&#123;    deep[x]=st,flag[x]=1;bl4[x]=otp;    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(flag[y]) continue;        rt[y]=t;        dis[y]=dis[x]+1;        f[y][0]=x;        dfs(y,st+1,t);    &#125;    return ;&#125;ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))&#123;if(c==&#39;-&#39;) f=-1;c=getchar();&#125;    while(isdigit(c))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;c=getchar();&#125;    return f*x;&#125;inline void tarjan(ll x)&#123;    dfn[x]=low[x]=++num;    sta[++top]=x;ins[x]=1;    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(dfn[y]==0)        &#123;            tarjan(y);            low[x]=min(low[x],low[y]);        &#125;        else if(ins[y])            low[x]=min(low[x],dfn[y]);    &#125;    if(dfn[x]==low[x])    &#123;        ++cnt;        ll yy=0,cis=0,lu;        while(1)        &#123;            yy=sta[top--];            ins[yy]=0;            cis++;                bl4[yy]=cnt;            if(yy==x)                break;            scc[cnt].push_back(yy);            belong[yy]=-1;            //printf(&quot;将%lld赋成-1\n&quot;,yy);        &#125;        if(cis&gt;1) scc[cnt].push_back(x),belong[x]=-1;        else cnt--;    &#125;&#125;void tiaotarjan()&#123;    cout&lt;&lt;&quot;***&quot;&lt;&lt;endl;    for(ll i=1;i&lt;=cnt;i++)    &#123;        for(ll j=0;j&lt;scc[i].size();j++)        &#123;            cout&lt;&lt;scc[i][j]&lt;&lt;&quot; &quot;;        &#125;        if(scc[i].size()) cout&lt;&lt;endl;    &#125;            cout&lt;&lt;&quot;***&quot;&lt;&lt;endl;    &#125;void tiaos()&#123;&#125;void work()&#123;    n=read();m=read();    t=log(n)/log(2)+2;    for(ll i=1;i&lt;=n;i++)    &#123;        ll xx=read();        add(xx,i);        //建反图跑tarjan缩点+lca    &#125;    for(ll i=1;i&lt;=n;i++)        if(!dfn[i])    tarjan(i);    top=0;    memset(flag,0,sizeof(flag));    for(ll i=1;i&lt;=cnt;i++)    &#123;        ll size=scc[i].size();otp++;        for(ll ii=0;ii&lt;size;ii++)        &#123;            ll q=scc[i][ii];             for(ll j=head[q];j;j=nxt[j])            &#123;                ll y=ver[j];                if(belong[y]!=-1)                &#123;                    rt[y]=q;                    dfs(y,1,rt[y]);                    f[y][0]=y;                &#125;            &#125;        &#125;    &#125;    for(ll j=1;j&lt;=t;j++)        for(ll i=1;i&lt;=n;i++)            f[i][j]=f[f[i][j-1]][j-1];    /*for(ll i=1;i&lt;=n;i++)    &#123;        if(belong[i]!=-1)        &#123;            printf(&quot;i=%lld rt=%lld deep=%lld\n&quot;,i,rt[i],deep[i]);        &#125;    &#125;*/    for(ll i=1;i&lt;=m;i++)    &#123;            ll xx=read(),yy=read();        if(bl4[xx]==bl4[yy])        &#123;            ll lc=lca(xx,yy);            //printf(&quot;rtx=%lld rty=%lld\n&quot;,rt[xx],rt[yy]);            if(rt[xx]==rt[yy])            &#123;                printf(&quot;%lld %lld\n&quot;,dis[xx]-dis[lc],dis[yy]-dis[lc]);            &#125;            if(rt[xx]!=rt[yy])            &#123;                ll de1=deep[xx],de2=deep[yy];                ll now=bl4[rt[xx]];                ll size=scc[now].size(),ott=0;                bool kais=0;                for(ll ii=0;ii&lt;size*2-1;ii++)                &#123;                        if(ii&gt;size)                    &#123;                        ll j=ii-size;                        if(!kais&amp;&amp;(scc[now][ii]==rt[xx]||scc[now][ii]==rt[yy]))                        &#123;                            kais=1;                        &#125;                        else if(kais==1)                        &#123;                            de1&lt;de2?de1++:de2++;                            if(scc[now][ii]==rt[xx]||scc[now][ii]==rt[yy])                            &#123;                                kais=0;                                break;                            &#125;                        &#125;                    &#125;                    else                    &#123;                        if(!kais&amp;&amp;(scc[now][ii]==rt[xx]||scc[now][ii]==rt[yy]))                        &#123;                            kais=1;                        &#125;                        else if(kais==1)                        &#123;                            de1&lt;de2?de1++:de2++;                            if(scc[now][ii]==rt[xx]||scc[now][ii]==rt[yy])                            &#123;                                kais=0;                                break;                            &#125;                        &#125;                    &#125;                &#125;                printf(&quot;%lld %lld\n&quot;,de1,de2);            &#125;        &#125;        else            printf(&quot;-1 -1\n&quot;);    &#125;&#125;int main()&#123;work();&#125;</code></pre><p>View Code</p><p>和同学讨论这个题发现他们也挺艰难的</p><p>day2 下午 然后经过艰难的辨认+艰难的手膜得到以下代码</p><pre><code>　　　　　　　　　 ll lx,ly,bl=belong[ances[x]],rootx=ances[x],rooty=ances[y],disx=deep[x]-deep[rootx],disy=deep[y]-deep[rooty],xy,yx;                for(ll j=0;j&lt;scc[bl].size();j++)                &#123;                    if(scc[bl][j]==rootx) lx=j;                    if(scc[bl][j]==rooty) ly=j;                &#125;                if(lx&lt;ly)                    xy=ly-lx,yx=sz[bl]-(ly-lx);                else                     yx=lx-ly,xy=sz[bl]-(lx-ly);                if(max(disx+xy,disy)&lt;max(disx,disy+yx)) printf(&quot;%lld %lld\n&quot;,disx+xy,disy);                else if(max(disx+xy,disy)&gt;max(disx,disy+yx)) printf(&quot;%lld %lld\n&quot;,disx,disy+yx);                else                &#123;                    if(min(disx+xy,disy)&lt;min(disx,disy+yx)) printf(&quot;%lld %lld\n&quot;,disx+xy,disy);                    else if(min(disx+xy,disy)&gt;min(disx,disy+yx)) printf(&quot;%lld %lld\n&quot;,disx,disy+yx);                    else if(disx+xy&gt;=disy) printf(&quot;%lld %lld\n&quot;,disx+xy,disy);                    else printf(&quot;%lld %lld\n&quot;,disx,disy+yx);                &#125;</code></pre><p>然后TLE了</p><p>得知tarjan一定会被卡死</p><p>然后改成了dfs（？？？？？？）</p><p>终于吧MLE整过了之后，就接着TLE</p><p>经过几个小时卡常斗争终于A了</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll int#define A 510000const int L=1&lt;&lt;20|1;char buffer[L],*S,*T;#define getchar() ((S==T&amp;&amp;(T=(S=buffer)+fread(buffer,1,L,stdin),S==T))?EOF:*S++)using namespace std;ll head[A],nxt[A],belong[A],ver[A],tot=0,deep[A],t,n,m,otp=0,num=0,f[A][22],cnt=0,bl[A],ances[A],last,sz[A],v[A],cixu[A],chushi=0;inline ll find(ll x)&#123;if(ances[x]==x) return x;return ances[x]=find(ances[x]);&#125;inline void add(ll x,ll y)&#123;nxt[++tot]=head[x];ver[tot]=y;head[x]=tot;&#125;inline ll lca(ll x,ll y)&#123;    if(deep[x]&gt;deep[y])swap(x,y);    ll w;    for(w=0;(1&lt;&lt;w)&lt;=deep[y];w++);    w--;    for(ll i=w;i&gt;=0;i--)    &#123;        if(deep[x]==deep[y]) break;        if(deep[x]&lt;=deep[f[y][i]]) y=f[y][i];    &#125;    if(x==y) return x;    for(ll i=t;i&gt;=0;i--)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];&#125;inline void dfs(ll x,ll pre)&#123;    v[x]=++num;    deep[x]=deep[pre]+1;//    printf(&quot;%lld \n&quot;,deep[x]);    for(ll i=1;(1&lt;&lt;i)&lt;=deep[x];i++)        f[x][i]=f[f[x][i-1]][i-1];    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(v[y]&gt;last)        &#123;            cnt++;            chushi=0;            cixu[x]=++chushi;            sz[cnt]++;            belong[x]=cnt;            ances[x]=x;            for(ll i=x;i!=y;i=f[i][0])            &#123;                cixu[f[i][0]]=++chushi;                belong[f[i][0]]=cnt;                ances[f[i][0]]=f[i][0];                sz[cnt]++;            &#125;        &#125;        else         &#123;            ances[y]=f[y][0]=x            ,dfs(y,x);        &#125;    &#125;&#125;inline ll Read()&#123;    register ll ret;    register char r;    while(r=getchar(),r&lt;&#39;0&#39;||r&gt;&#39;9&#39;);ret=r-48;    while(r=getchar(),r&gt;=&#39;0&#39;&amp;&amp;r&lt;=&#39;9&#39;)ret=ret*10+r-48;    return ret;&#125;inline void work()&#123;    last=0;    n=Read();m=Read();    t=log(n)/log(2)+1;    for(ll i=1;i&lt;=n;i++)    &#123;        ll xx=Read();        add(xx,i);    &#125;    for(ll i=1;i&lt;=n;i++)        if(!v[i])        &#123;            ances[i]=f[i][0]=i;            dfs(i,0);            last=num;        &#125;    for(ll i=1;i&lt;=m;i++)    &#123;            ll x=Read(),y=Read();        if(find(x)!=find(y)&amp;&amp;belong[ances[x]]!=belong[ances[y]]) printf(&quot;-1 -1\n&quot;);        else        &#123;            if(ances[x]==ances[y])            &#123;                ll lc=lca(x,y);                printf(&quot;%d %d\n&quot;,deep[x]-deep[lc],deep[y]-deep[lc]);            &#125;            else            &#123;                ll lx,ly,bl=belong[ances[x]],disx=deep[x]-deep[ances[x]],disy=deep[y]-deep[ances[y]],xy,yx;                lx=cixu[ances[x]];ly=cixu[ances[y]];                if(lx&lt;ly)                    xy=ly-lx,yx=sz[bl]-(ly-lx);                else                     yx=lx-ly,xy=sz[bl]-(lx-ly);                if(max(disx+xy,disy)&lt;max(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx+xy,disy);                else if(max(disx+xy,disy)&gt;max(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx,disy+yx);                else                &#123;                    if(min(disx+xy,disy)&lt;min(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx+xy,disy);                    else if(min(disx+xy,disy)&gt;min(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx,disy+yx);                    else if(disx+xy&gt;=disy) printf(&quot;%d %d\n&quot;,disx+xy,disy);                    else printf(&quot;%d %d\n&quot;,disx,disy+yx);                &#125;            &#125;        &#125;    &#125;&#125;main()&#123;work();&#125;</code></pre><p>View Code</p><p>具体思路</p><p>首先我们会发现图中一定存在环而且仅仅存在一个环，可能有多个可分割的图，每个图都有一个环</p><p>我们要建反图，这样我们就可以跑lca了</p><p>然后我们模拟就完了，对于同一个图上的有如下情况</p><p>一.路径不经过环</p><p>lca完了</p><p>二.路径经过环</p><p>我们发现我们缩点时其实是按照一定顺序缩的，事实上是按照逆边顺序缩的</p><p>于是我们维护一个类似于dfn序的东西就完了</p><p>只在环上维护dfn序，相减就得到了距离</p><p>对于不在一个图上的直接-1 -1</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll int#define A 510000const int L=1&lt;&lt;20|1;char buffer[L],*S,*T;#define getchar() ((S==T&amp;&amp;(T=(S=buffer)+fread(buffer,1,L,stdin),S==T))?EOF:*S++)using namespace std;ll head[A],nxt[A],belong[A],ver[A],tot=0,deep[A],t,n,m,otp=0,num=0,f[A][22],cnt=0,bl[A],ances[A],last,sz[A],v[A],cixu[A],chushi=0;inline ll find(ll x)&#123;if(ances[x]==x) return x;return ances[x]=find(ances[x]);&#125;inline void add(ll x,ll y)&#123;nxt[++tot]=head[x];ver[tot]=y;head[x]=tot;&#125;inline ll lca(ll x,ll y)&#123;    if(deep[x]&gt;deep[y])swap(x,y);    ll w;    for(w=0;(1&lt;&lt;w)&lt;=deep[y];w++);    w--;    for(ll i=w;i&gt;=0;i--)    &#123;        if(deep[x]==deep[y]) break;        if(deep[x]&lt;=deep[f[y][i]]) y=f[y][i];    &#125;    if(x==y) return x;    for(ll i=t;i&gt;=0;i--)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];&#125;inline void dfs(ll x,ll pre)&#123;    v[x]=++num;    deep[x]=deep[pre]+1;//    printf(&quot;%lld \n&quot;,deep[x]);    for(ll i=1;(1&lt;&lt;i)&lt;=deep[x];i++)        f[x][i]=f[f[x][i-1]][i-1];    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(v[y]&gt;last)        &#123;            cnt++;            chushi=0;            cixu[x]=++chushi;            sz[cnt]++;            belong[x]=cnt;            ances[x]=x;            for(ll i=x;i!=y;i=f[i][0])            &#123;                cixu[f[i][0]]=++chushi;                belong[f[i][0]]=cnt;                ances[f[i][0]]=f[i][0];                sz[cnt]++;            &#125;        &#125;        else         &#123;            ances[y]=f[y][0]=x            ,dfs(y,x);        &#125;    &#125;&#125;inline ll Read()&#123;    register ll ret;    register char r;    while(r=getchar(),r&lt;&#39;0&#39;||r&gt;&#39;9&#39;);ret=r-48;    while(r=getchar(),r&gt;=&#39;0&#39;&amp;&amp;r&lt;=&#39;9&#39;)ret=ret*10+r-48;    return ret;&#125;inline void work()&#123;    last=0;    n=Read();m=Read();    t=log(n)/log(2)+1;    for(ll i=1;i&lt;=n;i++)    &#123;        ll xx=Read();        add(xx,i);    &#125;    for(ll i=1;i&lt;=n;i++)        if(!v[i])        &#123;            ances[i]=f[i][0]=i;            dfs(i,0);            last=num;        &#125;    for(ll i=1;i&lt;=m;i++)    &#123;            ll x=Read(),y=Read();        if(find(x)!=find(y)&amp;&amp;belong[ances[x]]!=belong[ances[y]]) printf(&quot;-1 -1\n&quot;);        else        &#123;            if(ances[x]==ances[y])            &#123;                ll lc=lca(x,y);                printf(&quot;%d %d\n&quot;,deep[x]-deep[lc],deep[y]-deep[lc]);            &#125;            else            &#123;                ll lx,ly,bl=belong[ances[x]],disx=deep[x]-deep[ances[x]],disy=deep[y]-deep[ances[y]],xy,yx;                lx=cixu[ances[x]];ly=cixu[ances[y]];                if(lx&lt;ly)                    xy=ly-lx,yx=sz[bl]-(ly-lx);                else                     yx=lx-ly,xy=sz[bl]-(lx-ly);                if(max(disx+xy,disy)&lt;max(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx+xy,disy);                else if(max(disx+xy,disy)&gt;max(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx,disy+yx);                else                &#123;                    if(min(disx+xy,disy)&lt;min(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx+xy,disy);                    else if(min(disx+xy,disy)&gt;min(disx,disy+yx)) printf(&quot;%d %d\n&quot;,disx,disy+yx);                    else if(disx+xy&gt;=disy) printf(&quot;%d %d\n&quot;,disx+xy,disy);                    else printf(&quot;%d %d\n&quot;,disx,disy+yx);                &#125;            &#125;        &#125;    &#125;&#125;main()&#123;work();&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>压力</title>
      <link href="/2025/03/14/%E5%8E%8B%E5%8A%9B/"/>
      <url>/2025/03/14/%E5%8E%8B%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-15 21:08</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190715210435107-78860853.png"></p><p>首先如果路径上有割点一定是必经点，然后如果是环上的点（除了割点）一定有多条路径可以到，所以环上（除了割点起点终点）都不必经。</p><p>所以点双缩点，重新建图（普通建图or圆方）</p><p>那么对于每组询问lca加普通树差标记一下，</p><p>对于每组询问拿数组zz记录起点终点，</p><p>最后dfs扫一遍</p><p>，结束时如果不为割点，直接输出zz</p><p>否则输出dfs扫出的ans</p><p>必经点模版题</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define pt printf(&quot;******\n&quot;)#define A 1000000using namespace std;ll tot=0,head[A],sta[A],low[A],dfn[A],nxt[A],ver[A],deep[A],belong[A],cut[A];ll tc=0,head_c[A],nxt_c[A],ver_c[A],sz[A],f[A][30],ans[A],zz[A];ll n,m,q,t,num=0,cnt=0,root,top=0;vector&lt;ll&gt; scc[A];bool flag[A],vis[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void add_c(ll x,ll y)&#123;    nxt_c[++tc]=head_c[x],head_c[x]=tc,ver_c[tc]=y;&#125;void tarjan(ll x)&#123;    low[x]=dfn[x]=++num;    sta[++top]=x;ll vis=0;    if(x==root&amp;&amp;!head[x])    &#123;        cnt++;        belong[x]=cnt;        scc[cnt].push_back(x);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(!dfn[y])&#123;            tarjan(y);            low[x]=min(low[x],low[y]);            if(dfn[x]&lt;=low[y])&#123;                vis++;                if(x!=root||vis&gt;1) cut[x]=1;                cnt++;                ll z;                do&#123;                    z=sta[top--];                    belong[z]=cnt;                    scc[cnt].push_back(z);                &#125;while(z!=y);                belong[x]=cnt;                scc[cnt].push_back(x);            &#125;        &#125;        else low[x]=min(low[x],dfn[y]);    &#125;&#125;inline ll lca(ll x,ll y)&#123;    if(deep[x]&gt;deep[y]) swap(x,y);    ll w;    for(w=0;(1&lt;&lt;w)&lt;=deep[y];w++);    w--;    for(ll i=w;i&gt;=0;i--)    &#123;//        printf(&quot;deep[%lld]=%lld deep[%lld]=%lld f[%lld]=%lld\n&quot;,x,deep[x],y,deep[y],i,f[y][i]);                if(deep[x]&lt;=deep[f[y][i]]) y=f[y][i];        if(deep[x]==deep[y]) break;    &#125;    if(x==y) return x;    for(ll i=w;i&gt;=0;i--)&#123;        if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];    &#125;    return f[y][0];&#125;void dfs2(ll x,ll de)&#123;    deep[x]=de;flag[x]=1;    for(ll i=head_c[x];i;i=nxt_c[i])&#123;        ll y=ver_c[i];        if(flag[y])            continue;        f[y][0]=x;        dfs2(y,de+1);    &#125;&#125;ll dfs3(ll x)&#123;    vis[x]=1;    for(ll i=head_c[x];i;i=nxt_c[i])&#123;        ll y=ver_c[i];        if(vis[y]) continue;        ll to=dfs3(y);        ans[x]+=to;    &#125;    return ans[x];&#125;int main()&#123;//    freopen(&quot;mkd.txt&quot;,&quot;r&quot;,stdin);//    freopen(&quot;wa.txt&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;q);    t=log(n)/log(2)+5;    for(ll i=1;i&lt;=m;i++)&#123;        ll x,y;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);        add(x,y);add(y,x);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        if(!dfn[i]) root=i,tarjan(i);    &#125;    num=cnt;    for(ll i=1;i&lt;=n;i++)    if(cut[i]) belong[i]=++num/*,printf(&quot;gd=%lld\n&quot;,i)*/;    for(ll i=1;i&lt;=cnt;i++)&#123;        ll size=scc[i].size();        for(ll j=0;j&lt;size;j++)&#123;            if(cut[scc[i][j]])&#123;                add_c(i,belong[scc[i][j]]);                add_c(belong[scc[i][j]],i);            &#125;        &#125;    &#125;    dfs2(1,1),f[1][0]=1;    for(ll j=1;j&lt;=t;j++)        for(ll i=1;i&lt;=num;i++)            f[i][j]=f[f[i][j-1]][j-1];    /*for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;belong=%lld\n&quot;,belong[i]);        &#125;    for(ll i=1;i&lt;=num;i++)    &#123;        printf(&quot;deep[i]=%lld f[i][0]=%lld belong=%lld\n&quot;,deep[belong[i]],f[belong[i]][0],belong[i]);    &#125;*/    for(ll i=1;i&lt;=q;i++)&#123;        ll x,y;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);        ll lc=lca(belong[x],belong[y]);//        cout&lt;&lt;lc&lt;&lt;endl;        zz[x]++,zz[y]++;//        printf(&quot;x=%lld y=%lld lc=%lld lf=%lld\n&quot;,belong[x],belong[y],lc,f[lc][0]);        ans[belong[x]]++;        ans[belong[y]]++;        ans[lc]--;        if(f[lc][0]!=lc)ans[f[lc][0]]--;    &#125;    dfs3(1);    for(ll i=1;i&lt;=n;i++)&#123;        if(cut[i]) cout&lt;&lt;ans[belong[i]]&lt;&lt;endl;        else cout&lt;&lt;zz[i]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消防 直径性质</title>
      <link href="/2025/03/14/%E6%B6%88%E9%98%B2%20%E7%9B%B4%E5%BE%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2025/03/14/%E6%B6%88%E9%98%B2%20%E7%9B%B4%E5%BE%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-23 19:39</p><p>题目大意</p><p>先放直径性质(转自<a href="https://www.cnblogs.com/knife-rose/p/11189707.html">刀与玫瑰</a>)</p><p>1.直径两端点一定是叶子节点。</p><p>2.距任意点最远点一定是直径的端点，据所有点最大值最小的点一定是直径的中点。</p><p>3.两棵树相连，新直径的两端点一定是原四个端点中的两个</p><p>4.两棵树相连，新直径长度最小为max(max(直径1，直径2)，半径1+半径2+新边长度 )<br>（设k为直径中最接近中点的节点，半径&#x3D;max(tot-d[k],d[k])）</p><p>5.一棵树上接一个叶子结点，直径最多改变一个端点</p><p>6.若一棵树存在多条直径，多条直径交于一点，且交点是直径的严格中点（中点可能在某条边内）</p><p><a href="https://www.cnblogs.com/kzj-pwq/p/9512073.html">题解</a></p><p>先放一份别人的题解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树题目乱堆</title>
      <link href="/2025/03/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E9%A2%98%E7%9B%AE%E4%B9%B1%E5%A0%86/"/>
      <url>/2025/03/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E9%A2%98%E7%9B%AE%E4%B9%B1%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-15 15:15</p><h2 id="联"><a href="#联" class="headerlink" title="联"></a>联</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191015150533973-283161231.png"></p><p>范围$1e18$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先看到范围这么大,肯定要离散化的,</p><p>发现最后最左面0位置只可能 <em><strong>修改过</strong></em> 的位置-1,+1,等,不可能在一段区间中间凭空出现</p><p>于是可以这样离散化</p><pre><code>        if(l[i]!=1)            lsh[++lsh[0]]=l[i]-1;        lsh[++lsh[0]]=l[i];        lsh[++lsh[0]]=r[i];        lsh[++lsh[0]]=r[i]+1;</code></pre><p>然后考虑如何维护</p><p>两种方法:</p><p>1.维护最左0出现位置,最左1出现位置</p><p>这样异或操作就swap一下就好了</p><p>我没打这种</p><p>2.维护区间0个数,</p><p>这样异或操作就转化成了区间长度-0个数</p><p>查询如果左子树有0优先走左子树,否则走右子树,递归到叶子</p><p>3.keduoli树水过</p><p>这里用的第2种方法</p><p><em><strong>两种懒标记不可同时存在,</strong></em></p><p>down</p><pre><code>void down(ll x)&#123;//    printf(&quot;l=%lld r=%lld tr[lson].f1=%lld tr[rson].f1=%lld\n&quot;,tr[x].l,tr[x].r,tr[x&lt;&lt;1].f1,tr[x&lt;&lt;1|1].f1);    if(tr[x].f1)&#123;        if(tr[x&lt;&lt;1].f2)&#123;            tr[x&lt;&lt;1].f2=0;            tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len-tr[x&lt;&lt;1].sum;        &#125;        if(tr[x&lt;&lt;1|1].f2)&#123;            tr[x&lt;&lt;1|1].f2=0;            tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len-tr[x&lt;&lt;1|1].sum;        &#125;        tr[x&lt;&lt;1].f1=tr[x].f1;        tr[x&lt;&lt;1].sum=((tr[x].f1==2)?tr[x&lt;&lt;1].len:0);        tr[x&lt;&lt;1|1].f1=tr[x].f1;        tr[x&lt;&lt;1|1].sum=((tr[x].f1==2)?tr[x&lt;&lt;1|1].len:0);    &#125;    else if(tr[x].f2)&#123;//区间异或        if(tr[x&lt;&lt;1].f2)&#123;            tr[x&lt;&lt;1].f2=0;            tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len-tr[x&lt;&lt;1].sum;        &#125;        else if(tr[x&lt;&lt;1].f1==1)&#123;            tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len;            tr[x&lt;&lt;1].f1=2;            tr[x&lt;&lt;1].f2=0;        &#125;        else if(tr[x&lt;&lt;1].f1==2)&#123;            tr[x&lt;&lt;1].sum=0;            tr[x&lt;&lt;1].f1=1;            tr[x&lt;&lt;1].f2=0;        &#125;        else tr[x&lt;&lt;1].f2=1,tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len-tr[x&lt;&lt;1].sum;        if(tr[x&lt;&lt;1|1].f2)&#123;            tr[x&lt;&lt;1|1].f2=0;            tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len-tr[x&lt;&lt;1|1].sum;        &#125;        else if(tr[x&lt;&lt;1|1].f1==1)&#123;            tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len;            tr[x&lt;&lt;1|1].f1=2;            tr[x&lt;&lt;1|1].f2=0;        &#125;        else if(tr[x&lt;&lt;1|1].f1==2)&#123;            tr[x&lt;&lt;1|1].sum=0;            tr[x&lt;&lt;1|1].f1=1;            tr[x&lt;&lt;1|1].f2=0;        &#125;        else tr[x&lt;&lt;1|1].f2=1,tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len-tr[x&lt;&lt;1|1].sum;    &#125;    //    printf(&quot;down*** f1=%lld f2=%lld lson.f2=%lld rson.f2=%lld  l=%lld r=%lld tr[x].sum=%lld lson l=%lld r=%lld sum=%lld rson l=%lld r=%lld sum=%lld\n&quot;,tr[x].f1,tr[x].f2,tr[x&lt;&lt;1].f2,tr[x&lt;&lt;1|1].f2,tr[x].l,tr[x].r,tr[x].sum,tr[x&lt;&lt;1].l,tr[x&lt;&lt;1].r,tr[x&lt;&lt;1].sum,tr[x&lt;&lt;1|1].l,tr[x&lt;&lt;1|1].r,tr[x&lt;&lt;1|1].sum);//    printf(&quot;l=%lld r=%lld lson.f1=%lld f2=%lld sum=%lld l=%lld r=%lld rson.f1=%lld f2=%lld sum=%lld\n&quot;,tr[x&lt;&lt;1].l,tr[x&lt;&lt;1].r,tr[x&lt;&lt;1].f1,tr[x&lt;&lt;1].f2,tr[x&lt;&lt;1].sum,tr[x&lt;&lt;1|1].l,tr[x&lt;&lt;1|1].r,tr[x&lt;&lt;1|1].f1,tr[x&lt;&lt;1|1].f2,tr[x&lt;&lt;1|1].sum);    tr[x].f1=0;    tr[x].f2=0;&#125;</code></pre><p>注意,这里区间修改因为 <em><strong>两种懒标记不可同时存在,</strong></em> 所以也要进行这种操作</p><p>可能两次都修改同一个区间,这样你上一个标记没下传,这一个标记就又来了</p><p>特殊处理一下</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 10010101ll c[A],l[A],r[A],opt[A],now[A],lsh[A],yuan[A];ll ans,canqj=1,rest,n,len;struct node&#123;    ll l,r,f1,f2,len,sum,yu;&#125;tr[A];void up(ll x)&#123;    tr[x].sum=tr[x&lt;&lt;1].sum+tr[x&lt;&lt;1|1].sum;//    printf(&quot;x.l=%lld x.r=%lld tr[x].sum=%lld\n&quot;,tr[x].l,tr[x].r,tr[x].sum);&#125;void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    tr[x].len=r-l+1;    if(l==r)&#123;        tr[x].sum=1;        tr[x].yu=lsh[l];        return;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);    up(x);&#125;void down(ll x)&#123;//    printf(&quot;l=%lld r=%lld tr[lson].f1=%lld tr[rson].f1=%lld\n&quot;,tr[x].l,tr[x].r,tr[x&lt;&lt;1].f1,tr[x&lt;&lt;1|1].f1);    if(tr[x].f1)&#123;        if(tr[x&lt;&lt;1].f2)&#123;            tr[x&lt;&lt;1].f2=0;            tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len-tr[x&lt;&lt;1].sum;        &#125;        if(tr[x&lt;&lt;1|1].f2)&#123;            tr[x&lt;&lt;1|1].f2=0;            tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len-tr[x&lt;&lt;1|1].sum;        &#125;        tr[x&lt;&lt;1].f1=tr[x].f1;        tr[x&lt;&lt;1].sum=((tr[x].f1==2)?tr[x&lt;&lt;1].len:0);        tr[x&lt;&lt;1|1].f1=tr[x].f1;        tr[x&lt;&lt;1|1].sum=((tr[x].f1==2)?tr[x&lt;&lt;1|1].len:0);    &#125;    else if(tr[x].f2)&#123;//区间异或        if(tr[x&lt;&lt;1].f2)&#123;            tr[x&lt;&lt;1].f2=0;            tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len-tr[x&lt;&lt;1].sum;        &#125;        else if(tr[x&lt;&lt;1].f1==1)&#123;            tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len;            tr[x&lt;&lt;1].f1=2;            tr[x&lt;&lt;1].f2=0;        &#125;        else if(tr[x&lt;&lt;1].f1==2)&#123;            tr[x&lt;&lt;1].sum=0;            tr[x&lt;&lt;1].f1=1;            tr[x&lt;&lt;1].f2=0;        &#125;        else tr[x&lt;&lt;1].f2=1,tr[x&lt;&lt;1].sum=tr[x&lt;&lt;1].len-tr[x&lt;&lt;1].sum;        if(tr[x&lt;&lt;1|1].f2)&#123;            tr[x&lt;&lt;1|1].f2=0;            tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len-tr[x&lt;&lt;1|1].sum;        &#125;        else if(tr[x&lt;&lt;1|1].f1==1)&#123;            tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len;            tr[x&lt;&lt;1|1].f1=2;            tr[x&lt;&lt;1|1].f2=0;        &#125;        else if(tr[x&lt;&lt;1|1].f1==2)&#123;            tr[x&lt;&lt;1|1].sum=0;            tr[x&lt;&lt;1|1].f1=1;            tr[x&lt;&lt;1|1].f2=0;        &#125;        else tr[x&lt;&lt;1|1].f2=1,tr[x&lt;&lt;1|1].sum=tr[x&lt;&lt;1|1].len-tr[x&lt;&lt;1|1].sum;    &#125;    //    printf(&quot;down*** f1=%lld f2=%lld lson.f2=%lld rson.f2=%lld  l=%lld r=%lld tr[x].sum=%lld lson l=%lld r=%lld sum=%lld rson l=%lld r=%lld sum=%lld\n&quot;,tr[x].f1,tr[x].f2,tr[x&lt;&lt;1].f2,tr[x&lt;&lt;1|1].f2,tr[x].l,tr[x].r,tr[x].sum,tr[x&lt;&lt;1].l,tr[x&lt;&lt;1].r,tr[x&lt;&lt;1].sum,tr[x&lt;&lt;1|1].l,tr[x&lt;&lt;1|1].r,tr[x&lt;&lt;1|1].sum);//    printf(&quot;l=%lld r=%lld lson.f1=%lld f2=%lld sum=%lld l=%lld r=%lld rson.f1=%lld f2=%lld sum=%lld\n&quot;,tr[x&lt;&lt;1].l,tr[x&lt;&lt;1].r,tr[x&lt;&lt;1].f1,tr[x&lt;&lt;1].f2,tr[x&lt;&lt;1].sum,tr[x&lt;&lt;1|1].l,tr[x&lt;&lt;1|1].r,tr[x&lt;&lt;1|1].f1,tr[x&lt;&lt;1|1].f2,tr[x&lt;&lt;1|1].sum);    tr[x].f1=0;    tr[x].f2=0;&#125;void seg_add(ll x,ll l,ll r,ll val)&#123;//    printf(&quot;l=%lld r=%lld tr[x].l=%lld tr[x].r=%lld\n&quot;,l,r,tr[x].l,tr[x].r);        if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        if(val==3)&#123;//异或            if(tr[x].f2)&#123;                tr[x].f2=0;                tr[x].sum=tr[x].len-tr[x].sum;            &#125;            else if(tr[x].f1==1)&#123;                tr[x].sum=tr[x].len;                tr[x].f1=2;                tr[x].f2=0;            &#125;            else if(tr[x].f1==2)&#123;                tr[x].sum=0;                tr[x].f1=1;                tr[x].f2=0;            &#125;            else tr[x].f2=1,tr[x].sum=tr[x].len-tr[x].sum;        &#125;        else if(val==1)&#123;//区间赋值1            tr[x].sum=0;            tr[x].f1=1;            tr[x].f2=0;        &#125;        else if(val==2)&#123;            tr[x].sum=tr[x].len;            tr[x].f1=2;            tr[x].f2=0;        &#125;//        printf(&quot;havefindit l=%lld r=%lld val=%lld val=%lld\n&quot;,tr[x].l,tr[x].r,tr[x].f1,val);        return ;    &#125;    if(tr[x].f1||tr[x].f2) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l)seg_add(x&lt;&lt;1,l,r,val);    if(mid&lt;r) seg_add(x&lt;&lt;1|1,l,r,val);    up(x);&#125;void query(ll x)&#123;    if(tr[x].l==tr[x].r)&#123;        ans=lsh[tr[x].l];        return ;    &#125;//    printf(&quot;query l=%lld r=%lld f1=%lld f2=%lld\n&quot;,tr[x].l,tr[x].r,tr[x].f1,tr[x].f2);    if(tr[x].f1||tr[x].f2) down(x);    if(tr[x&lt;&lt;1].sum) query(x&lt;&lt;1);    else query(x&lt;&lt;1|1);    up(x);&#125;void check(ll x)&#123;//    printf(&quot;l=%lld r%lld f1=%lld f2=%lld sum=%lld\n&quot;,tr[x].l,tr[x].r,tr[x].f1,tr[x].f2,tr[x].sum);    if(tr[x].l==tr[x].r) return ;    check(x&lt;&lt;1);    check(x&lt;&lt;1|1);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    lsh[++lsh[0]]=1;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;opt[i],&amp;l[i],&amp;r[i]);        if(l[i]!=1)            lsh[++lsh[0]]=l[i]-1;        lsh[++lsh[0]]=l[i];        lsh[++lsh[0]]=r[i];        lsh[++lsh[0]]=r[i]+1;    &#125;    sort(lsh+1,lsh+lsh[0]+1);    len=unique(lsh+1,lsh+lsh[0]+1)-lsh-1;//    for(ll i=1;i&lt;=lsh[0];i++)&#123;//        printf(&quot;lsh[i]=%lld len=%lld\n&quot;,lsh[i],len);//    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        l[i]=lower_bound(lsh+1,lsh+len+1,l[i])-lsh;        r[i]=lower_bound(lsh+1,lsh+len+1,r[i])-lsh;//        printf(&quot;l=%lld r=%lld\n&quot;,l[i],r[i]);    &#125;    built(1,1,len);    for(ll i=1;i&lt;=n;i++)&#123;        seg_add(1,l[i],r[i],opt[i]);            query(1);//        check(1);        printf(&quot;%lld\n&quot;,ans);    &#125;&#125;</code></pre><p>View Code</p><h2 id="幸运字符"><a href="#幸运字符" class="headerlink" title="幸运字符"></a>幸运字符</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个由4，7组成字符串，动态最长不下降子序列</p><p>区间反转</p><p>随便记录4,7,47即可,因为包含翻转所以还要记录74</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 10010010struct node&#123;    ll l,r,_4,_7,_74,_47,f;&#125;tr[A];char ch[A],ch2[10];ll n,m;void up(ll x)&#123;    tr[x]._4=tr[x&lt;&lt;1]._4+tr[x&lt;&lt;1|1]._4;    tr[x]._7=tr[x&lt;&lt;1]._7+tr[x&lt;&lt;1|1]._7;    tr[x]._47=max((tr[x&lt;&lt;1]._4+tr[x&lt;&lt;1|1]._7),max(tr[x&lt;&lt;1]._4+tr[x&lt;&lt;1|1]._47,tr[x&lt;&lt;1]._47+tr[x&lt;&lt;1|1]._7));    tr[x]._74=max((tr[x&lt;&lt;1]._7+tr[x&lt;&lt;1|1]._4),max(tr[x&lt;&lt;1]._74+tr[x&lt;&lt;1|1]._4,tr[x&lt;&lt;1]._7+tr[x&lt;&lt;1|1]._74));//    printf(&quot;tr[%lld].l=%lld r=%lld _4=%lld _7=%lld _47=%lld _74=%lld tr[ls].l=%lld r=%lld _4=%lld _7=%lld _47=%lld _74=%lld tr[rs].l=%lld r=%lld _4=%lld _7=%lld _47=%lld _74=%lld\n&quot;,x,tr[x].l,tr[x].r,tr[x]._4,tr[x]._7,tr[x]._47,tr[x]._74,tr[x&lt;&lt;1].l,tr[x&lt;&lt;1].r,tr[x&lt;&lt;1]._4,tr[x&lt;&lt;1]._7,tr[x&lt;&lt;1]._47,tr[x&lt;&lt;1]._74,tr[x&lt;&lt;1|1].l,tr[x&lt;&lt;1|1].r,tr[x&lt;&lt;1|1]._4,tr[x&lt;&lt;1|1]._7,tr[x&lt;&lt;1|1]._47,tr[x&lt;&lt;1|1]._74);&#125;void down(ll x)&#123;    swap(tr[x&lt;&lt;1]._4,tr[x&lt;&lt;1]._7);    swap(tr[x&lt;&lt;1]._47,tr[x&lt;&lt;1]._74);    swap(tr[x&lt;&lt;1|1]._4,tr[x&lt;&lt;1|1]._7);    swap(tr[x&lt;&lt;1|1]._47,tr[x&lt;&lt;1|1]._74);    tr[x&lt;&lt;1].f^=1,tr[x&lt;&lt;1|1].f^=1;    tr[x].f=0;&#125;void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        if(ch[l]==&#39;4&#39;)    tr[x]._4=1;        else tr[x]._7=1;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);    up(x);&#125;void change(ll x,ll l,ll r)&#123;    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        swap(tr[x]._4,tr[x]._7);        swap(tr[x]._47,tr[x]._74);            tr[x].f^=1;        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l)change(x&lt;&lt;1,l,r);    if(mid&lt;r) change(x&lt;&lt;1|1,l,r);    up(x);&#125;void query(ll x)&#123;    printf(&quot;tr[x].l=%lld r=%lld _4=%lld _7=%lld _47=%lld _74=%lld\n&quot;,tr[x].l,tr[x].r,tr[x]._4,tr[x]._7,tr[x]._47,tr[x]._74);    if(tr[x].l==tr[x].r) return ;    query(x&lt;&lt;1);    query(x&lt;&lt;1|1);&#125;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    scanf(&quot;%s&quot;,ch+1);    built(1,1,n);//    query(1);    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%s&quot;,ch2+1);//        printf(&quot;i=%lld\n&quot;,i);        if(ch2[1]==&#39;c&#39;)&#123;            ll maxx=max(max(tr[1]._4,tr[1]._7),tr[1]._47);            printf(&quot;%lld\n&quot;,maxx);        &#125;        else &#123;            ll l,r;            scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);            change(1,l,r);        &#125;//        query(1);    &#125;&#125;</code></pre><p>View Code</p><h2 id="线段树维护hash"><a href="#线段树维护hash" class="headerlink" title="线段树维护hash"></a>线段树维护hash</h2><p>一般用于必须满足某个顺序时可以用</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1010100#define rill 233using namespace std;struct node&#123;    ll l,r,jz;    unsigned ll val;    void init()&#123;        jz=0;val=0;    &#125;&#125;tr[A];unsigned ll h[A],p[A];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    tr[x].init();    if(l==r)&#123;        tr[x].val=0;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void down(ll x)&#123;//    tr[x&lt;&lt;1].jz+=tr[x].jz;    tr[x&lt;&lt;1|1].jz+=tr[x].jz;    tr[x&lt;&lt;1].val*=p[tr[x].jz];    tr[x&lt;&lt;1|1].val*=p[tr[x].jz];    tr[x&lt;&lt;1].val+=tr[x].val;    tr[x&lt;&lt;1|1].val+=tr[x].val;    tr[x].jz=0;tr[x].val=0;&#125;void seg_add(ll x,ll l,ll r,ll d)&#123;    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;//        tr[x].val=tr[x].val*233+d;tr[x].jz++;return ;    &#125;    if(tr[x].jz) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l)seg_add(x&lt;&lt;1,l,r,d);    if(mid&lt;r) seg_add(x&lt;&lt;1|1,l,r,d);&#125;ll n,k,t;ll ans=0;void find(ll x)&#123;    if(tr[x].l==tr[x].r)&#123;        if(tr[x].val==h[k])            ans++;        return ;    &#125;    if(tr[x].jz) down(x);    find(x&lt;&lt;1);find(x&lt;&lt;1|1);&#125;void print(ll x)&#123;    printf(&quot;l=%lld r=%lld jz=%lld val=&quot;,tr[x].l,tr[x].r,tr[x].jz); cout&lt;&lt;tr[x].val&lt;&lt;endl;    if(tr[x].l==tr[x].r) return ;    print(x&lt;&lt;1);print(x&lt;&lt;1|1);&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;t);    p[0]=1;    for(ll i=1;i&lt;=k;i++)        h[i]=h[i-1]*233+i,p[i]=p[i-1]*233;    built(1,1,n);    while(t--)&#123;        ll l,r,x;        scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;x);        seg_add(1,l,r,x);//        print(1);    &#125;    find(1);    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>天才绅士少女助手克里斯蒂娜「推柿子」</title>
      <link href="/2025/03/14/%E5%A4%A9%E6%89%8D%E7%BB%85%E5%A3%AB%E5%B0%91%E5%A5%B3%E5%8A%A9%E6%89%8B%E5%85%8B%E9%87%8C%E6%96%AF%E8%92%82%E5%A8%9C%E3%80%8C%E6%8E%A8%E6%9F%BF%E5%AD%90%E3%80%8D/"/>
      <url>/2025/03/14/%E5%A4%A9%E6%89%8D%E7%BB%85%E5%A3%AB%E5%B0%91%E5%A5%B3%E5%8A%A9%E6%89%8B%E5%85%8B%E9%87%8C%E6%96%AF%E8%92%82%E5%A8%9C%E3%80%8C%E6%8E%A8%E6%9F%BF%E5%AD%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-09 20:35</p><p>pdf往下翻突然看见一个克里斯蒂娜</p><p>感觉就像人群当中突然钻出来一个光头!</p><p>$\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r} {(x_i<em>y_j-x_j</em>y_i)}^2$</p><p>带修改,</p><p>$\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r}<br>{x_i}^2*{y_j}^2+\sum\limits_{l&lt;&#x3D;j&lt;i&lt;&#x3D;r}{x_i}^2*{y_j}^2-\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r}2<em>x_i</em>x_j<em>y_i</em>y_j$</p><p>$\sum\limits_{l&lt;&#x3D;i,j&lt;&#x3D;r,[i!&#x3D;j]} {x_i}^2*{y_j}^2-\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r}<br>2<em>x_i</em>x_j<em>y_i</em>x_j$</p><p>$\sum\limits_{l&lt;&#x3D;i,j&lt;&#x3D;r,[i可以&#x3D;j]}<br>{x_i}^2*{y_j}^2-\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}x_i<em>y_i-\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r}<br>2</em>x_i<em>x_j</em>y_i*y_j$</p><p>$(\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}{x_i}^2) (\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r} {y_i}^2)<br>-\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r} {x_i}^2*{y_i}^2-2*\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r}<br>x_i<em>x_j</em>y_i*y_j$</p><p>这里$-\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r} {x_i}^2*{y_i}^2-2*\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r}<br>x_i<em>x_j</em>y_i<em>y_j&#x3D;-(\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}x_i</em>y_i)^2$</p><p>推导过程:</p><p>$2*\sum\limits_{l&lt;&#x3D;i&lt;j&lt;&#x3D;r} x_i<em>x_j</em>y_i*y_j$用上面的套路拆开</p><p>$\sum\limits_{l&lt;&#x3D;i,j&lt;&#x3D;r[i!&#x3D;j]} x_i<em>x_j</em>y_i*y_j$</p><p>即$\sum\limits_{l&lt;&#x3D;i,j&lt;&#x3D;r[i可以&#x3D;j]} x_i<em>x_j</em>y_i<em>y_j-\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}<br>{x_i}^2</em>{y_i}^2$</p><p>后面这一部分和前面消掉了</p><p>前面这部分即$\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}<br>x_i<em>y_j</em>\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}x_i<em>y_j$即$(\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}x_i</em>y_i)^2$</p><p>$(\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}{x_i}^2)(\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}{y_i}^2)-(\sum\limits_{l&lt;&#x3D;i&lt;&#x3D;r}x_i*y_i)^2$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心只能过样例 loj515</title>
      <link href="/2025/03/14/%E8%B4%AA%E5%BF%83%E5%8F%AA%E8%83%BD%E8%BF%87%E6%A0%B7%E4%BE%8B%20loj515/"/>
      <url>/2025/03/14/%E8%B4%AA%E5%BF%83%E5%8F%AA%E8%83%BD%E8%BF%87%E6%A0%B7%E4%BE%8B%20loj515/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-23 19:27</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190923191611293-941363085.png"></p><p>范围$100$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>比较裸的式子</p><p>$f[i][j]$表示枚举到第$i$位有没有和为$j$方案</p><p>只有$0$或$1$ $f[i][j]&#x3D;f[i-1][j-val*val]$</p><p>答案$\sum\limits f[n][i]$</p><p>范围$1000000$$((1-100)^2 *100)$</p><p>复杂度爆炸,可以滚动数组,得17分</p><p>考虑优化,$bitset$,</p><p>$bitset$表示实际值是否可以凑出</p><p>$f[i]|&#x3D;f[i-1]&lt;&lt;(val*val)$</p><p>注意我们这里维护的是一个类似前缀和的东西</p><p>例如(举个例子不保证正确性)</p><p>你$f[1]$二进制下$11$,(即可凑出1 , 2)</p><p>然后你$f[2]$可以取$1$,那么你在第二位可以凑出就是$011$(可凑出2,3)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111bitset&lt;A&gt; f[101];ll a[101],b[101];ll n;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)            scanf(&quot;%lld%lld&quot;,&amp;a[i],&amp;b[i]);    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=a[i];j&lt;=b[i];j++)&#123;            if(i==1)                f[i][j*j]=1;            else f[i]|=f[i-1]&lt;&lt;(j*j);        &#125;    &#125;    printf(&quot;%lld\n&quot;,1ll*f[n].count());&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数颜色</title>
      <link href="/2025/03/14/%E6%95%B0%E9%A2%9C%E8%89%B2/"/>
      <url>/2025/03/14/%E6%95%B0%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-03 21:31</p><p>此数颜色非彼数颜色,</p><p>彼者带修莫队,主席树,树套树,分块,权值线段树皆可A之</p><p>而此者带修莫队,树套树,分块皆不可A之</p><p>题简单,而数据异常之巨也,卡分块，卡权值线段树</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190803212436973-359893981.png"></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190803212502074-140663981.png"></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190803212531825-1994372064.png"></p><p>从11.00即开始卡常,然而不让我过</p><h3 id="对于分块"><a href="#对于分块" class="headerlink" title="对于分块"></a>对于分块</h3><p>使用register inline fread 展开 不写函数 二进制优化 fwrite puts 单词拓展 英语优化 等卡常</p><p>unorded_map,0分ce</p><p>set 60分TLE</p><p>map 40分TLE</p><p>桶 70分MLE</p><p>桶+离散化 90分TLE</p><p>最后还是没有过掉</p><h3 id="对于权值线段树"><a href="#对于权值线段树" class="headerlink" title="对于权值线段树"></a>对于权值线段树</h3><p>各种卡常往上hu 100分</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数位dp从会打模板到不会打模板</title>
      <link href="/2025/03/14/%E6%95%B0%E4%BD%8Ddp%E4%BB%8E%E4%BC%9A%E6%89%93%E6%A8%A1%E6%9D%BF%E5%88%B0%E4%B8%8D%E4%BC%9A%E6%89%93%E6%A8%A1%E6%9D%BF/"/>
      <url>/2025/03/14/%E6%95%B0%E4%BD%8Ddp%E4%BB%8E%E4%BC%9A%E6%89%93%E6%A8%A1%E6%9D%BF%E5%88%B0%E4%B8%8D%E4%BC%9A%E6%89%93%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-09 17:07</p><p>打了几个数位$dp$，发现自己除了会打模板之外没有任何长进，遇到非模板题依然什么都不会</p><p>那么接下来这篇文章将介绍如何打模板（滑稽）</p><p>假设我们要处理$l—-r$</p><p>采用记忆化搜索的方式，枚举$&lt;&#x3D;r$每一种情况，枚举每一位，然后再枚举$&lt;&#x3D;l-1$每一种情况，然后两个值相减即可</p><p>我们可以比较轻松打出一个模板</p><pre><code>ll dfs(ll x,ll pre,ll lead,ll limit)&#123;    if(x&gt;pos) return 1;    if(!limit&amp;&amp;f[x][pre]) return f[x][pre];    ll ans=0;    ll mx=limit?maxn[pos-x+1]:9;    for(ll i=0;i&lt;=mx;i++)&#123;        if(????????) continue;        if(lead&amp;&amp;i==0) ans+=dfs(x+1,-2,1,limit&amp;&amp;(i==mx));        else ans+=dfs(x+1,i,0,limit&amp;&amp;(i==mx));    &#125;    if(!limit&amp;&amp;!lead) f[x][pre]=ans;    return ans;&#125;</code></pre><p>解释一下$limit$是什么</p><p>假设有一个数</p><p>$1\ 2\ 3\ 4\ 5\ 6$</p><p>$1\ 2\ 3\ ?\ ?\ ?$</p><p>我们枚举到第四位时最多枚举到$4$，</p><p>$1\ 2\ 3\ 4\ 5\ 6$</p><p>$1\ 2\ 2\ ?\ ?\ ?$</p><p>这时我们枚举到第四位最多枚举到$9$</p><p>$limit$就是判断这个的</p><p>那么为什么要在$！limit$下才记忆化呢？</p><p>如果在所有情况下我们都记录f，那么假如之前枚举到$9$时你记录了一个答案，然后当前位有$limit$限制根本枚举不到$9$，你仍然用了这个f会出现错误</p><p>当然你这样记忆化也可以这样避免冲突</p><pre><code>ll dfs(ll x,ll limit,ll tmp,ll d)&#123;    if(f[x][limit][tmp][d])          return f[x][limit][tmp][d];       ………………        f[x][limit][tmp][d]=ans;    return ans;&#125;</code></pre><p>解释一下$lead$</p><p>处理前导0用的，</p><p>有的时候</p><p>$0\ 0\ 0\ 4\ 5\ 6$</p><p>也被认为是合法的，这时处理可能会出现问题，$lead$特判特殊处理</p><p>那么我们看几道模板题</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="windy数"><a href="#windy数" class="headerlink" title="windy数"></a>windy数</h3><p>Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为2的正整数被称为 Windy 数。</p><p>Windy 想知道，在l和r  之间，包括l  和 r ，总共有多少个 Windy 数？</p><p>非常简单对不对</p><p>套模板</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 50ll f[A][A],maxn[A];ll pos=0,a,b;ll dfs(ll x,ll pre,ll lead,ll limit)&#123;    if(x&gt;pos) return 1;    if(!limit&amp;&amp;f[x][pre]) return f[x][pre];    ll ans=0;    ll mx=limit?maxn[pos-x+1]:9;//    printf(&quot;mx=%lld\n&quot;,mx);    for(ll i=0;i&lt;=mx;i++)&#123;        if(abs(pre-i)&lt;2) continue;        if(lead&amp;&amp;i==0) ans+=dfs(x+1,-2,1,limit&amp;&amp;(i==mx));        else ans+=dfs(x+1,i,0,limit&amp;&amp;(i==mx));//        printf(&quot;ans=%lld\n&quot;,ans);    &#125;    if(!limit&amp;&amp;!lead) f[x][pre]=ans;    return ans;&#125;ll solve(ll x)&#123;    pos=0;    memset(f,0,sizeof(f));    while(x)&#123;        maxn[++pos]=x%10;        x/=10;    &#125;    ll ans=dfs(1,-2,1,1);    return ans;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);    swap(a,b);    printf(&quot;%lld\n&quot;,solve(a)-solve(b-1));&#125;</code></pre><h3 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a>不要62</h3><p>$l—r$间数位上不含$4$且没有$62$相连的数个数</p><p>套模板</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 50ll f[A][A],maxn[A];ll pos=0,a,b;ll dfs(ll x,ll pre,ll limit)&#123;    if(!x) return 1;    if(!limit&amp;&amp;f[x][pre]) return f[x][pre];//    printf(&quot;x=%lld pre=%lld  limit=%lld\n&quot;,x,pre,limit);    ll ans=0;    ll mx=limit?maxn[x]:9;    for(ll i=0;i&lt;=mx;i++)&#123;        if(pre==6&amp;&amp;i==2) continue;        if(i==4) continue;        ans+=dfs(x-1,i,limit&amp;&amp;(i==mx));    &#125;//    printf(&quot;ans=%lld\n&quot;,ans);    if(!limit) f[x][pre]=ans;    return ans;&#125;ll solve(ll x)&#123;    pos=0;    memset(f,0,sizeof(f));    while(x)&#123;        maxn[++pos]=x%10;        x/=10;    &#125;    ll ans=dfs(pos,0,1);    return ans;&#125;int main()&#123;    a=233,b=233;    while(a!=0&amp;&amp;b!=0)&#123;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        if(a&lt;b)swap(a,b);        if(a==0||b==0)&#123;            return 0;        &#125;        printf(&quot;%lld\n&quot;,solve(a)-solve(b-1));    &#125;&#125;</code></pre><h3 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h3><p>至少$3$个相邻的相同的数，$8$ $4$不能同时出现</p><p>套模板，注意下特判，不然会70到自闭</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 30ll f[A][A][A][2][2][2],pos[A];ll tot=0,a,b;ll dfs(ll x,ll prer,ll pre,ll limit,ll _4,ll _8,ll ok)&#123;    if(_4&amp;&amp;_8) return 0;    if(x&gt;tot&amp;&amp;!ok) return 0;    if(x&gt;tot&amp;&amp;ok) return 1;    if(!limit&amp;&amp;f[x][prer][pre][_4][_8][ok]) return f[x][prer][pre][_4][_8][ok];    ll maxn=limit?pos[tot-x+1]:9;    ll ans=0;    for(ll i=0;i&lt;=maxn;i++)&#123;        if(x==1&amp;&amp;i==0) continue;        if(_4&amp;&amp;i==8) continue;        if(_8&amp;&amp;i==4) continue;        if(pre==prer&amp;&amp;i==pre&amp;&amp;i==prer)            ans+=dfs(x+1,pre,i,(limit&amp;&amp;i==maxn),(_4||i==4),(_8||i==8),1);        else             ans+=dfs(x+1,pre,i,limit&amp;&amp;(i==maxn),(_4||i==4),(_8||i==8),ok);//        printf(&quot;ans=%lld i=%lld maxn=%lld\n&quot;,ans,i,maxn);    &#125;    if(!limit)        f[x][prer][pre][_4][_8][ok]=ans;    return ans;&#125;ll solve(ll x)&#123;    tot=0;    if(x&lt;1e10) return 0;    memset(f,0,sizeof(f));    while(x)&#123;        pos[++tot]=x%10;        x/=10;    &#125;    ll ans=dfs(1,0,0,1,0,0,0);    return ans;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);    if(a&lt;b) swap(a,b);    printf(&quot;%lld\n&quot;,solve(a)-solve(b-1));&#125;</code></pre><h3 id="花神的数论题"><a href="#花神的数论题" class="headerlink" title="花神的数论题"></a>花神的数论题</h3><p>设 sum(i) 表示 i 的二进制表示中 1 的个数。给出一个正整数 N ，花神要问你派(Sum(i)),也就是 sum(1)—sum(N) 的乘积。</p><p>套模板，等等，我要套什么，</p><p>这个题不算很板，值得思考思考。</p><p>数位dp计算出所有二进制下sum个数，然后快速幂处理一下，</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define A 53#define mod 10000007#define ll long longll n,tot=0,sum=0;ll f[A][2][A][A],ans[A],pos[A];ll dfs(ll cur,ll up,ll tmp,ll d)&#123;    if(!cur)        return tmp==d;    if(~f[cur][up][tmp][d])        return f[cur][up][tmp][d];    ll lim=up?pos[cur]:1;    ll ret=0;    for(ll i=0;i&lt;=lim;i++)        ret+=dfs(cur-1,up&amp;&amp;i==lim,tmp+(i==1),d);    return f[cur][up][tmp][d]=ret;&#125;ll meng(ll a,ll b)&#123;    ll ret=1;    while(b)        ret=ret*(b&amp;1?a:1)%mod,a=a*a%mod,b&gt;&gt;=1;    return ret;&#125;ll solve(ll x)&#123;    sum=1;    while(x)&#123;        pos[++tot]=x&amp;1;        x&gt;&gt;=1;    &#125;    for(ll i=1;i&lt;=tot;i++)&#123;        memset(f,-1,sizeof(f));        ans[i]=dfs(tot,1,0,i);    &#125;    for(ll i=1;i&lt;=tot;i++)&#123;        sum=(sum*max(meng(i,ans[i]),1ll))%mod;    &#125;    return sum;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    printf(&quot;%lld\n&quot;,solve(n));&#125;</code></pre><p>剩下一些题都不算很板</p><p><a href="https://www.luogu.org/problem/P3281">数数</a></p><p><a href="https://www.luogu.org/problem/P3303">淘金</a></p><p><a href="https://www.luogu.org/problem/P3286">方伯伯商场之旅</a></p><p>题解慢慢补充八</p><p>那么你现在会模板了吗？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数对</title>
      <link href="/2025/03/14/%E6%95%B0%E5%AF%B9/"/>
      <url>/2025/03/14/%E6%95%B0%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-29 15:15</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>算是历史遗留问题的解决</p><p>之前队长快跑看题解很迷糊,觉得似懂非懂的,AC但是很水,最后代码都不是我的,是$王_{drink_{grass}}$的</p><p>现在总算会了</p><p>首先题目中条件就是$max(a)&lt;&#x3D;b_i$</p><p>暴力dp就是$f[i][j]$表示考虑了前$i$个位置最大值为$j$时权值最大是多少</p><p>于是分情况讨论</p><p>1.$a_i&gt;b_i$</p><p>因为要满足$max(a)&lt;&#x3D;b_i$所以$f[i][a[i]]&#x3D;max(f[i-1][1],f[i-1][2],,,,,f[i-1][b[i]])+val$这些位置最大值都会改变为$a[i]$</p><p>2.$a_i&lt;b_i$</p><p>因为要满足$max(a)&lt;&#x3D;b_i$显然在$a_i–b_i$之间$f[i-1][a[i]]–f[i-1][b[i]]$之间最大值不会变直接+val即可</p><p>在$1–<br>a_{i-1}$,最大值变为$a[i]$,于是就有了$f[i][a[i]]&#x3D;max(f[i-1][1],f[i-1][2],,,,,f[i-1][a[i-1]])+val$</p><p>可以用线段树维护</p><blockquote><p>$f[i][a[i]]&#x3D;max(f[i-1][1],f[i-1][2],,,,,f[i-1][b[i]])+val$</p></blockquote><blockquote><p>$f[i][a[i]]&#x3D;max(f[i-1][1],f[i-1][2],,,,,f[i-1][a[i-1]])+val$</p></blockquote><p>就是区间最大值,单点赋值</p><blockquote><p>$f[i-1][a[i]]+val–f[i-1][b[i]]+val$</p></blockquote><p>就是区间+</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 12000000ll lsh[A];ll n,maxn,len=0,cnt=0,q;struct node&#123;    ll a,b,w;    friend bool operator &lt; (const node &amp;c,const node &amp;d)&#123;        return ((c.a+c.b)==(d.a+d.b))?(c.b&lt;d.b):((c.a+c.b)&lt;(d.a+d.b));    &#125;&#125;s[A];struct tree&#123;    ll l,r,f,val;&#125;tr[A];void up(ll x)&#123;    tr[x].val=max(tr[x&lt;&lt;1].val,tr[x&lt;&lt;1|1].val);&#125;void down(ll x)&#123;    tr[x&lt;&lt;1].f+=tr[x].f;    tr[x&lt;&lt;1|1].f+=tr[x].f;    tr[x&lt;&lt;1].val+=tr[x].f;    tr[x&lt;&lt;1|1].val+=tr[x].f;    tr[x].f=0;&#125;void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(tr[x].l==tr[x].r)&#123;        tr[x].val=0;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);    up(x);&#125;void seg_max(ll x,ll l,ll r)&#123;    if(l&gt;r) return;    if(tr[x].f) down(x);    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        maxn=max(maxn,tr[x].val);//        maxn=tr[x].val;        return ;    &#125;        ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_max(x&lt;&lt;1,l,r);    if(mid&lt;r) seg_max(x&lt;&lt;1|1,l,r);&#125;void change(ll x,ll ooo,ll val)&#123;    if(tr[x].l==tr[x].r) &#123;        tr[x].val=max(tr[x].val,val);        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(ooo&lt;=mid) change(x&lt;&lt;1,ooo,val);    else change(x&lt;&lt;1|1,ooo,val);    up(x);&#125;void seg_change(ll x,ll l,ll r,ll val)&#123;    if(l&gt;r) return;    if(tr[x].f) down(x);    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        tr[x].val+=val;        tr[x].f+=val;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_change(x&lt;&lt;1,l,r,val);    if(mid&lt;r) seg_change(x&lt;&lt;1|1,l,r,val);    up(x);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld%lld%lld&quot;,&amp;s[i].a,&amp;s[i].b,&amp;s[i].w),lsh[++cnt]=s[i].a,lsh[++cnt]=s[i].b;    sort(lsh+1,lsh+cnt+1);    len=unique(lsh+1,lsh+cnt+1)-lsh-1;    for(ll i=1;i&lt;=n;i++)&#123;        s[i].a=lower_bound(lsh+1,lsh+len+1,s[i].a)-lsh;        s[i].b=lower_bound(lsh+1,lsh+len+1,s[i].b)-lsh;    &#125;    sort(s+1,s+n+1);    built(1,1,len);    for(ll i=1;i&lt;=n;i++)&#123;        if(s[i].a&gt;s[i].b)&#123;            maxn=0;            seg_max(1,1,s[i].b);            change(1,s[i].a,s[i].w+maxn);        &#125;        else &#123;            seg_change(1,s[i].a,s[i].b,s[i].w);            maxn=0;            seg_max(1,1,s[i].a-1);            change(1,s[i].a,s[i].w+maxn);        &#125;    &#125;    maxn=0;    seg_max(1,1,len);    printf(&quot;%lld\n&quot;,maxn);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树上染色</title>
      <link href="/2025/03/14/%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/"/>
      <url>/2025/03/14/%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-17 17:00</p><h1 id="树上染色"><a href="#树上染色" class="headerlink" title="树上染色"></a>树上染色</h1><p>内存限制：256 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一棵点数为 NNN 的树，树边有边权。给你一个在 0∼N0 \sim N0∼N 之内的正整数 KKK，你要在这棵树中选择 KKK<br>个点，将其染成黑色，并将其他的 N−KN-KN−K 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。</p><p>问收益最大值是多少。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 N,KN,KN,K。<br>接下来 N−1N-1N−1 行每行三个正整数 fr,to,dis\text{fr}, \text{to} ,<br>\text{dis}fr,to,dis，表示该树中存在一条长度为 dis\text{dis}dis 的边<br>(fr,to)(\text{fr},\text{to})(fr,to)。<br>输入保证所有点之间是联通的。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，表示收益的最大值。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>5 21 2 31 5 12 3 12 4 2</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>17</code></pre><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>将点 1,21,21,2 染黑就能获得最大收益。</p><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>N≤2000, 0≤K≤NN \leq 2000, \ 0 \leq K \leq NN≤2000, 0≤K≤N</p><p>第一次遇到这种题，我看了题解才过，觉得自己思维还有待提升</p><p>首先考虑f很好列但贡献特别难求难点就在于求贡献</p><p>设$f[x][j]$表示为以x为根时 给j个点染成黑色时最大值</p><p>我们轻易得到</p><p>$f[x][j]&#x3D;max(f[x][j],f[x][j-w]+f[y][w]+val)$</p><p>注意这里f含义略微改变，我们把它当成背包一样转移</p><p>这是类似于一个子树合并的过程，假设当前枚举的是箭头指向的边</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190717164920862-52636149.png"></p><p>j-w是左边那一大堆，我们现在通过y这条边将子树合并过来使得最终状态为j</p><p>所以得到$f[x][j]&#x3D;max(f[x][j],f[x][j-w]+f[y][w]+val)$</p><p>然后我们开始计算val</p><p>直接计算肯定不行，预处理也预处理不出来</p><p>然后我的思路就到这了，距离不是很好求</p><p>经过仔细思考（颓题解）</p><p>发现其实我们要计算的val就是这条边的贡献</p><p>事实上这条边之外的点对是转移不过来的（图中圈中的相同颜色点对不用经过这条边）</p><p>那么我们就可以求出来这个边以下的黑点和y的兄弟为黑点构成的点对的贡献，</p><p>假设给y这个节点子树p个黑点，x兄弟共q-p个黑点</p><p>黑点之间贡献其实就是val*（p*（size[y]-p））</p><p>类似的，我们用容斥求出白点之间贡献最后得到</p><p>$(p*(k-p)+(size[y]-p)*(n-k-(size[y]-p)))*z$</p><p>转移就完了</p><p>你以为这是$n^3$的吗？</p><p>其实这有专门复杂度分析，具体可以查阅相关资料，大概是因为枚举点对之间贡献所以$n^2$</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 6000ll f[A][A],tot=0,deep[A],size[A],head[A],nxt[A],ver[A],edg[A],n,k;bool flag[A];void add(ll x,ll y,ll z)&#123;    edg[++tot]=z,nxt[tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void dfs(ll x,ll pre)&#123;    memset(f[x],-1,sizeof(f[x]));    f[x][1]=f[x][0]=0;size[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue;        dfs(y,x);        size[x]+=size[y];    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i],z=edg[i];        if(y==pre) continue;        for(ll q=min(k,size[x]);q&gt;=0;q--)            for(ll p=0;p&lt;=min(q,size[y]);p++)            if(q-p&gt;=0&amp;&amp;f[x][q-p]!=-1)            &#123;                ll val=(p*(k-p)+(size[y]-p)*(n-k-(size[y]-p)))*z;//                printf(&quot;val=%lld x=%lld y=%lld q=%lld p=%lld\n&quot;,val,x,y,q,p);                f[x][q]=max(f[x][q],f[x][q-p]+f[y][p]+val);            &#125;    &#125;&#125;int main()&#123;//    freopen(&quot;mkd.txt&quot;,&quot;r&quot;,stdin);//    freopen(&quot;wa.txt&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);    for(ll i=1;i&lt;=n-1;i++)&#123;        ll xx,yy,zz;        scanf(&quot;%lld%lld%lld&quot;,&amp;xx,&amp;yy,&amp;zz);        add(xx,yy,zz);add(yy,xx,zz);    &#125;    dfs(1,0);/*    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=k;j++)&#123;            printf(&quot;f=%lld &quot;,f[i][j]);        &#125;*/    cout&lt;&lt;f[1][k]&lt;&lt;endl;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树上启发式合并</title>
      <link href="/2025/03/14/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2025/03/14/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-30 21:44</p><p>树上启发式合并，一种美妙的黑科技，可以用普通的优化让你$n^2$变成严格$n log$,解决一些类似(树上数颜色,树上查众数)这样的问题</p><p>首先你要知道暴力为什么是$n^2$的</p><p>以这个图为例</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190730212828617-432610919.png"></p><p>每次你从一个节点开始向下搜,你从1节点搜到3,搜完这个子树然后你需要把3存的col等信息删去再遍历另一个子树才是正确的</p><p>那么我们每次遍历这个节点一个子树,每次搜完这棵子树都要清空当前子树储存信息这样(最差)复杂度$n^2$</p><p>我们可以发现清空最后一个遍历的子树是没有意义的,那么我们人为把最后一个子树放到最后不就是最优的吗</p><p>所以,首先我们先找出来重链,轻链,对于轻链我们求出子树答案,再清除子树贡献,.然后求出重链上子树答案,不清除贡献.最后我们再算一遍子树对当前节点贡献即可</p><p>你可能会认为,这不就是一个简单的优化吗,怎么就是$n log$了</p><p>我不知道</p><p>它并没有优化最优复杂度而是避免了最差复杂度</p><p>以给一棵根为1的树，每次询问子树颜色种类数为例</p><p>代码大致如下</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define r register #define A 1001010ll head[A],nxt[A],ver[A],size[A],col[A],cnt[A],ans[A],son[A];ll tot=0,num,sum,nowson,n,m,xx,yy;inline void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;inline ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();    return f*x;&#125;void dfs(ll x,ll fa)&#123;    size[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        dfs(y,x);        size[x]+=size[y];        if(size[son[x]]&lt;size[y])            son[x]=y;    &#125;&#125;void cal(ll x,ll fa,ll val)&#123;    if(!cnt[col[x]]) ++sum;    cnt[col[x]]+=val;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa||y==nowson) continue;        cal(y,x,val);     &#125;&#125;void dsu(ll x,ll fa,bool op)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa||y==son[x])            continue;        dsu(y,x,0);        //从轻儿子出发    &#125;    if(son[x])        dsu(son[x],x,1),nowson=son[x];    cal(x,fa,1);nowson=0;    ans[x]=sum;    if(!op)&#123;        cal(x,fa,-1);        sum=0;    &#125;&#125;int main()&#123;    n=read();    for(ll i=1;i&lt;=n-1;i++)&#123;        xx=read(),yy=read();        add(xx,yy),add(yy,xx);    &#125;    for(ll i=1;i&lt;=n;i++)        col[i]=read();    dfs(1,0);    dsu(1,0,1);    m=read();    for(ll i=1;i&lt;=m;i++)&#123;        xx=read();        printf(&quot;%d\n&quot;,ans[xx]);    &#125;&#125;</code></pre><p>另一种打法</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;#define R register#define ll long longinline ll read()&#123;    ll aa=0;R int bb=1;char cc=getchar();    while(cc&lt;&#39;0&#39;||cc&gt;&#39;9&#39;)        &#123;if(cc==&#39;-&#39;)bb=-1;cc=getchar();&#125;    while(cc&gt;=&#39;0&#39;&amp;&amp;cc&lt;=&#39;9&#39;)        &#123;aa=(aa&lt;&lt;1)+(aa&lt;&lt;3)+(cc^48);cc=getchar();&#125;    return aa*bb;&#125;const int N=1e5+3;struct edge&#123;    int v,last;&#125;ed[N&lt;&lt;1];int first[N],tot;inline void add(int x,int y)&#123;    ed[++tot].v=y;    ed[tot].last=first[x];    first[x]=tot;&#125;int n,m,c[N],son[N],cnt[N],ans[N],siz[N];void dfsi(int x,int fa)&#123;    siz[x]=1;    for(R int i=first[x],v;i;i=ed[i].last)&#123;        v=ed[i].v;        if(v==fa)continue;        dfsi(v,x);        siz[x]+=siz[v];        if(siz[v]&gt;siz[son[x]])son[x]=v;    &#125;    return;&#125;int dfsj(int x,int fa,int bs,int kep)&#123;    if(kep)&#123;        for(R int i=first[x],v;i;i=ed[i].last)&#123;            v=ed[i].v;            if(v!=fa&amp;&amp;v!=son[x])                dfsj(v,x,0,1);        &#125;    &#125;    int res=0;    if(son[x])res+=dfsj(son[x],x,1,kep);    for(R int i=first[x],v;i;i=ed[i].last)&#123;        v=ed[i].v;        if(v!=fa&amp;&amp;v!=son[x])            res+=dfsj(v,x,0,0);    &#125;    if(!cnt[c[x]])res++;    cnt[c[x]]++;    if(kep)&#123;        ans[x]=res;        if(!bs)memset(cnt,0,sizeof(cnt));    &#125;    return res;&#125;int main()&#123;    n=read();    for(R int i=1,x,y;i&lt;n;++i)&#123;        x=read();y=read();        add(x,y);add(y,x);    &#125;    for(R int i=1;i&lt;=n;++i)c[i]=read();    dfsi(1,0); dfsj(1,0,1,1);    m=read();    for(R int i=1,x;i&lt;=m;++i)&#123;        x=read();        printf(&quot;%d\n&quot;,ans[x]);    &#125;    return 0;&#125;</code></pre><p>虽然好像没什么区别</p><p>然后再看一道例题</p><p>有一棵 n 个节点的以 1 号节点为根的树，每个节点上有一个小桶，节点u上的小桶可以容纳${k_u}$<br>个小球，ljh每次可以给一个节点到根路径上的所有节点的小桶内放一个小球，如果这个节点的小桶满了则不能放进这个节点，最后多次询问某个节点值</p><p>首先暴力不能过</p><p>直接权值线段树+线段树合并很难维护，树链剖分也难以维护，但我们直接树上启发式合并+线段树暴力修改可以维护。</p><p>首先单纯线段树暴力修改可以维护，但这会超时。于是我们用启发式合并作为时间复杂度保证，莫名奇妙AC了这个题</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1001010ll head[A],nxt[A],ver[A],size[A],son[A],tong[A],col[A],getfa[A],isbigson[A],ans[A],al[A];vector&lt;pair&lt;ll,ll&gt; &gt;v[A];map&lt;ll,ll&gt;mp;ll n,m,tot=0,Q,wwb=0;struct tree&#123;    ll l,r,f,x,t,c;&#125;tr[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void prdfs(ll x,ll fa)&#123;    size[x]=v[x].size()+1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        prdfs(y,x);        size[x]+=size[y];        if(size[son[x]]&lt;size[y])            isbigson[son[x]]=0,son[x]=y,isbigson[y]=1;    &#125;&#125;void built(ll p,ll l,ll r)&#123;    tr[p].l=l,tr[p].r=r;    if(tr[p].l==tr[p].r)&#123;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(p&lt;&lt;1,l,mid);    built(p&lt;&lt;1|1,mid+1,r);&#125;ll ask(ll p,ll pos)&#123;    if(pos&gt;=tr[p].t) return tr[p].c;    return (pos&gt;=tr[p&lt;&lt;1].t?tr[p&lt;&lt;1].c+ask(p&lt;&lt;1|1,pos-tr[p&lt;&lt;1].t):ask(p&lt;&lt;1,pos));&#125;void insert(ll p,ll pos,ll t,ll c)&#123;    if(tr[p].l==tr[p].r)        &#123;tr[p].t+=t;tr[p].c+=c;return;&#125;    if(pos&lt;=tr[p&lt;&lt;1].r)        insert(p&lt;&lt;1,pos,t,c);    else         insert(p&lt;&lt;1|1,pos,t,c);    tr[p].t=tr[p&lt;&lt;1].t+tr[p&lt;&lt;1|1].t;    tr[p].c=tr[p&lt;&lt;1].c+tr[p&lt;&lt;1|1].c;&#125;void up(ll x,ll fa)&#123;    if(v[getfa[x]].size()&lt;v[getfa[fa]].size())&#123;        for(ll i=0;i&lt;v[getfa[x]].size();i++)            v[getfa[fa]].push_back(v[getfa[x]][i]);        v[getfa[x]].clear();        getfa[x]=getfa[fa];    &#125;    else&#123;        for(ll i=0;i&lt;v[getfa[fa]].size();i++)            v[getfa[x]].push_back(v[getfa[fa]][i]);        v[getfa[fa]].clear();        getfa[fa]=getfa[x];    &#125;&#125;void dfs(ll x,ll fa)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa||y==son[x])    continue;        dfs(y,x);    &#125;    if(son[x]) dfs(son[x],x);    for(ll i=0;i&lt;v[getfa[x]].size();i++)&#123;        ll tim=v[getfa[x]][i].first,col=v[getfa[x]][i].second;        if(!al[col])    al[col]=tim,insert(1,tim,1,1);        else if(al[col]&gt;tim)&#123;            insert(1,al[col],0,-1);            insert(1,tim,1,1);            al[col]=tim;        &#125;        else insert(1,tim,1,0);    &#125;//    printf(&quot;t=%lld tong=%lld\n&quot;,tr[1].t,tong[x]);    ans[x]=ask(1,min(tr[1].t,tong[x]));    if(son[x])        up(son[x],x);    if(!isbigson[x])&#123;        for(ll i=0;i&lt;v[getfa[x]].size();i++)&#123;            ll tim=v[getfa[x]][i].first,col=v[getfa[x]][i].second;            if(al[col]==tim)                insert(1,tim,-1,-1),al[col]=0;            else                 insert(1,tim,-1,0);        &#125;        up(x,fa);    &#125;    /*    for(ll i=1;i&lt;=5;i++)&#123;        printf(&quot;ans=%lld &quot;,ans[i]);    &#125;*//*    cout&lt;&lt;endl;*/&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;n;i++)&#123;        ll xx,yy;        scanf(&quot;%lld%lld&quot;,&amp;xx,&amp;yy);        add(xx,yy),add(yy,xx);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;tong[i]);        getfa[i]=i;    &#125;    prdfs(1,0);    scanf(&quot;%lld&quot;,&amp;m);built(1,1,m);    for(ll i=1,x,c;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;c);        if(!mp[c])            mp[c]=++wwb;        //离散化        v[x].push_back(make_pair(i,mp[c]));    &#125;    dfs(1,0);    scanf(&quot;%lld&quot;,&amp;Q);    for(ll i=1,x;i&lt;=Q;i++)&#123;        scanf(&quot;%lld&quot;,&amp;x);        printf(&quot;%lld\n&quot;,ans[x]);    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树的计数（prufer序列 或 purfer序列）</title>
      <link href="/2025/03/14/%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0%EF%BC%88prufer%E5%BA%8F%E5%88%97%20%E6%88%96%20purfer%E5%BA%8F%E5%88%97%EF%BC%89/"/>
      <url>/2025/03/14/%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0%EF%BC%88prufer%E5%BA%8F%E5%88%97%20%E6%88%96%20purfer%E5%BA%8F%E5%88%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-21 19:04</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先我们要知道一条性质，prufer序列中的某个点出现次数为该点在树中度数-1</p><p>感性理解一下，其实按照prufer序列求法自己推一下就出来了</p><p>设题目里给的度为$d[]$</p><p>先将所有的d–</p><p>然后按照排列组合得出来</p><p>这是多重集排列数</p><p>首先从n-2中选择d[1]个数是$C_{n}^{d[1]}$然后再从剩余n-d[1]中选d[2] $C_{n-d[1]}^{d[2]}$依次类推</p><p>$C_{n-2}^{d[1]}\times C_{n-2-d[1]}^{d[2]}\times C_{n-2-d[1]-d[2]}^{d[3]}\times<br>……\times C_{n-2-d[1]-……-d[n-1]}^{d[n]}$</p><p>得到</p><p>$\frac{(n-2)!}{\sum\limits_{i&#x3D;1}^{n}d[i]!}$</p><p>高精转移就完了</p><p>还是过不了？</p><h4 id="一些特判："><a href="#一些特判：" class="headerlink" title="一些特判："></a>一些特判：</h4><p>首先该题会有无解的情况</p><p>然后当只有一个点时方案数为1</p><p>然后当出现度数为0的点时方案数要特殊处理</p><p>以下是本人丑陋的代码</p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define N 10#define P 1using namespace std;ll n,m,d[20000],cnt=0;bool flag[20000];struct bignum&#123;    ll n[200000],l;    bignum()&#123;l=1,memset(n,0,sizeof(n));&#125;    void clear()&#123;while(l&gt;1&amp;&amp;!n[l-1]) l--;&#125;    void print()    &#123;        printf(&quot;%lld&quot;,n[l-1]);        for(ll i=l-2;i&gt;=0;i--)        printf(&quot;%0*lld&quot;,P,n[i]);        printf(&quot;\n&quot;);    &#125;    bignum operator = (ll x)    &#123;        l=0;            while(x)        &#123;            n[l++]=x%N;            x/=N;        &#125;        return *this;    &#125;    bignum operator +(bignum x) const    &#123;        bignum t=*this;        if(x.l&gt;t.l) t.l=x.l;                for(ll i=0;i&lt;t.l;i++)        &#123;            t.n[i]+=x.n[i];            if(t.n[i]&gt;=N)            &#123;                t.n[i+1]+=t.n[i]/N;                t.n[i]%=N;            &#125;        &#125;        return t;    &#125;       bignum operator * (const ll&amp; b)      &#123;        bignum c;           c.l=0;        for(ll i=0,g=0;g||i&lt;l;i++)        &#123;            ll x;            if(i&lt;l)x=n[i]*b+g;            else x=g;            c.n[c.l++]=x%N;            g=x/N;        &#125;        return c;    &#125;    bignum operator *(bignum x) const    &#123;        bignum t=*this,tep;        tep.l=t.l+x.l+1;        for(ll i=0;i&lt;t.l;i++)            for(ll j=0;j&lt;=x.l;j++)            &#123;                tep.n[i+j]+=t.n[i]*x.n[j];            &#125;        for(ll i=0;i&lt;tep.l;i++)        &#123;            tep.n[i+1]+=tep.n[i]/N;            tep.n[i]%=N;        &#125;        tep.clear();        return tep;    &#125;    bool operator &lt;(bignum x) const    &#123;        bignum t=*this,tep;        if(t.l!=x.l)    return t.l&lt;x.l;        for(ll i=t.l-1;i&gt;=0;i--)        &#123;            if(t.n[i]!=x.n[i]) return t.n[i]&lt;x.n[i];        &#125;        return 0;    &#125;    bool operator &gt;(bignum x) const    &#123;        bignum t=*this;        if(t.l!=x.l) return t.l&gt;x.l;        for(ll i=t.l-1;i&gt;=0;i--)        &#123;            if(t.n[i]!=x.n[i]) return t.n[i]&gt;x.n[i];        &#125;        return 0;    &#125;    bignum operator -(bignum x) const    &#123;        bignum t=*this;        if(t&lt;x) printf(&quot;-&quot;),swap(t,x);        ll jie=0;        for(ll i=0;i&lt;t.l;i++)        &#123;            t.n[i]-=x.n[i];            while(t.n[i]&lt;0)            &#123;                t.n[i]+=N;                jie++;            &#125;            t.n[i+1]-=jie;            jie=0;;        &#125;        t.clear();        return t;    &#125;    bignum operator /(const ll &amp;x)    &#123;        bignum t=*this,r;        ll tmp=0;        r.l=t.l;        for(ll i=t.l-1;i&gt;=0;i--)&#123;            tmp+=t.n[i];            if(tmp&gt;=x)&#123;                r.n[i]=tmp/x;                tmp%=x;            &#125;            tmp*=N;        &#125;        r.clear();        return r;    &#125;&#125;ans;bignum jie(ll x)&#123;    bignum t;t=1;    for(ll i=2;i&lt;=x;i++)&#123;        t=x*i;    &#125;    return t;&#125;int main()&#123;    memset(flag,0,sizeof(flag));    ll sum=0,you0=0;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%lld&quot;,&amp;d[i]);        if(d[i])flag[i]=1,cnt++;        else you0=1;        d[i]--,sum+=d[i];            &#125;    if(you0&amp;&amp;n==1)&#123;        cout&lt;&lt;1&lt;&lt;endl;        return 0;    &#125;    if(sum!=n-2||you0)     &#123;        cout&lt;&lt;0&lt;&lt;endl;        return 0;    &#125;    ans=1;    for(ll i=2;i&lt;=cnt-2;i++)        ans=ans*i;    for(ll i=1;i&lt;=n;i++)&#123;        if(flag[i])        for(ll j=2;j&lt;=d[i];j++)                ans=ans/j;    &#125;    ans.print();&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>神盐皇</title>
      <link href="/2025/03/14/%E7%A5%9E%E7%9B%90%E7%9A%87/"/>
      <url>/2025/03/14/%E7%A5%9E%E7%9B%90%E7%9A%87/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-10 14:59</p><p>终于会了</p><p>先放一个<a href="https://www.cnblogs.com/butterflydew/p/9889530.html">极好的博客</a></p><p>求满足$a+b|a*b,&amp;a&lt;&#x3D;n,b&lt;&#x3D;n$数对数量,$n&lt;&#x3D;10^{15}$</p><p>设$d&#x3D;gcd(a,b)$</p><p>那么$a_1&#x3D;\frac{a}{d},,b_1&#x3D;\frac{b}{d}$</p><p>原要求变为$(a_1+b_1)<em>d|a_1</em>b_1<em>d</em>d$即$(a_1+b_1)|a_1<em>b_1</em>d$</p><p>考虑辗转相减法转化$gcd(a_1,b_1)&#x3D;&#x3D;1$-&gt;$gcd(a_1+b_1,b_1)&#x3D;&#x3D;1$-&gt;$gcd(a_1+b_1,a_1)&#x3D;&#x3D;1$</p><p>$a_1+b_1$与$b_1$无公因数,与$a_1$无公因数$gcd(a_1+b_1,a_1*b_1)&#x3D;&#x3D;1$</p><p>原式变为求$(a_1+b_1)|d$个数</p><p>$i&#x3D;a_1+b_1$设$d&#x3D;k*i$</p><p>$d<em>i&lt;&#x3D;n$故$k$共$\large \lfloor \frac {n}{i</em>i} \rfloor$个</p><p>考虑$i$的取值情况,</p><p>现在要求$gcd(x-i,i)&#x3D;&#x3D;1$数个数</p><p>仍然考虑辗转相减$gcd(x,i)&#x3D;&#x3D;1$个数,确定,$x&lt;&#x3D;i$,那么就是$\varphi(i)$</p><p>$\sum\limits_{i&#x3D;1}^{\sqrt n}\varphi(i)\lfloor\frac{n}{i^2}\rfloor$</p><p>然后关于$\varphi(i)$求法</p><p>我又忘了$\varphi(i)$线筛怎么求了,重新理解了一遍</p><p>首先计算式$\varphi(N)&#x3D;N\prod_{i}^{i|N且i为质数}(1-\frac{1}{i})$</p><p>$\varphi$是积性函数</p><p><em><strong>互质</strong></em> 的$a,b$满足$\varphi(a<em>b)&#x3D;\varphi(a)</em>\varphi(b)$</p><p>首先$p$为质数若$p|N$且$p^2\nmid N$ 那么说明互质$\varphi(N)&#x3D;\varphi(\frac{N}{p})\varphi(p)$</p><p>$\varphi(p)&#x3D;p-1$</p><p>那么$\varphi(N)&#x3D;\varphi(\frac{N}{p})*(p-1)$($p$为质数若$p|N$且$p^2\nmid N$)</p><p>那么若$p|N$且$p^2|N$ 那么说明 <em><strong>有相同质因子不互质</strong></em></p><p>说明$N$与$\frac{N}{p}$拥有的质因子完全相同,根据计算式$\varphi(N)&#x3D;N\prod_{i}^{i|N且i为质数}(1-\frac{1}{i})$后面部分完全一样差的只是前面的$N$</p><p>于是$\varphi(N)&#x3D;\varphi(\frac{N}{p})*p$($p|N$且$p^2|N$)</p><p>总结</p><p>打表不会出奇迹</p><p>关于gcd相关应用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蛇</title>
      <link href="/2025/03/14/%E8%9B%87/"/>
      <url>/2025/03/14/%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-13 07:24</p><p>构造题,</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n条蛇,第i条长度为i,编号为奇数必须有奇数个转折点,编号为偶数必须有偶数个转折点,密铺一个矩形</p><p>输出矩形长宽,并依次输出每条蛇坐标</p><p>$n&lt;&#x3D;500$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>找规律,</p><p>首先根据等差数列,当$n$为奇数矩形长为$\frac{n+1}{2}$宽为$n$当$n$为偶数,矩形长为$\frac{n}{2}$宽为$n$</p><p>当$n$为偶数$n$这条蛇直接在前面基础上往右摞就完了</p><p>x x x x x n n</p><p>x x x x x n n</p><p>x x x x x n n</p><p>当$n$为奇数要找规律,往下摞最后规律是这样的</p><p>x x x x x n-2 n</p><p>x x x x x n-2 n</p><p>n-1 n-1 n-1 n-2 n-2 n-2 n</p><p>n-1 n-1 n-1 n n n n</p><p>蛇</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longvoid f(ll n)&#123;    ll nowx,nowy,lie,hang,num;    if(n&amp;1) nowx=(n+1)/2,nowy=n;    else nowx=n/2,nowy=n+1;    if(n==2)&#123;        printf(&quot;1 1\n&quot;);        printf(&quot;1 2 1 3\n&quot;);        return ;    &#125;    if(n==3)&#123;        printf(&quot;2 1\n&quot;);        printf(&quot;1 1 1 2\n&quot;);        printf(&quot;1 3 2 3 2 2\n&quot;);        return ;    &#125;    if(n&amp;1)&#123;        f(n-3);        hang=(n-3)/2;        lie=n-2;        num=(n-1)/2;        //n-2        for(ll i=1;i&lt;=num;i++)            printf(&quot;%lld %lld &quot;,i,lie+1);        for(ll i=0;i&lt;num-1;i++)            printf(&quot;%lld %lld &quot;,hang+1,lie-i);        puts(&quot;&quot;);        //n-1        for(ll i=1;i&lt;=num;i++)            printf(&quot;%lld %lld &quot;,hang+1,i);        for(ll i=num;i&gt;=1;i--)            printf(&quot;%lld %lld &quot;,hang+2,i);        puts(&quot;&quot;);        //n        for(ll i=1;i&lt;=num+1;i++)            printf(&quot;%lld %lld &quot;,i,lie+2);        for(ll i=0;i&lt;num;i++)            printf(&quot;%lld %lld &quot;,hang+2,lie-i+1);        puts(&quot;&quot;);    &#125;    else &#123;        f(n-1);        hang=(n+1)/2,lie=n-1;        //n        for(ll i=1;i&lt;=hang;i++)            printf(&quot;%lld %lld &quot;,i,lie+1);        for(ll i=hang;i&gt;=1;i--)            printf(&quot;%lld %lld &quot;,i,lie+2);        puts(&quot;&quot;);    &#125;&#125;ll d;int main()&#123;    ll x,y;    while(cin&gt;&gt;d)&#123;        if(d&amp;1)&#123;            x=(d+1)/2,y=d;        &#125;        else x=d/2,y=d+1;        printf(&quot;%lld %lld\n&quot;,x,y);        f(d);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>山屋惊魂</title>
      <link href="/2025/03/14/%E5%B1%B1%E5%B1%8B%E6%83%8A%E9%AD%82/"/>
      <url>/2025/03/14/%E5%B1%B1%E5%B1%8B%E6%83%8A%E9%AD%82/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-26 15:35</p><p>我太傻逼了打了13.5K</p><p>思路很简单,代码很难</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct moo&#123;    ll opt1;//第一个    ll xiaoyu,xiaoyudengyu,dayu,dayudengyu;    ll opt2;//第二个    ll val1;//第一个数    ll val2;//第二个数    ll wenhao;//有无问号&#125;node[110];ll n;ll mit[10],spd[10],san[10],kno[10];double f[110][10][10][10][10],ans1[110],ans2[110],ans3[110],ans4[110],dice[30][75];ll needpan(ll x)&#123;    if((!node[x].xiaoyu)&amp;&amp;(!node[x].dayu)&amp;&amp;(!node[x].xiaoyudengyu)&amp;&amp;(!node[x].dayudengyu))        return 0;    return 1;&#125;char ch1[110],ch2[110],ch3[110],ch4[110];ll work(char c)&#123;    if(c==&#39;i&#39;) return 1;    if(c==&#39;p&#39;) return 2;    if(c==&#39;a&#39;) return 3;    if(c==&#39;n&#39;) return 4;&#125;void cal(ll i,ll j1,ll j2,ll j3,ll j4,ll opt,ll val,double gailv)&#123;//    printf(&quot;**************opt=%lld\n&quot;,opt);    if(opt==1)&#123;        if(j1+val&lt;=0) return ;        ll jj=j1+val;        if(jj&gt;8) jj=8;        f[i+1][jj][j2][j3][j4]+=gailv*f[i][j1][j2][j3][j4];    &#125;    else if(opt==2)&#123;        if(j2+val&lt;=0) return ;        ll jj=j2+val;        if(jj&gt;8) jj=8;        f[i+1][j1][jj][j3][j4]+=gailv*f[i][j1][j2][j3][j4];    &#125;    else if(opt==3)&#123;        if(j3+val&lt;=0)&#123;//            printf(&quot;****\n&quot;);            return ;        &#125;        ll jj=j3+val;        if(jj&gt;8) jj=8;        f[i+1][j1][j2][jj][j4]+=gailv*f[i][j1][j2][j3][j4];            &#125;    else&#123;        if(j4+val&lt;=0)&#123;//            printf(&quot;******\n&quot;);            return ;        &#125;        ll jj=j4+val;        if(jj&gt;8) jj=8;        f[i+1][j1][j2][j3][jj]+=gailv*f[i][j1][j2][j3][j4];//        printf(&quot;f[%lld][%lld][%lld][%lld][%lld]=%lf\n&quot;,i+1,j1,j2,j3,jj,f[i+1][j1][j2][j3][jj]);    &#125;    &#125;int main()&#123;    ll ita,itb,itc,itd,a;    scanf(&quot;%lld&quot;,&amp;a);    while(a)&#123;        mit[++mit[0]]=a%10;        a/=10;    &#125;    scanf(&quot;%lld&quot;,&amp;ita);    scanf(&quot;%lld&quot;,&amp;a);    while(a)&#123;        spd[++spd[0]]=a%10;        a/=10;    &#125;    scanf(&quot;%lld&quot;,&amp;itb);    scanf(&quot;%lld&quot;,&amp;a);    while(a)&#123;        san[++san[0]]=a%10;        a/=10;    &#125;    scanf(&quot;%lld&quot;,&amp;itc);    scanf(&quot;%lld&quot;,&amp;a);    while(a)&#123;        kno[++kno[0]]=a%10;        a/=10;    &#125;    scanf(&quot;%lld&quot;,&amp;itd);    scanf(&quot;%lld&quot;,&amp;a);    for(ll i=1;i&lt;=a;i++)&#123;        scanf(&quot;%s&quot;,ch1+1);        node[i].opt1=work(ch1[2]);        scanf(&quot;%s&quot;,ch2+1);        if(ch2[1]==&#39;+&#39;||ch2[1]==&#39;-&#39;)&#123;            ll x=0;            ll it=2,f=1;            if(ch2[1]==&#39;-&#39;) f=-1;            while(isdigit(ch2[it]))&#123;                x=x*10+ch2[it]-&#39;0&#39;;                it++;            &#125;            if(ch2[it]==&#39;?&#39;)&#123;                node[i].wenhao=1;            &#125;            node[i].val1=x*f;        &#125;        else &#123;            if(ch2[1]==&#39;&lt;&#39;&amp;&amp;ch2[2]==&#39;=&#39;)&#123;                node[i].xiaoyudengyu=1;            &#125;            else if(ch2[1]==&#39;&lt;&#39;)&#123;                node[i].xiaoyu=1;            &#125;            else if(ch2[1]==&#39;&gt;&#39;&amp;&amp;ch2[2]==&#39;=&#39;)&#123;                node[i].dayudengyu=1;            &#125;            else node[i].dayu=1;            scanf(&quot;%lld&quot;,&amp;node[i].val1);            scanf(&quot;%s&quot;,ch3+1);            node[i].opt2=work(ch3[2]);            scanf(&quot;%s&quot;,ch2+1);            ll x=0;            ll it=2,f=1;            if(ch2[1]==&#39;-&#39;) f=-1;            while(isdigit(ch2[it]))&#123;                x=x*10+ch2[it]-&#39;0&#39;;                it++;            &#125;            if(ch2[it]==&#39;?&#39;)&#123;                node[i].wenhao=1;            &#125;            node[i].val2=x*f;        &#125;    &#125;//    for(ll i=1;i&lt;=a;i++)&#123;//        printf(&quot;opt1=%lld opt2=%lld val1=%lld val2=%lld wenhao=%lld &lt;%lld &lt;=%lld &gt;%lld &gt;=%lld\n&quot;,node[i].opt1,node[i].opt2,node[i].val1,node[i].val2,node[i].wenhao,node[i].xiaoyu,node[i].xiaoyudengyu,node[i].dayu,node[i].dayudengyu);//    &#125;    f[0][ita][itb][itc][itd]=100;    dice[0][0]=1.0;    for(ll i=0;i&lt;=16;i++)&#123;        for(ll j=0;j&lt;=32;j++)&#123;            dice[i+1][j+1]+=dice[i][j]*1.0/3.0;            dice[i+1][j+2]+=dice[i][j]*1.0/3.0;            dice[i+1][j]+=dice[i][j]*1.0/3.0;        &#125;    &#125;//    printf(&quot;ita=%lld itb=%lld itc=%lld itd=%lld************\n&quot;,ita,itb,itc,itd);//    printf(&quot;****\n&quot;);    for(ll i=0;i&lt;a;i++)&#123;        for(ll j1=1;j1&lt;=8;j1++)            for(ll j2=1;j2&lt;=8;j2++)                for(ll j3=1;j3&lt;=8;j3++)                    for(ll j4=1;j4&lt;=8;j4++)&#123;                        if(f[i][j1][j2][j3][j4])&#123;                            if(!needpan(i+1))&#123;                                if(node[i+1].wenhao)&#123;                                    ll cnt=abs(node[i+1].val1);                                    ll opt,opt1;                                    if(node[i+1].val1&lt;0) opt=-1;                                    else opt=1;                                    double delt=1;                                    opt1=node[i+1].opt1;                                    for(ll j=0;j&lt;=32;j++)&#123;                                        if(!dice[cnt][j]) continue ;                                        ll val=opt*j;                                        cal(i,j1,j2,j3,j4,opt1,val,dice[cnt][j]);                                    &#125;                                &#125;                                else &#123;                                    ll opt=node[i+1].opt1,val=node[i+1].val1;                                    cal(i,j1,j2,j3,j4,opt,val,1.0);                                &#125;                            &#125;                            else &#123;//void cal(ll i,ll j1,ll j2,ll j3,ll j4,ll opt,ll val,double gailv)&#123;                                ll opt1=node[i+1].opt1,opt2=node[i+1].opt2;                                ll val1=node[i+1].val1,val2=fabs(node[i+1].val2);                                ll opt;                                if(node[i+1].val2&lt;0) opt=-1;                                else opt=1;                                if(node[i+1].xiaoyu)&#123;//&lt;                                    if(opt1==1)&#123;                                        ll cnt1=mit[8-j1+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==2)&#123;                                        ll cnt1=spd[8-j2+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==3)&#123;                                        ll cnt1=san[8-j3+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;//                                                        printf(&quot;%lf cnt1=%lld val2=%lld dice\n&quot;,dice[cnt1][j]*dice[val2][q],cnt1,val2);                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);//                                                        printf(&quot;f=%lf\n&quot;,f[i+1][j1][j2][j3+opt*val2][j4]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==4)&#123;                                        ll cnt1=kno[8-j4+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                &#125;                                else if(node[i+1].dayu)&#123;                                    if(opt1==1)&#123;                                        ll cnt1=mit[8-j1+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==2)&#123;                                        ll cnt1=spd[8-j2+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==3)&#123;                                        ll cnt1=san[8-j3+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==4)&#123;                                        ll cnt1=kno[8-j4+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;=val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                &#125;                                else if(node[i+1].dayudengyu)&#123;                                    if(opt1==1)&#123;                                        ll cnt1=mit[8-j1+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==2)&#123;                                        ll cnt1=spd[8-j2+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==3)&#123;                                        ll cnt1=san[8-j3+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==4)&#123;                                        ll cnt1=kno[8-j4+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&lt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                &#125;                                else &#123;                                    if(opt1==1)&#123;                                        ll cnt1=mit[8-j1+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==2)&#123;                                        ll cnt1=spd[8-j2+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==3)&#123;                                        ll cnt1=san[8-j3+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                    if(opt1==4)&#123;                                        ll cnt1=kno[8-j4+1];                                        for(ll j=0;j&lt;=32;j++)&#123;                                            if(j&gt;val1)                                                f[i+1][j1][j2][j3][j4]+=dice[cnt1][j]*f[i][j1][j2][j3][j4];                                            else &#123;                                                if(node[i+1].wenhao)&#123;                                                    for(ll q=0;q&lt;=32;q++)&#123;                                                        cal(i,j1,j2,j3,j4,opt2,opt*q,dice[cnt1][j]*dice[val2][q]);                                                    &#125;                                                &#125;                                                else &#123;                                                    cal(i,j1,j2,j3,j4,opt2,opt*val2,dice[cnt1][j]);                                                &#125;                                            &#125;                                        &#125;                                    &#125;                                &#125;                            &#125;                        &#125;                    &#125;    &#125;    double ans=0;    for(ll j1=1;j1&lt;=8;j1++)&#123;        for(ll j2=1;j2&lt;=8;j2++)&#123;            for(ll j3=1;j3&lt;=8;j3++)&#123;                for(ll j4=1;j4&lt;=8;j4++)&#123;                    if(f[a][j1][j2][j3][j4])&#123;//                        printf(&quot;f[%lld][%lld][%lld][%lld][%lld]=%lf\n&quot;,a,j1,j2,j3,j4,f[a][j1][j2][j3][j4]);                        ans1[mit[8-j1+1]]+=f[a][j1][j2][j3][j4];                        ans2[spd[8-j2+1]]+=f[a][j1][j2][j3][j4];                        ans3[san[8-j3+1]]+=f[a][j1][j2][j3][j4];                        ans4[kno[8-j4+1]]+=f[a][j1][j2][j3][j4];                    &#125;                &#125;            &#125;        &#125;    &#125;    ans=0;    for(ll i=1;i&lt;=8;i++)        ans+=ans1[i];    printf(&quot;%.2lf\n&quot;,fabs(100-ans));    for(ll i=1;i&lt;=8;i++)        printf(&quot;%.2lf &quot;,ans1[i]);    puts(&quot;&quot;);    for(ll i=1;i&lt;=8;i++)        printf(&quot;%.2lf &quot;,ans2[i]);    puts(&quot;&quot;);    for(ll i=1;i&lt;=8;i++)        printf(&quot;%.2lf &quot;,ans3[i]);    puts(&quot;&quot;);    for(ll i=1;i&lt;=8;i++)        printf(&quot;%.2lf &quot;,ans4[i]);    puts(&quot;&quot;);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何开启O2优化</title>
      <link href="/2025/03/14/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFO2%E4%BC%98%E5%8C%96/"/>
      <url>/2025/03/14/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFO2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-03 16:54</p><p>O2环境会使你的程序跑的特别快,然而大多数正式考试都不能开O2</p><p>然而平时做有些题强制开O2,会出现在本机运行正确,但是交上去RE的情况,这时你就要开O2了.</p><p>例如在本机运行时会有下标为-但可以运行,而O2你就会RE</p><p>那么如何开呢</p><p>类似这样</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)</code></pre><p>或者终端编译时输入</p><pre><code>g++ -O2 1.cpp -o  1</code></pre><p><code>或者从c++中编译中加入-O2   </code></p><pre><code> g++ 1.cpp -O2 </code></pre><p>guide我不会开’’’</p><p>update 8.8日</p><p>经测试#pragma GCC optimize(2)好像不行，</p><p>另一份厌氧代码（RE：76分）在#pragma GCC optimize(2)下表现结果正常，在lemon下运行100分且本机运行正常。</p><p>但若在终端下开 g++ 1.cpp -O2 或者会正常的爆炸，经调试，数组下标为负，在负下标里，O2运行出错</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>奇怪的道路</title>
      <link href="/2025/03/14/%E5%A5%87%E6%80%AA%E7%9A%84%E9%81%93%E8%B7%AF/"/>
      <url>/2025/03/14/%E5%A5%87%E6%80%AA%E7%9A%84%E9%81%93%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-30 10:35</p><p>DeepinC的题解</p><p>考场AC nb%%%%%%%%%%%%%%%%%%</p><p>2019&#x2F;4&#x2F;27<br>Day1 T3 奇怪的道路  </p><p>step1：复杂度分析  </p><p>1&lt;&#x3D; n &lt;&#x3D; 30, 0 &lt;&#x3D; m &lt;&#x3D; 30, 1 &lt;&#x3D; K &lt;&#x3D; 8.<br>按照习惯，正解复杂度一般在1e6-1e8级别<br>而且往往复杂度关系最大的就是最小的那个数<br>对，抓住那个k&#x3D;8打<br>所以说先蒙个复杂度<br>O（mnk）?太小<br>O（mn*2^k）这个差不多<br>所以试试状压？  </p><p>step2：算法  </p><p>算法一：<br>其实看到这么小的数据范围应该也能 &lt;感受一下&gt; 状压的气息吧<br>[任何一个城市都与恰好偶数条道路相连（0也被认为是偶数）]<br>奇数偶数？可以用0,1，两种状态表示，这很状压，这非常状压<br>设dp[n][m][state]表示已经考虑了n个城市，m条道路，所有城市状态为state时的情况数<br>如果你把n和p连起来，n-k&lt;&#x3D;p&lt;n (pow[i]表示2的i次方)<br>则<br>dp[n][m][state]+&#x3D;dp[n][m-1][state^pow[n]^pow[p]];<br>异或超棒的，当你连上一条路时，两个端点已经连上的路原来是奇数的就变成偶数，偶数就变成奇数<br>题库里内存128M，考试时内存256M，state太占内存，大概能处理n&#x3D;15，一半分  </p><p>算法二：（优化）<br>我说过那个最小的k是突破口吧？但是用上了吗？<br>根据复杂度分析，如果把那个2^n替换成2^k就可以了<br>那么就要把state的位数变成k，仔细一看，刚好合适<br>那么state的含义稍微一变：最后k座城市的状态<br>&lt;交线牛逼法&gt;很好啊，因为第i座城市的状态转移只与最后k座城市有关<br>&lt;NOI2019 Day2 T1 mentor:中国好码农&gt;ing…<br>码出来的时候，忽然发现一个问题，我没考虑当前城市的情况，所以state的大小其实是2^(k+1)<br>&lt;王鹤松式&gt;没关系没关系，复杂度更接近上限了，正确的可能性更高了（玄学信仰）<br>状态转移的式子稍微一改<br>dp[n][m][state]+&#x3D;dp[n][m-1][state^1^pow[n-p]];<br>而且因为state的表示范围在变化，所以对于每个n，dp值都需要特殊转移<br>dp[n][m][（state&lt;&lt;1）&amp;(pow[k+1]-1)]+&#x3D;dp[n-1][m][state];<br>dp[n][m][0]即为答案  </p><p>算法三：（无关紧要的优化）<br>时间小优化：<br>我是个听学长话的乖孩子。。。。。。<br>他说过，取模超级慢的是嘛？<br>怎么避免取模呢？减法优于取模，判断优于计算<br>inline long long mod(long long k){return k&gt;&#x3D;1000000007?k-1000000007:k;}<br>因为代码里只存在加法，所以计算结果不会超过1000000007*2，减去一个1000000007就行了<br>空间大优化：<br>为什么只有256M啊？NOI还有5G呢<br>可见，dp式子只从n-1转移到n<br>滚动数组！棒！<br>式子再稍微一改<br>dp[i&amp;1][j][s]&#x3D;mod(dp[i&amp;1][j][s]+dp[i&amp;1][j-1][s^1^pow[i-p]])；<br>dp[(i&amp;1)^1][j][s&lt;&lt;1]&#x3D;dp[i&amp;1][j]；<br>滚起来别忘了清空数组<br>dp[i&amp;1][j][s]&#x3D;0;  </p><p>编号 题目 状态 分数 总时间 内存 代码 &#x2F; 答案文件 提交者 提交时间<br>#57153<br>#C. 奇怪的道路<br>Accepted 100 67 ms 616 KiB C++11 &#x2F; 754 B DeepinC (吴迪) 2019-04-27 21:46:34  </p><p>20个测试点，时间还不错<br>k&#x3D;8的话目测可以处理m&#x3D;n&#x3D;300；</p><p>代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排队（排列组合）</title>
      <link href="/2025/03/14/%E6%8E%92%E9%98%9F%EF%BC%88%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89/"/>
      <url>/2025/03/14/%E6%8E%92%E9%98%9F%EF%BC%88%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-06-27 11:15</p><p>题目大意：</p><p>两个老师，n个男，m个女，女不互邻，老师不互邻 方案</p><p>不是${A_n^n}<em>{A_{n+1}^m}</em>{A_{n+m+1}^2}$，也不是${A_n^n}<em>{A_{n+1}^2}</em>{A_{n+3}^m}$</p><p>因为这两种都没有考虑两个老师||两个女生互邻然后中间再插一个（挡板法默认不相邻）</p><p>首先用${A_{n+1}^{n+1}}$$*$ ${A_{n+2}^{m-1}}$$<em>m</em>2$求出老师老师之间插男生时情况</p><p>那么应该再加上两个老师之间插一个女生</p><p>首先默认两个老师相邻因为两个老师不同，所以有两种情况${A_2^2}$，然后中间塞一个女生有m种情况;</p><p>然后把“”老师“”–“”女生“”–“”老师“”看作一个组合体即看成一个男生</p><p>然后剩余m-1个女生往n+2个空里插</p><p>所得${A_{n+1}^{n+1}}$$*$$A_{n+2}^{m-1}$$<em>m</em>2$&#96;&#96;</p><p>最终相加得到$ans&#x3D;$${A_n^n}<em>{A_{n+1}^2}</em>{A_{n+3}^m}$$+$${A_{n+1}^{n+1}}$$*$$A_{n+2}^{m-1}$$<em>m</em>2$</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define N 10000#define P 4using namespace std;ll n,m;struct bignum&#123;    ll n[20000],l;    bignum()&#123;l=1,memset(n,0,sizeof(n));&#125;    void clear()&#123;while(l&gt;1&amp;&amp;!n[l-1]) l--;&#125;    void print()    &#123;        printf(&quot;%lld&quot;,n[l-1]);        for(ll i=l-2;i&gt;=0;i--)        printf(&quot;%0*lld&quot;,P,n[i]);        printf(&quot;\n&quot;);    &#125;    bignum operator = (ll x)    &#123;        l=0;            while(x)        &#123;            n[l++]=x%N;            x/=N;        &#125;        return *this;    &#125;    bignum operator +(bignum x) const    &#123;        bignum t=*this;        if(x.l&gt;t.l) t.l=x.l;                for(ll i=0;i&lt;t.l;i++)        &#123;            t.n[i]+=x.n[i];            if(t.n[i]&gt;=N)            &#123;                t.n[i+1]+=t.n[i]/N;                t.n[i]%=N;            &#125;        &#125;        return t;    &#125;       bignum operator * (const ll&amp; b)      &#123;        bignum c;           c.l=0;        for(ll i=0,g=0;g||i&lt;l;i++)        &#123;            ll x;            if(i&lt;l)x=n[i]*b+g;            else x=g;            c.n[c.l++]=x%N;            g=x/N;        &#125;        return c;    &#125;    bignum operator *(bignum x) const    &#123;        bignum t=*this,tep;        tep.l=t.l+x.l;        for(ll i=0;i&lt;t.l;i++)            for(ll j=0;j&lt;=x.l;j++)            &#123;                tep.n[i+j]+=t.n[i]*x.n[j];            &#125;        for(ll i=0;i&lt;tep.l;i++)        &#123;            tep.n[i+1]+=tep.n[i]/N;            tep.n[i]%=N;        &#125;        tep.clear();        return tep;    &#125;        bool operator &lt;(bignum x) const    &#123;        bignum t=*this,tep;        if(t.l!=x.l)    return t.l&lt;x.l;        for(ll i=t.l-1;i&gt;=0;i--)        &#123;            if(t.n[i]!=x.n[i]) return t.n[i]&lt;x.n[i];        &#125;        return 0;    &#125;    bool operator &gt;(bignum x) const    &#123;        bignum t=*this;        if(t.l!=x.l) return t.l&gt;x.l;        for(ll i=t.l-1;i&gt;=0;i--)        &#123;            if(t.n[i]!=x.n[i]) return t.n[i]&gt;x.n[i];        &#125;        return 0;    &#125;    bignum operator -(bignum x) const    &#123;        bignum t=*this;        if(t&lt;x) printf(&quot;-&quot;);swap(t,x);        ll jie=0;        for(ll i=0;i&lt;t.l;i++)        &#123;            t.n[i]-=x.n[i];            while(t.n[i]&lt;0)            &#123;                t.n[i]+=N;                jie++;            &#125;            t.n[i+1]-=jie;            jie=0;        &#125;        while(!t.n[t.l-1]&amp;&amp;t.l&gt;1) t.l--;        return t;    &#125;&#125;ans,c;bignum A(ll m,ll n)&#123;//    if(m&gt;n) return bignum();    bignum c;    c=1;    for(ll i=n-m+1;i&lt;=n;i++)        c=c*i;    return c;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    ans=0;    ans=A(n,n)*(A(2,n+1)*A(m,n+3)+A(1,n+1)*A(2,2)*A(1,m)*A(m-1,n+2));    ans.print();&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向简单题记录</title>
      <link href="/2025/03/14/%E9%80%86%E5%90%91%E7%AE%80%E5%8D%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/03/14/%E9%80%86%E5%90%91%E7%AE%80%E5%8D%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>归档于  2022-11-06 14:21</p><p><img src="https://img2022.cnblogs.com/blog/1708132/202211/1708132-20221106141940348-262999067.png" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202211/1708132-20221106141953616-1815758873.png" alt="image"><br>关于最后的<img src="https://img2022.cnblogs.com/blog/1708132/202211/1708132-20221106142007555-1057117749.png" alt="image"><br>v7处在esp+40h的位置 esp+40h-41&#x3D;esp+17h 此时再加5*v3[25]+v4可得到为v3数组中某值 v3为行，v4为列</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>猫和狗（二分图）</title>
      <link href="/2025/03/14/%E7%8C%AB%E5%92%8C%E7%8B%97%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%89/"/>
      <url>/2025/03/14/%E7%8C%AB%E5%92%8C%E7%8B%97%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-17 17:53</p><h1 id="猫和狗"><a href="#猫和狗" class="headerlink" title="猫和狗"></a>猫和狗</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>小k同学正在玩一个游戏，在游戏中他扮演了一个马戏团的老板，现在小k同学需要利用马戏团中的A只猫和B只狗举办一次表演，表演之前他让观众进行了投票，投票的类容是：我想看到第___号猫&#x2F;狗的表演，不想看到第___号猫&#x2F;狗的表演。注意到每个观众都是更喜欢猫或更喜欢狗，所以两个空后面一定会被勾上不同的内容。喜欢猫的观众会在第一空后面选择猫，第二空后面选择狗；反之就会在第一空后面选择狗，第二空后面选择猫。对于每一个观众，只有当TA投票的内容都被满足了（即TA想看到的动物出场表演，TA不想看到的动物不参与表演）的时候，TA才会来看表演。当然啦，看表演是要付门票钱的，作为马戏团的老板，小k自然是希望来的人越多越好了。他想找到一个安排动物表演的方案，使得来看表演的观众尽量多。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行3个正整数n,m,k，分别表示猫、狗和观众的数量</p><p>第2~k+1行，每行描述了一个观众的投票内容。</p><p>首先输入一个字符C或D紧接着是一个数字，表示某个观众想看到的动物，然后是一个空格隔开，接下去又是一个C或D加上一个数字，表示这个观众不想看到的动物，同一行中一定不会出现两个C或两个D。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行一个正整数，表示小k在最优的安排下可以吸引多少观众来看表演。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>1 2 4C1 D1C1 D1C1 D2D2 C1</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>3</code></pre><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>对于25%的数据n,m≤10,k≤25; 对于100%的数据，n,m≤300,k≤500.</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,question,catnum,dognum;int a[601][601],result[20000],tot=0;int id[601][601];bool state[1000];bool find(int aa)&#123;    for(int j=1;j&lt;=n;j++)        if(a[aa][j]==1&amp;&amp;state[j]==0)        &#123;            state[j]=1;            if(result[j]==0||find(result[j]))            &#123;                result[j]=aa;                return 1;            &#125;        &#125;    return 0;&#125;int main()&#123;    cin&gt;&gt;catnum&gt;&gt;dognum&gt;&gt;n;    int x,y;    string aa[600],bb[600];    for(int i=1;i&lt;=n;i++)    &#123;        cin&gt;&gt;aa[i];        cin&gt;&gt;bb[i];    &#125;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)        &#123;            if(aa[i]==bb[j]) a[i][j]=a[j][i]=1;         &#125;    for(int i=1;i&lt;=n;i++)    &#123;        memset(state,0,sizeof(state));        if(find(i)) tot++;     &#125;    cout&lt;&lt;n-tot/2&lt;&lt;endl;&#125;</code></pre><p>View Code</p><p>系统复习了一下二分图，觉得这个题挺有价值</p><p>我们将有矛盾的人之间建边，然后求出来最小独立集即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>旅行计划「分块优化」</title>
      <link href="/2025/03/14/%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92%E3%80%8C%E5%88%86%E5%9D%97%E4%BC%98%E5%8C%96%E3%80%8D/"/>
      <url>/2025/03/14/%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92%E3%80%8C%E5%88%86%E5%9D%97%E4%BC%98%E5%8C%96%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-24 16:40</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>第一次遇到这种思路,觉得需要写一写</p><p>暴力的话就是直接dp</p><p>$f[x][y][j]$表示从x走到y走恰好j步最少路径长度</p><p>转移$f[x][y][i]&#x3D;min(f[x][j][i-1]+edg[j][y])$</p><p>因为要至少j步,我们求出来恰好j步然后维护后缀最小值即可</p><p>期望得分$10-40$</p><p>正解是分块</p><p>同样维护$f[x][y][j]$同样维护从x走到y恰好j步最少路径长度,</p><p>多维护$f2[x][y][j]$表示走$100*j$步方案数</p><p>转移$f2[x][y][j]&#x3D;min(f[x][j][100]+f2[j][y][j-1])$</p><p>然后再维护$f3$是至少$j$步(即$f$数组后缀最小值)</p><p>这样回答是$min(f2[x][j][i&#x2F;100]+f3[j][y][i {\Huge %}100])$</p><p>$O(n)$回答</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 55ll n,m,tot,tot2,qq,s,t,pla;ll edg[A][A],f[A][A][111],f2[A][A][111];int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    memset(edg,0x3f,sizeof(edg));    for(ll i=1;i&lt;=m;i++)&#123;        ll a,b,c;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);        edg[a][b]=min(c,edg[a][b]);    &#125;    memset(f,0x3f,sizeof(f));    memset(f2,0x3f,sizeof(f2));    for(ll k=1;k&lt;=n;k++)        f[k][k][0]=0;    for(ll q=1;q&lt;=101;q++)        for(ll i=1;i&lt;=n;i++)            for(ll k=1;k&lt;=n;k++)                for(ll j=1;j&lt;=n;j++)                    f[i][j][q]=min(f[i][k][q-1]+edg[k][j],f[i][j][q]);    for(ll k=1;k&lt;=n;k++)        for(ll k2=1;k2&lt;=n;k2++)            f2[k][k][0]=0,f2[k][k2][1]=f[k][k2][100];    for(ll q=2;q&lt;=101;q++)        for(ll k=1;k&lt;=n;k++)            for(ll i=1;i&lt;=n;i++)                    for(ll j=1;j&lt;=n;j++)&#123;                f2[i][j][q]=min(f[i][k][100]+f2[k][j][q-1],f2[i][j][q]);//                if(q&lt;=2)//                printf(&quot;f2[%lld][%lld][%lld]=%lld f[%lld][%lld][%lld]=%lld\n&quot;,i,j,q,f2[i][j][q],i,j,100ll,f[i][j][100]);            &#125;    for(ll q=100;q&gt;=0;q--)        for(ll i=1;i&lt;=n;i++)            for(ll j=1;j&lt;=n;j++)                        f[i][j][q]=min(f[i][j][q+1],f[i][j][q]);    scanf(&quot;%lld&quot;,&amp;qq);    for(ll i=1;i&lt;=qq;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;s,&amp;t,&amp;pla);        ll ans=123456789101112;        for(ll j=1;j&lt;=n;j++)&#123;            ans=min(f2[s][j][pla/100]+f[j][t][pla%100],ans);//        printf(&quot;f2[%lld][%lld][%lld]=%lld f[%lld][%lld][%lld]=%lld\n&quot;,s,j,pla/100,f2[s][j][pla/100],j,t,pla%100,f[j][t][pla%100]);        &#125;        if(ans==123456789101112) printf(&quot;-1\n&quot;);        else printf(&quot;%lld\n&quot;,ans);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乱搞及剪枝</title>
      <link href="/2025/03/14/%E4%B9%B1%E6%90%9E%E5%8F%8A%E5%89%AA%E6%9E%9D/"/>
      <url>/2025/03/14/%E4%B9%B1%E6%90%9E%E5%8F%8A%E5%89%AA%E6%9E%9D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-22 15:27</p><p>剪枝乱搞我觉得还是要总结一下的</p><h2 id="乱搞"><a href="#乱搞" class="headerlink" title="乱搞"></a>乱搞</h2><h3 id="毛三琛"><a href="#毛三琛" class="headerlink" title="毛三琛"></a>毛三琛</h3><p>正解是乱搞及剪枝</p><p>随机化,用剪枝增多随机化次数</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 44444ll n,mod,k,ans,maxx;ll a[A],b[A],p[A],q[A];ll random(ll x)&#123;    return 1ll*rand()%x;&#125;ll check(ll mid)&#123;    ll cnt=1,sum=0;    for(ll i=1;i&lt;=n;i++)&#123;        if(sum+b[i]&lt;=mid)&#123;            sum+=b[i];        &#125;        else &#123;            sum=b[i];            cnt++;        &#125;        if(cnt&gt;k) return 0;    &#125;    return 1;&#125;void work()&#123;    ll l=maxx,r=ans;    ll nowans=0x7fffffff;    while(l&lt;=r)&#123;        ll mid=(l+r)&gt;&gt;1;        if(check(mid))&#123;            r=mid-1;            nowans=mid;        &#125;        else l=mid+1;//        if(l&gt;ans) return ;    &#125;    ans=min(ans,nowans);&#125;int main()&#123;    ans=0;    srand((unsigned)time(0));    double st=clock();    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;mod,&amp;k);    for(int i=0;i&lt;mod;++i)p[i]=i;    random_shuffle(p+0,p+mod);    random_shuffle(p+0,p+mod);    random_shuffle(p+0,p+mod);    random_shuffle(p+0,p+mod);    random_shuffle(p+0,p+mod);        for(ll i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;a[i]),ans+=a[i],maxx=max(a[i],maxx);    for(int kx=1;kx&lt;=mod;++kx)&#123;        ll i=p[kx-1];        maxx=0;        double ed=clock();        if((ed-st)/1e6&gt;0.99) break;        for(ll j=1;j&lt;=n;j++)            b[j]=(a[j]+i)%mod,maxx=max(maxx,b[j]);        if(!check(ans)) continue ;        work();            &#125;    printf(&quot;%d\n&quot;,ans);&#125;</code></pre><p>View Code</p><h3 id="小P的生成树"><a href="#小P的生成树" class="headerlink" title="小P的生成树"></a>小P的生成树</h3><p>神仙生成树</p><p>类似最小方差生成树</p><p>然而可以用这种方法乱搞</p><pre><code>    friend bool operator &lt; (const node &amp;c,const node &amp;d)&#123;        return c.a*k1+c.b*k2&gt;d.a*k1+d.b*k2;    &#125;        k1=random(20000)-10000,k2=random(20000)-10000;        init();        sort(edg+1,edg+m+1);</code></pre><h3 id="SKYH的最短路"><a href="#SKYH的最短路" class="headerlink" title="SKYH的最短路"></a>SKYH的最短路</h3><p>有一些边权不确定,但不确定的边权全部相等,每个点能否在最短路上</p><p>随机化,卡时&#x3D;&#x3D;AC</p><p>注意判断每个点能否在最短路</p><p>可能有多条最短路径</p><p>vector存一下跑拓扑排序</p><h3 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h3><p>$1e12$,有循环节</p><p>循环接长度150</p><p>正解太神了,我不会,神仙矩阵快速幂优化</p><p>怎么乱搞?</p><p>找出len*len循环节即可</p><p>若n&gt;len<em>len跑len</em>len,否则跑满n</p><p>为什么是len*len</p><p>这样能取遍循环节每一个元素</p><p>即使出现1 2 3 4 5 6 这样循环节,我们也可以这样取出第一个循环节1,第二个循环节2,,,,,,,,,,,依次类推</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n,t,a,b,c,d,kuku,maxn;struct node&#123;    ll l,r,val;&#125;tr[8222222];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        tr[x].val=0;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void change(ll x,ll pla,ll val)&#123;    if(tr[x].l==tr[x].r)&#123;        tr[x].val=val;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla)change(x&lt;&lt;1,pla,val);    else change(x&lt;&lt;1|1,pla,val);    tr[x].val=max(tr[x&lt;&lt;1].val,tr[x&lt;&lt;1|1].val);&#125;void ask(ll x,ll l,ll r)&#123;    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        maxn=max(maxn,tr[x].val);        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) ask(x&lt;&lt;1,l,r);    if(mid&lt;r)  ask(x&lt;&lt;1|1,l,r);&#125;ll top;ll lis[22222222],vis[22222222];ll cnt=0,len,tot,lit,st,ans=0;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;t,&amp;a,&amp;b,&amp;c,&amp;d);    ll mx=t;    for(ll i=1;i&lt;=n;i++)&#123;        if(vis[lis[++tot]=t])&#123;st=vis[lis[tot]];len=i-vis[t];lit=i-1;break;&#125;        vis[t]=i;        t=(t*t*a+b*t+c)%d;        mx=max(mx,t);    &#125;    if(!st) st=n+1;    lit=min(n,lit+len*len);    for(ll i=st+len;i&lt;=lit;i++)&#123;        lis[i]=lis[i-len];        tot++;    &#125;    built(1,0,mx);    for(ll i=1;i&lt;=tot;i++)&#123;        maxn=0;        ask(1,0,lis[i]);        change(1,lis[i],maxn+1);        if(i&gt;=st)&#123;            ans=max(ans,(n-i)/len+maxn+1);//            printf(&quot;a[i]=%lld i=%lld n-i/len+maxn+1=%lld\n&quot;,lis[i],i,(n-i)/len+maxn+1);        &#125;        else ans=max(ans,maxn+1);    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191114095947787-1130225988.png"></p><p>贪心就是按照$b-a$从大到小排序,然后每次先取出a最大值,如果可以爬出就爬出,否则取出$b-a$继续爬</p><p>然而不对</p><p>2 999</p><p>100 1</p><p>900 800</p><p>会先选900 800,然后选100 1</p><p>显然不对</p><p>然后Lrefrain神跟我说贪心是对的,可以微扰证明,我没过就是我个傻逼写错了</p><p>他说对拍700000组都没错,这个贪心一定是对的</p><p>第二天我两组hack数据他都没过</p><p>正解很神</p><p>所以枚举角度无脑AC</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>/*2 999900 80099 02 22but-16 84 23 53 42 46 31 1132231*/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111111ll vis[A],c[A];ll ans=0x3f3f3f3f;ll n,l,zong,now,wwb;struct node&#123;    ll a,b,id;    node()&#123;&#125;    node(const ll &amp;c,const ll &amp;d,const ll &amp;e)&#123;a=c,b=d,id=e;&#125;    friend bool operator &lt; (const node &amp;c,const node &amp;d)&#123;        return c.a&lt;d.a;    &#125;&#125;s[A];priority_queue&lt;node&gt; q;inline ll cmp1(const node &amp;x,const node &amp;y)&#123;    return ((x.a-x.b)==(y.a-y.b))?(x.a&lt;y.a):(x.a-x.b&gt;y.a-y.b);&#125;double delta=0;inline ll cmp5(const node &amp;x,const node &amp;y)&#123;    return 1.0*x.a*delta-x.b&gt;1.0*y.a*delta-y.b;&#125;ll work()&#123;    memset(vis,0,sizeof(vis));    now=0,wwb=0;    while(!q.empty()) q.pop();    for(ll i=1;i&lt;=n;i++)        q.push(s[i]);    for(ll i=1;i&lt;=n;i++)&#123;        while(vis[q.top().id]) q.pop();        if(now+q.top().a&gt;=l) return i;        vis[s[i].id]=1;        now+=s[i].a-s[i].b;wwb+=c[i];        if(now&lt;=wwb) return 0x3f3f3f3f;    &#125;&#125;void print()&#123;    if(ans==0x3f3f3f3f) puts(&quot;-1&quot;);    else printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123;    freopen(&quot;climb.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;climb.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;l);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;s[i].a,&amp;s[i].b);        s[i].id=i;    &#125;    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;c[i]);    for(double i=0;i&lt;=1;i+=0.1)&#123;        if(clock()&gt;1800000)&#123;            print();            return 0;        &#125;        delta=i;        sort(s+1,s+n+1,cmp5);        ans=min(work(),ans);        if(clock()&gt;1800000)&#123;            print();            return 0;        &#125;    &#125;    print();    return 0;&#125;</code></pre><p>View Code</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="打扫卫生"><a href="#打扫卫生" class="headerlink" title="打扫卫生"></a>打扫卫生</h3><p>打扫干净屋子再请客</p><p>最优性剪枝</p><pre><code>            if(nowcnt*nowcnt&gt;f[i]) break;</code></pre><h3 id="毛三琛-1"><a href="#毛三琛-1" class="headerlink" title="毛三琛"></a>毛三琛</h3><p>剪枝比较显然,但没有见过,没有想到</p><p>r越大符合可能性越高,如果check(r)都不符合,那么就一定不符合直接continue,,check下一个</p><h3 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h3><p>最优性剪枝,可行性剪枝</p><p>还有一种剪枝1 2 3 ,1 3 2 ,2 1 3都是一种方案,只枚举其中一种,</p><p>因为是矩阵实现起来比较麻烦,但可以用id实现</p><p>还有为了剪最优性的枝可以先sort贪心求出一种看似很优的解</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 void dfs(ll sum,ll qs)&#123; 2 //    printf(&quot;sum=%lld\n&quot;,sum); 3 //    printf(&quot;%lld\n&quot;,ans); 4     if(sum&gt;=ans) return ; 5     if(check())&#123; 6         ans=min(ans,sum); 7 //        printf(&quot;ans=%lld\n&quot;,ans); 8         return ; 9     &#125;10     if(clock()&gt;960000)&#123;11         printf(&quot;%lld\n&quot;,ans);12         exit(0);13     &#125;14     for(ll k=qs;k&lt;=n*m;k++)&#123;15         ll i=tmp[k].x,j=tmp[k].y;16             if(!vis[i][j])&#123;17                 if(ok(i,j))&#123;18 //                    printf(&quot;enter %lld %lld\n&quot;,i,j);19                     vis[i][j]=1;20                     ll x=i,y=j,21                     yuan1=now[x-1&lt;1?1:x-1][y],22                     yuan2=now[x+1&gt;n?x:x+1][y],23                     yuan3=now[x][y-1&lt;1?1:y-1],24                     yuan4=now[x][y+1&gt;m?y:y+1],25                     yuan5=now[x][y];26                     now[x-1&lt;1?1:x-1][y]=1;27                     now[x+1&gt;n?x:x+1][y]=1;28                     now[x][y-1&lt;1?1:y-1]=1;29                     now[x][y+1&gt;m?y:y+1]=1;30                     now[x][y]=1;31                     dfs(sum+val[i][j],k+1);32 //                    printf(&quot;hui %lld %lld\n&quot;,i,j);33                     vis[i][j]=0;34                     now[x-1&lt;1?1:x-1][y]=yuan1;35                     now[x+1&gt;n?x:x+1][y]=yuan2;36                     now[x][y-1&lt;1?1:y-1]=yuan3;37                     now[x][y+1&gt;m?y:y+1]=yuan4;38                     now[x][y]=yuan5;39                 &#125;40             &#125;41     &#125;42 &#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>零碎</title>
      <link href="/2025/03/14/%E9%9B%B6%E7%A2%8E/"/>
      <url>/2025/03/14/%E9%9B%B6%E7%A2%8E/</url>
      
        <content type="html"><![CDATA[<p>归档于  2022-11-04 20:28</p><h2 id="ls-xargs-cat"><a href="#ls-xargs-cat" class="headerlink" title="ls | xargs cat"></a>ls | xargs cat</h2><p>cat不支持管道传递参数<br>需要使用xargs将ls的东西传递到cat里</p><h2 id="cat-IFS-1flag-php"><a href="#cat-IFS-1flag-php" class="headerlink" title="cat$IFS$1flag.php"></a>cat$IFS$1flag.php</h2><p>$IFS用作分隔符，然后$1做占位，无实意，（不分隔$会匹配多位匹配截止到$IFSflag</p><p>\(haha\)<br>$haha$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>理科卷math·english·chinese·biology·chemistry·physics</title>
      <link href="/2025/03/14/%E7%90%86%E7%A7%91%E5%8D%B7math%C2%B7english%C2%B7chinese%C2%B7biology%C2%B7chemistry%C2%B7physics/"/>
      <url>/2025/03/14/%E7%90%86%E7%A7%91%E5%8D%B7math%C2%B7english%C2%B7chinese%C2%B7biology%C2%B7chemistry%C2%B7physics/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-29 11:54</p><p>一套比一套炸,果然我只会做B卷,虽然我B也很差但没差到这种地步</p><h2 id="math"><a href="#math" class="headerlink" title="$math$"></a>$math$</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看似没法做但总会有突破口</p><p>$70%$</p><p>发现和小凯的诱惑很像,于是看$gcd$是否为$1$只要为$1$可以凑齐所有数</p><p>$n^2$枚举两两$gcd$</p><p>$80%$</p><p>我考试时思路</p><p>找到每一个数和$mod$的$gcd$,发现只要是任一$gcd$倍数就可以凑出来,于是枚举每一个数和$mod$的$gcd$,瓶颈在于统计答案</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2222222ll n,k,cnt=0;ll a[A],dl[A],ok[A];ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;)            f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;int main()&#123;    n=read(),k=read();        for(ll i=1;i&lt;=n;i++)        a[i]=read(),dl[++dl[0]]=a[i];    for(ll i=1;i&lt;=dl[0];i++)&#123;        ll g=gcd(dl[i],k);        if(g==1)&#123;            printf(&quot;%lld\n&quot;,k);            for(ll j=0;j&lt;=k-1;j++)&#123;                printf(&quot;%lld &quot;,j);            &#125;            return 0;        &#125;        else &#123;            for(ll i=g;i&lt;k;i+=g)&#123;                ok[i]=1;            &#125;            ok[0]=1;        &#125;    &#125;    for(ll i=0;i&lt;=k;i++)&#123;        if(ok[i]) cnt++;    &#125;    printf(&quot;%lld\n&quot;,cnt);    for(ll i=0;i&lt;=k;i++)&#123;    if(ok[i])    printf(&quot;%lld &quot;,i);    &#125;    printf(&quot;\n&quot;);&#125;</code></pre><p>View Code</p><p>$100%$</p><p>其实从$80%$我们就应该看出可以找到所有数$gcd$,然后只有为$gcd$倍数才可以凑出来</p><p>考试时我连这个都没有想到!</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll n,k,cnt=0;ll a[A],dl[A];ll read()&#123;    ll f=1,x=0;    char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;int main()&#123;    n=read(),k=read();    for(ll i=1;i&lt;=n;i++)&#123;        a[i]=read();           while(a[i]&lt;0)&#123;            a[i]+=k;        &#125;    &#125;    ll g=gcd(a[1],a[2]);    g=gcd(g,k);    for(ll i=3;i&lt;=n;i++)        g=gcd(a[i],g);    for(ll i=0;i&lt;k;i+=g)&#123;        cnt++;        dl[++dl[0]]=i;    &#125;    printf(&quot;%lld\n&quot;,cnt);    for(ll i=1;i&lt;=dl[0];i++)&#123;        printf(&quot;%lld &quot;,dl[i]);    &#125;    printf(&quot;\n&quot;);&#125;</code></pre><p>View Code</p><h2 id="english"><a href="#english" class="headerlink" title="$english$"></a>$english$</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>破题打了很久从$23$日打到$27$日</p><p>然而考试两个人当场$AC$</p><p>思路还算比较简单,然而很难打,不用说了我码力太弱</p><p>$ans1$还算比较简单,和学数数那个题很像,</p><p>我们找到以每一个值为最大值的最左$l$,最右$r$</p><p>设当前值位置为$now$</p><p>那么因为是异或,造成贡献的只有$now-l$中与$r-now$中二进制位相反的</p><p>设$0[x][j]$表示$1–x$中第$j$位为$0$数有多少个(这是前缀和)</p><p>类似设$1[x][j]$表示$1–x$中第$j$位为$1$数有多少个</p><p>那么$now$贡献就为$\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;最高位}<br>(0[now][j]-0[l-1][j])<em>(1[r][j]-1[now-1][j])+(1[now][j]-1[l-1][j])</em>(0[r][j]-0[now-1][j])$</p><p>然后问题又转化为了找到以每一个值为最大值的最左$l$,最右$r$</p><p>这里我还是用的我的老方法(愚蠢至极)</p><pre><code>void pre(ll l,ll r,ll now,ll nowmax)&#123;    if(l&gt;r) return ;    lef[now]=l,rig[now]=r;    if(l==r) &#123;        len[now]=r-l+1;        return ;    &#125;    maxn=-1,ida=0;    if(l&lt;=now-1)&#123;            seg_max(1,l,now-1);        pre(l,now-1,ida,maxn);    &#125;    maxn=-1,ida=0;    if(now+1&lt;=r)&#123;        seg_max(1,now+1,r);        pre(now+1,r,ida,maxn);    &#125;&#125;</code></pre><p>二分套线段树</p><p>复杂度玄学说是$n*{log(n)^2}$然而实际跑起来只比单调栈慢$400ms$,学数数还比单调栈快</p><p>$ans2$稍难但是还是寻找突破口</p><p>先放官方题解</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190829115634600-761784296.png"></p><p>这是很好的转化,我的实现和他不一样</p><p>(启发式合并太难打了,事实上我打了但根本没发调)</p><p>我用的可持久化$tire$,</p><p>可持久化$tire$可以查区间</p><p>要找到右面区间有多少个$xor$当前$a[j]$比最大值大</p><p>放进$tire$树里看如果最大值当前位为$1$,你不可能比它大,必须选相反位,为$0$比它大个数就是$size$了(size下所有都比它大)</p><p>放一下实现</p><pre><code>void work2()&#123;    root[0]=newnode();    for(ll i=1;i&lt;=n;i++)        root[i]=newnode(),insert(root[i-1],root[i],a[i]);    for(ll i=1;i&lt;=n;i++)&#123;        ll tmp=0;        if(rig[i]-i&gt;i-lef[i])            for(ll j=lef[i];j&lt;=i;j++)                tmp=(tmp+query(root[i-1],root[rig[i]],a[j],a[i]))%mod;        if(rig[i]-i&lt;=i-lef[i])            for(ll j=i;j&lt;=rig[i];j++)                tmp=(tmp+query(root[lef[i]-1],root[i],a[j],a[i]))%mod;        ans2=(ans2+tmp*a[i])%mod;    &#125;&#125;ll query(ll F,ll C,ll now,ll big)&#123;    ll ans=0;    for(ll i=20;i&gt;=0;i--)&#123;        ll num[2];        num[0]=sz[ch[C][0]]-sz[ch[F][0]];        num[1]=sz[ch[C][1]]-sz[ch[F][1]];        ll         nowbit=(now&gt;&gt;(i))&amp;1,        bigbit=(big&gt;&gt;(i))&amp;1;        if(bigbit) F=ch[F][nowbit^1],C=ch[C][nowbit^1];        else F=ch[F][nowbit],C=ch[C][nowbit],ans=(ans+num[nowbit^1]%mod);     &#125;    return ans;&#125;</code></pre><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 222222const ll mod=1e9+7;ll n,q,mx,mn=0x7fffffffff,ida,maxn,idb,thebigest,thebigestid,ans1,ans2;ll a[A],sum[A],b[A],ls[A],rs[A],len[A],_0[A][33],_1[A][33],lef[A],rig[A],sta[A];ll root[A];ll sz[11111111];ll ch[11111111][2];ll totnode=1,top=0;char c[10];struct tree&#123;    ll l,r,val,id;&#125;tr[A];void init()&#123;    for(ll i=1;i&lt;=n;++i)&#123;        while(top&amp;&amp;a[sta[top]]&lt;a[i]) rig[sta[top--]]=i-1;        sta[++top]=i;    &#125;    while(top) rig[sta[top--]]=n;    for(ll i=n;i&gt;=1;--i)&#123;        while(top&amp;&amp;a[sta[top]]&lt;=a[i]) lef[sta[top--]]=i+1;        sta[++top]=i;    &#125;    while(top) lef[sta[top--]]=1;&#125;void pushup(ll p)&#123;    if(tr[p&lt;&lt;1].val&gt;tr[p&lt;&lt;1|1].val)&#123;        tr[p].val=tr[p&lt;&lt;1].val;        tr[p].id=tr[p&lt;&lt;1].id;    &#125;    else &#123;        tr[p].val=tr[p&lt;&lt;1|1].val;        tr[p].id=tr[p&lt;&lt;1|1].id;    &#125;&#125;void built(ll p,ll l,ll r)&#123;    tr[p].l=l,tr[p].r=r;    if(l==r)&#123;        tr[p].val=a[l];        tr[p].id=l;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(p&lt;&lt;1,l,mid);    built(p&lt;&lt;1|1,mid+1,r);    pushup(p);&#125;void seg_max(ll p,ll l,ll r)&#123;    if(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)&#123;        if(tr[p].val&gt;maxn)&#123;            maxn=tr[p].val;            ida=tr[p].id;        &#125;        return ;    &#125;    ll mid=(tr[p].l+tr[p].r)&gt;&gt;1;    if(mid&gt;=l)        seg_max(p&lt;&lt;1,l,r);    if(mid&lt;r)        seg_max(p&lt;&lt;1|1,l,r);&#125;void pre(ll l,ll r,ll now,ll nowmax)&#123;    if(l&gt;r) return ;    lef[now]=l,rig[now]=r;    if(l==r) &#123;        len[now]=r-l+1;        return ;    &#125;    maxn=-1,ida=0;    if(l&lt;=now-1)&#123;            seg_max(1,l,now-1);        pre(l,now-1,ida,maxn);    &#125;    maxn=-1,ida=0;    if(now+1&lt;=r)&#123;        seg_max(1,now+1,r);        pre(now+1,r,ida,maxn);    &#125;&#125;void work1()&#123;    for(ll j=0;j&lt;=20;j++)        for(ll i=1;i&lt;=n;i++)&#123;            _0[i][j]=_0[i-1][j];            _1[i][j]=_1[i-1][j];            if((a[i]&amp;(1&lt;&lt;j))) _1[i][j]++;            else _0[i][j]++;        &#125;    for(ll i=1;i&lt;=n;i++)&#123;        ll tmp=0;        for(ll j=0;j&lt;=20;j++)&#123;            ll             l0=_0[i][j]-_0[lef[i]-1][j],            r0=_0[rig[i]][j]-_0[i-1][j],            l1=_1[i][j]-_1[lef[i]-1][j],            r1=_1[rig[i]][j]-_1[i-1][j];            tmp=(tmp+(l0*(r1%mod*(1&lt;&lt;j)%mod)))%mod;            tmp=(tmp+(l1*(r0%mod*(1&lt;&lt;j)%mod)))%mod;        &#125;ans1=(ans1+tmp*a[i])%mod;    &#125;&#125;ll newnode()&#123;    memset(ch[totnode],0,sizeof(ch[totnode]));    sz[totnode]=0;    return totnode++;&#125;//F之前树 C现在树 inline void insert(ll F,ll C,ll val)&#123;    for(ll i=20;i&gt;=0;i--)&#123;        ll bit=(val&gt;&gt;i)&amp;1;        if(!ch[C][bit])&#123;            ch[C][bit]=newnode();            ch[C][!bit]=ch[F][!bit];            sz[ch[C][bit]]=sz[ch[F][bit]];        &#125;        C=ch[C][bit],F=ch[F][bit];        sz[C]++;    &#125;&#125;ll query(ll F,ll C,ll now,ll big)&#123;    ll ans=0;    for(ll i=20;i&gt;=0;i--)&#123;        ll num[2];        num[0]=sz[ch[C][0]]-sz[ch[F][0]];        num[1]=sz[ch[C][1]]-sz[ch[F][1]];        ll         nowbit=(now&gt;&gt;(i))&amp;1,        bigbit=(big&gt;&gt;(i))&amp;1;        if(bigbit) F=ch[F][nowbit^1],C=ch[C][nowbit^1];        else F=ch[F][nowbit],C=ch[C][nowbit],ans=(ans+num[nowbit^1]%mod);     &#125;    return ans;&#125;void work2()&#123;    root[0]=newnode();    for(ll i=1;i&lt;=n;i++)        root[i]=newnode(),insert(root[i-1],root[i],a[i]);    for(ll i=1;i&lt;=n;i++)&#123;        ll tmp=0;        if(rig[i]-i&gt;i-lef[i])            for(ll j=lef[i];j&lt;=i;j++)                tmp=(tmp+query(root[i-1],root[rig[i]],a[j],a[i]))%mod;        if(rig[i]-i&lt;=i-lef[i])            for(ll j=i;j&lt;=rig[i];j++)                tmp=(tmp+query(root[lef[i]-1],root[i],a[j],a[i]))%mod;        ans2=(ans2+tmp*a[i])%mod;    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);        if(a[i]&gt;mx)            ida=i,mx=a[i];        mn=min(mn,a[i]);    &#125;    thebigestid=ida;    built(1,1,n);    pre(1,n,ida,a[ida]);    work1();work2();    if(q==1)printf(&quot;%lld\n&quot;,ans1);    if(q==2)printf(&quot;%lld\n&quot;,ans2);    if(q==3)printf(&quot;%lld\n%lld\n&quot;,ans1,ans2);&#125;</code></pre><p>View Code</p><h2 id="chinese"><a href="#chinese" class="headerlink" title="$chinese$"></a>$chinese$</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>炼字简称练字(其实是我懒得改了)</p><p>真·吃了语文的亏</p><p>考试一直在做这个题($2$小时左右)然而还是只会暴力(然后更加蠢的是我打了暴力没有打表,别人打表$60$分,我暴力$45$)</p><p>首先题目中式子含义要搞清楚</p><p>其实他就是让你统计所有方案有多少个练字</p><p>你放一个练字那么贡献就是当前所有方案数$*1$</p><p>当前方案数如何求呢?</p><p>假设当前在$x$,$y$填练字,,练字为$i$</p><p>那么$x$所在行剩下$m-1$个位置只能小$(i-1)^{(m-1)}$</p><p>类似的$y$所在列剩下$(i-1)^{(n-1)}$</p><p>剩下位置随便填</p><p>这样为什么是对的,(即为什么是练字个数)</p><p>假设你随便填里有一个练字,你算当前练字个数算了一个,下一次考虑时又考虑当前这个</p><p>或者你这么想,在这$(i-1)^{(n-1)}*(i-1)^{(m-1)}<em>k^{(n-1)</em>(m-1)}$每一种方案都计算了当前这个练字,,每种方案贡献为$1$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n,m,ans=0;const ll mod=1e9+7;ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)&#123;        if(k&amp;1)            ans=ans*x%mod;    &#125;    return ans;&#125;ll k;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    for(ll i=1;i&lt;=k;i++)        ans=(ans+meng(i-1,n-1)%mod*meng(i-1,m-1)%mod*meng(k,(n-1)*(m-1))%mod)%mod;    ans=(ans*n%mod*m%mod)%mod;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="biology"><a href="#biology" class="headerlink" title="$biology$"></a>$biology$</h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>$dp$,思路没有见过,还是要多见见,</p><p>首先暴力转移枚举每一个方格最小的复杂度$n^2*m^2$</p><p>思考优化</p><p>绝对值很恶心,考虑去掉绝对值</p><p>拆成$-x-y$,$+x+y$,$-x+y$,$+x-y$</p><p>然后发现一个性质我们把一个原本应该是$-x-y$的拆成$4$个另外三个并不会比$-x-y$变优</p><p>于是我们愉快维护四个最大值变量就行了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define maxn 2101ll n,m,cnt=0,st=0,ans=0,mx1=0,mx2=0,mx3=0,mx4=0;ll tmp1,tmp2,tmp3,tmp4,sta;ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;)            f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;struct node&#123;    ll x,y,val;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.val&lt;b.val;    &#125;&#125;c[maxn*maxn];ll b[maxn][maxn],f[maxn*maxn];int main()&#123;    n=read(),m=read();    for(ll i=1;i&lt;=n;i++)        for(ll j=1,a;j&lt;=m;j++)&#123;            scanf(&quot;%lld&quot;,&amp;a);            if(a==0) continue;            ++cnt;            c[cnt].x=i;            c[cnt].y=j;            c[cnt].val=a;    &#125;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            scanf(&quot;%lld&quot;,&amp;b[i][j]);        &#125;    sort(c+1,c+cnt+1);    for(ll i=cnt;i&gt;=2;i--)&#123;        if(c[i].val!=c[i-1].val)&#123;            sta=i;        &#125;    &#125;    for(ll i=1;i&lt;sta;i++)&#123;        ll x=c[i].x,y=c[i].y;        f[i]=b[c[i].x][c[i].y];//        printf(&quot;f[%lld]=%lld x=%lld y=%lld\n&quot;,i,f[i],x,y);        tmp1=max(tmp1,f[i]-x-y);        tmp2=max(tmp2,f[i]-x+y);        tmp3=max(tmp3,f[i]+x-y);        tmp4=max(tmp4,f[i]+x+y);        ans=max(ans,f[i]);    &#125;    for(ll i=sta;i&lt;=cnt;i++)&#123;        ll x=c[i].x,y=c[i].y;        if(c[i].val!=c[i-1].val)&#123;            mx1=max(mx1,tmp1);            mx2=max(mx2,tmp2);            mx3=max(mx3,tmp3);            mx4=max(mx4,tmp4);        &#125;//        printf(&quot;mx1=%lld 2=%lld 3=%lld 4=%lld\n&quot;,mx1,mx2,mx3,mx4);        ll an=0;        an=max(an,mx1+x+y);        an=max(an,mx2+x-y);        an=max(an,mx3-x+y);        an=max(an,mx4-x-y);        f[i]=an+b[c[i].x][c[i].y];        tmp1=max(tmp1,f[i]-x-y);//左上        tmp2=max(tmp2,f[i]-x+y);//右上        tmp3=max(tmp3,f[i]+x-y);//左下        tmp4=max(tmp4,f[i]+x+y);//右下        ans=max(ans,f[i]);    &#125;//    for(ll i=1;i&lt;=cnt;i++)&#123;//        printf(&quot;%lld\n&quot;,f[i]);//    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="physics"><a href="#physics" class="headerlink" title="$physics$"></a>$physics$</h2><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>前缀和?</p><p>为什么选择前缀和,前缀和查询$O(1)$我们主要时间在查询上$n^3$(或)$n^2*log(n)$,修改$n^2$绝对可以接受</p><p>于是前缀和就完了</p><p>满足二分性质可以进行二分,然而我没有打</p><p>类似于二分答案枚举当前可以分成的$n^2*log(n)$</p><pre><code>void ask()&#123;    int l=1,r=ans;    while(l&lt;=r)&#123;        int mid=(l+r)&gt;&gt;1;        if(judge(mid)) l=mid+1;        else r=mid-1;    &#125;&#125;</code></pre><p>我暴力$+$剪枝$AC$思考怎么剪枝</p><p>首先枚举是越修改越小的,我们可以记录下当前答案,然后下次验证时在当前答案基础上验证就行了</p><p>然后还有记录当前所有符合答案</p><pre><code>                    cnt++;                    mo[cnt].x=x,mo[cnt].y=y,mo[cnt].ok=1,mo[cnt].len=i;</code></pre><p>验证时</p><pre><code>        for(ll j=1;j&lt;=cnt;j++)            if(mo[j].ok)&#123;                if(x&gt;=mo[cnt].x&amp;&amp;x&lt;=mo[cnt].x+mo[cnt].len-1&amp;&amp;y&gt;=mo[cnt].y&amp;&amp;y&lt;=mo[cnt].y+mo[cnt].len-1) mo[j].ok=0;                else allok=1;            &#125;        if(allok) printf(&quot;%d\n&quot;,nowans);        else pre(),printf(&quot;%d\n&quot;,nowans);</code></pre><p>复杂度与变化次数相关</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 1111char a[A][A];ll cnt=0,n,m,k,maxx,nowans,nowlefx,nowlefy,nowrigx,nowrigy,llll,upup;ll sum[A][A];struct node&#123;    ll x,y,len,ok;&#125;mo[1111111];void pre()&#123;    cnt=0;    for(ll i=nowans;i&gt;=1;i--)&#123;        for(ll x=1;x&lt;=n-i+1;x++)&#123;            for(ll y=1;y&lt;=n-i+1;y++)                if(sum[x+i-1][y+i-1]+sum[x-1][y-1]-sum[x-1][y+i-1]-sum[x+i-1][y-1]==0)&#123;                        cnt++;                    mo[cnt].x=x,mo[cnt].y=y,mo[cnt].ok=1,mo[cnt].len=i;                    nowans=i;                &#125;            &#125;        if(cnt) return ;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%s&quot;,a[i]+1);        for(ll j=1;j&lt;=m;j++)            if(a[i][j]==&#39;-&#39;)                 sum[i][j]=1;    &#125;    ll x,y;    scanf(&quot;%d%d&quot;,&amp;x,&amp;y);    sum[x][y]=1;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            sum[i][j]=sum[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];    nowans=n;    pre();    printf(&quot;%d\n&quot;,nowans);    for(ll i=2,x,y;i&lt;=k;i++)&#123;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        for(ll i=x;i&lt;=n;i++)            for(ll j=y;j&lt;=m;j++)                sum[i][j]++;        ll allok=0;        for(ll j=1;j&lt;=cnt;j++)            if(mo[j].ok)&#123;                if(x&gt;=mo[cnt].x&amp;&amp;x&lt;=mo[cnt].x+mo[cnt].len-1&amp;&amp;y&gt;=mo[cnt].y&amp;&amp;y&lt;=mo[cnt].y+mo[cnt].len-1) mo[j].ok=0;                else allok=1;            &#125;        if(allok) printf(&quot;%d\n&quot;,nowans);        else pre(),printf(&quot;%d\n&quot;,nowans);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>巨模拟2048</title>
      <link href="/2025/03/14/%E5%B7%A8%E6%A8%A1%E6%8B%9F2048/"/>
      <url>/2025/03/14/%E5%B7%A8%E6%A8%A1%E6%8B%9F2048/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-14 18:56</p><p>真是巨模拟</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191014185641525-651397431.png"></p><h2 id="打模拟不要复制粘贴-模拟考验的是细节"><a href="#打模拟不要复制粘贴-模拟考验的是细节" class="headerlink" title="打模拟不要复制粘贴,模拟考验的是细节"></a>打模拟不要复制粘贴,模拟考验的是细节</h2><h2 id="模拟容不得半点偷懒"><a href="#模拟容不得半点偷懒" class="headerlink" title="模拟容不得半点偷懒"></a>模拟容不得半点偷懒</h2><p>我的</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll mp[10][10],sta[10],sta2[10],vis[10],lst[10][10];ll n,m,x1,x2,yy1,y2,v1,v2,d,k,v,cnt=0,top,top2,ok=0,fen=0,already=0;void print()&#123;    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=n;j++)            printf(&quot;%lld &quot;,mp[i][j]);&#125;int main()&#123;//    freopen(&quot;game_sample2.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;x1,&amp;yy1,&amp;v1,&amp;x2,&amp;y2,&amp;v2);    mp[x1][yy1]=v1;    mp[x2][y2]=v2;    for(ll q=1;q&lt;=m;q++)&#123;        ok=1;        scanf(&quot;%lld%lld%lld&quot;,&amp;d,&amp;k,&amp;v);        for(ll i=1;i&lt;=n;i++)            for(ll j=1;j&lt;=n;j++)                lst[i][j]=mp[i][j];        if(already) continue ;        if(d==0)&#123;//向上            for(ll i=1;i&lt;=n;i++)&#123;//列                memset(vis,0,sizeof(vis));                memset(sta,0,sizeof(sta));                for(ll j=1;j&lt;=n;j++)&#123;//行                    if(mp[j][i])                        sta[++top]=mp[j][i];                &#125;                for(ll j=1;j&lt;=top;j++)&#123;                    if(!vis[j]&amp;&amp;sta[j]==sta[j+1])&#123;                        sta2[++top2]=sta[j]*2;                        fen+=sta[j]*2;                        vis[j+1]=1;                    &#125;                    else if(!vis[j]) sta2[++top2]=sta[j];                &#125;                for(ll j=1;j&lt;=n;j++)                    mp[j][i]=0;                                for(ll j=1;j&lt;=top2;j++)                    mp[j][i]=sta2[j];                top2=0;top=0;            &#125;        &#125;        else if(d==1)&#123;//向下            for(ll i=1;i&lt;=n;i++)&#123;//列                memset(vis,0,sizeof(vis));                memset(sta,0,sizeof(sta));                for(ll j=n;j&gt;=1;j--)&#123;//行                    if(mp[j][i])                        sta[++top]=mp[j][i];                &#125;                for(ll j=1;j&lt;=top;j++)&#123;                    if(!vis[j]&amp;&amp;sta[j]==sta[j+1])&#123;                        sta2[++top2]=sta[j]*2;                        fen+=sta[j]*2;                        vis[j+1]=1;                    &#125;                    else if(!vis[j]) sta2[++top2]=sta[j];                &#125;                for(ll j=1;j&lt;=n;j++)                    mp[j][i]=0;                                for(ll j=1;j&lt;=top2;j++)                    mp[n-j+1][i]=sta2[j];//                print();//                printf(&quot;**i=%lld top2=%lld top=%lld\n&quot;,i,top2,top);                top=0;top2=0;            &#125;        &#125;        else if(d==2)&#123;//向左            for(ll i=1;i&lt;=n;i++)&#123;//行                memset(vis,0,sizeof(vis));                memset(sta,0,sizeof(sta));                for(ll j=1;j&lt;=n;j++)&#123;//列                    if(mp[i][j])                        sta[++top]=mp[i][j];                &#125;                for(ll j=1;j&lt;=top;j++)&#123;                    if(!vis[j]&amp;&amp;sta[j]==sta[j+1])&#123;                        sta2[++top2]=sta[j]*2;                        fen+=sta[j]*2;                        vis[j+1]=1;                    &#125;                    else if(!vis[j]) sta2[++top2]=sta[j];                &#125;                for(ll j=1;j&lt;=n;j++)                    mp[i][j]=0;                                for(ll j=1;j&lt;=top2;j++)                    mp[i][j]=sta2[j];//                print();//                printf(&quot;**i=%lld top2=%lld top=%lld\n&quot;,i,top2,top);                top=0;top2=0;            &#125;        &#125;        else if(d==3)&#123;//向右            for(ll i=1;i&lt;=n;i++)&#123;//行                memset(vis,0,sizeof(vis));                memset(sta,0,sizeof(sta));                for(ll j=n;j&gt;=1;j--)&#123;                    if(mp[i][j])                        sta[++top]=mp[i][j];                &#125;                for(ll j=1;j&lt;=top;j++)&#123;                    if(!vis[j]&amp;&amp;sta[j]==sta[j+1])&#123;                        sta2[++top2]=sta[j]*2;                        fen+=sta[j]*2;                        vis[j+1]=1;                    &#125;                    else if(!vis[j]) sta2[++top2]=sta[j];                &#125;                for(ll j=1;j&lt;=n;j++)                    mp[i][j]=0;                for(ll j=1;j&lt;=top2;j++)                    mp[i][n-j+1]=sta2[j];                top2=0;top=0;            &#125;        &#125;        //        printf(&quot;q=%lld\n&quot;,q);//        print();        for(ll i=1;i&lt;=n;i++)            for(ll j=1;j&lt;=n;j++)&#123;                if(mp[i][j]!=lst[i][j])&#123;                    ok=0;                &#125;            &#125;//        print();        ll cnt=0;        for(ll i=1;i&lt;=n;i++)&#123;            for(ll j=1;j&lt;=n;j++)&#123;                if(!mp[i][j])&#123;                    cnt++;                &#125;            &#125;        &#125;if(cnt)&#123;            k%=cnt;            k++;        &#125;        else k=1;        cnt=0;        for(ll i=1;i&lt;=n;i++)&#123;            for(ll j=1;j&lt;=n;j++)&#123;                if(!mp[i][j])&#123;                    cnt++;                    if(cnt==k) &#123;                        mp[i][j]=v;                        goto E;                    &#125;                &#125;            &#125;        &#125;        E:;//        print();        if(ok==1)&#123;            already=q;        &#125;    &#125;    if(already==0)&#123;        printf(&quot;%lld\n%lld\n&quot;,m,fen);    &#125;    else    printf(&quot;%lld\n%lld\n&quot;,already-1,fen);&#125;</code></pre><p>View Code</p><p>lsc的2048[专业版]</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define re registerinline int read()&#123;    int x=0,f=1;char cc=getchar();    while(cc&gt;&#39;9&#39;||cc&lt;&#39;0&#39;)&#123;if(cc==&#39;-&#39;)f=-1;cc=getchar();&#125;    while(cc&gt;=&#39;0&#39;&amp;&amp;cc&lt;=&#39;9&#39;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+cc-&#39;0&#39;;cc=getchar();&#125;    return x*f;&#125;int n,m;int mp[520][520];int las[520][520];bool vis[520][520];int ans=0;bool jud=0;inline bool judge()&#123;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            if(mp[i][j]!=las[i][j])return 0;        &#125;    &#125;    return 1;&#125;inline void debug()//记得删！&#123;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            printf(&quot;%lld &quot;,mp[i][j]);        &#125;        puts(&quot;&quot;);    &#125;    puts(&quot;&quot;);    return ;&#125;inline void get(int dir)&#123;    //0/1/2/3分别代表上下左右！    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            las[i][j]=mp[i][j];        &#125;    &#125;    if(dir==0)    &#123;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                   if(!mp[i][j])continue;                int cp=i-1;                while(!mp[cp-1][j]&amp;&amp;cp-1&gt;=1)cp--;                if(mp[cp][j])cp++;                cp=max(cp,1ll);                //printf(&quot;up %d %d %d %d\n&quot;,i,j,cp,j);                if(mp[cp-1][j]&amp;&amp;mp[cp-1][j]==mp[i][j]&amp;&amp;!vis[cp-1][j])                &#123;                       mp[cp-1][j]*=2;ans+=mp[cp-1][j];vis[cp-1][j]=1;                    mp[cp][j]=mp[i][j]=0;                &#125;                else                &#123;                    int pc=mp[i][j];mp[i][j]=0;mp[cp][j]=pc;                &#125;                            &#125;        &#125;    &#125;    else if(dir==1)    &#123;        for(int i=n;i&gt;=1;i--)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                if(!mp[i][j])continue;                int cp=i+1;                while(!mp[cp+1][j]&amp;&amp;cp+1&lt;=n)cp++;                if(mp[cp][j])cp--;                cp=min(cp,n);                //printf(&quot;down %d %d %d %d\n&quot;,i,j,cp,j);                if(mp[cp+1][j]&amp;&amp;mp[cp+1][j]==mp[i][j]&amp;&amp;!vis[cp+1][j])                &#123;                    //printf(&quot;*2maker_it!\n&quot;);                    mp[cp+1][j]*=2;ans+=mp[cp+1][j];vis[cp+1][j]=1;                    mp[i][j]=mp[cp][j]=0;                &#125;                else                &#123;                    //printf(&quot;putong maker_it\n&quot;);                    int pc=mp[i][j];mp[i][j]=0;mp[cp][j]=pc;                &#125;            &#125;        &#125;    &#125;    else if(dir==2)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            for(int i=1;i&lt;=n;i++)            &#123;                if(!mp[i][j])continue;                int cp=j-1;                while(!mp[i][cp-1]&amp;&amp;cp-1&gt;=1)cp--;                if(mp[i][cp])cp++;                cp=max(cp,1ll);                //printf(&quot;left %d %d %d %d \n&quot;,i,j,i,cp);                if(mp[i][cp-1]&amp;&amp;mp[i][cp-1]==mp[i][j]&amp;&amp;!vis[i][cp-1])                &#123;                    //printf(&quot;type1 out!\n&quot;);                    mp[i][cp-1]*=2;ans+=mp[i][cp-1];vis[i][cp-1]=1;                    mp[i][j]=mp[i][cp]=0;                &#125;                else                &#123;                    //printf(&quot;type2 out!\n&quot;);                    int pc=mp[i][j];                    mp[i][j]=0;mp[i][cp]=pc;                &#125;            &#125;        &#125;    &#125;    else if(dir==3)    &#123;        for(int j=n;j&gt;=1;j--)        &#123;            for(int i=1;i&lt;=n;i++)            &#123;                if(!mp[i][j])continue;                int cp=j+1;                while(!mp[i][cp+1]&amp;&amp;cp+1&lt;=n)cp++;                if(mp[i][cp])cp--;                cp=min(cp,n);                //printf(&quot;right %d %d %d %d \n&quot;,i,j,i,cp);                if(mp[i][cp+1]&amp;&amp;mp[i][cp+1]==mp[i][j]&amp;&amp;!vis[i][cp+1])                &#123;                    mp[i][cp+1]*=2;ans+=mp[i][cp+1];vis[i][cp+1]=1;                    mp[i][j]=mp[i][cp]=0;                &#125;                else                &#123;                    int pc=mp[i][j];mp[i][j]=0;mp[i][cp]=pc;                &#125;            &#125;        &#125;    &#125;    //debug();//    return ;&#125;inline void make(int pos,int vall)&#123;    int ress=0;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            if(!mp[i][j])ress++;        &#125;    &#125;    int poss=1+pos%ress;    //printf(&quot;%d %d\n&quot;,ress,poss);    ress=0;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            if(!mp[i][j])ress++;            if(ress==poss)            &#123;                mp[i][j]=vall;                //printf(&quot;make :  %d %d \n&quot;,i,j);                return ;            &#125;        &#125;    &#125;    return ;&#125;signed main()&#123;    //freopen(&quot;game_sample2.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;cnm1.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;me1.out&quot;,&quot;w&quot;,stdout);    int cpp=0;    n=read(),m=read();    int xx,yy,vv;    xx=rand()%n+1,yy=rand()%n+1,vv=2;mp[xx][yy]=vv;    xx=rand()%n+1,yy=rand()%n+1,vv=2;mp[xx][yy]=vv;    //debug();//    //0/1/2/3分别代表上下左右！    int dir,pos,val;    char s;    while(1)    &#123;        cin&gt;&gt;s;        if(s==&#39;w&#39;)dir=0;        if(s==&#39;s&#39;)dir=1;        if(s==&#39;a&#39;)dir=2;        if(s==&#39;d&#39;)dir=3;        pos=rand()%100,val=2;        //printf(&quot;%d\n&quot;,dir);        get(dir);        //printf(&quot;judement %d\n&quot;,judge());        if(judge())&#123;puts(&quot;YOU HAVE DIED!&quot;);break;&#125;        cpp++;        make(pos,val);        debug();        printf(&quot;%lld\n&quot;,ans);    &#125;    printf(&quot;%d\n%d\n&quot;,cpp,ans);    return 0;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵快速幂总结</title>
      <link href="/2025/03/14/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%BB%E7%BB%93/"/>
      <url>/2025/03/14/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-23 19:12</p><p>update觉得自己之前写的跟..一样，重写了</p><p>依然主要还是自用</p><p>首先矩阵一条性质的概述和证明</p><p>概述:对于一个临接矩阵$G$来说，它自乘$G^k$次方中$G[i][j]$含义为从i走到j走k步方案数.</p><p>证明:比较麻烦,我们设f[i]表示从1走到其他点方案数,那么根据矩阵递推优化,k次就是转移了k次,那么每次走一步,k次就是走了k步</p><p>最好手模一下,然后自己随便写一个数据验证一下.</p><p>然后矩阵可以优化递推,比如优化菲波纳契数列的递推,暴力递推时间复杂度是$O(n)$的用矩阵快速幂能优化成$8*log(n)$的</p><p>具体优化步骤,</p><p>首先把之前各项写出来,</p><p>先写出这一项可以由什么转移过来,</p><p>通过添加系数的方法把各项算出来</p><p>就拿菲波纳契数列为例</p><p>首先假设f矩阵为</p><p>$(f[n], f[n-1])$</p><p>根据横乘竖的原则</p><p>得出$(f[n],f[n-1])$&#x3D;$(f[n-1],f[n-2])\times$$\left(\begin{array}{cc}1&amp;1\\1&amp;0\end{array}\right)$</p><p>那么关于矩阵快速幂优化一些套路  </p><p>1.ans矩阵对角线初始化为1</p><p>这是相当于快速幂中ans初始化为1的操作(对角线为1是单位矩阵,乘一个矩阵后变为乘的那个矩阵 1*5&#x3D;5)</p><p>2.处理出第一次方案,然后递推m–次</p><p>这样我们算出第一次方案,然后递推m-1次可得到最终系数矩阵</p><p>3.最后还要算一次,从第一次转移到最后一次出答案</p><p>我们算出往往是系数矩阵,系数矩阵递推了m-1次我们让第一次*当前转移m-1次系数矩阵就是最终结果</p><p>我们这里考虑的都是系数矩阵</p><p>还是觉得自己写的很…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态点分治总结</title>
      <link href="/2025/03/14/%E9%9D%99%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2025/03/14/%E9%9D%99%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-26 17:07</p><p>点分治是世界上最好的算法QwQ</p><p>点分治可以解决各种树上的边权点权问题，然后如果你发现这个题好像问的特别玄学，lca，树差都做不了，树上动‘龟’更做不了，只能暴力时，这个题大多数情况就是点分治了</p><p>点分治的思路，考虑指定p为根，对于p而言，树上路径分为两类，过p的路径，子树内的路径，显然对于子树内的路径，只要让他继续递归下去就行了，然后我们现在要算的就是经过p的路径</p><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>一，求出来重心</p><p>二，从重心开始跑dfs维护出这一段权值（路径长度等）</p><p>三，运行calc计算对ans贡献</p><p>四，从子树运行一–三</p><p>点分治时间复杂度nlogn，证明被咕了</p><p>为什么非得是重心，首先复杂度与最大的子树有关，如果是直接往下搜y时，遇到一个链会退化成$n^2 log<br>n$，若从重心开始搜，保证了子树小于$\frac{n}{2}$</p><p>运行点分治大约有两种思路第一种是暴力计算然后容斥（为什么容斥被咕了），第二种是类似树形背包转移，再加上各种数据结构维护</p><p>两种都比较常用容斥特别好打，背包适用广</p><p>我们拿几个例题看看点分治的思路</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="聪聪可可"><a href="#聪聪可可" class="headerlink" title="聪聪可可"></a>聪聪可可</h4><p>一颗n(n&lt;&#x3D;20000)个点的树上,求长度是3的倍数的路径条数。</p><p>思路清真，我们统计出来各个子树内路径，最后让他们合并（长度余2与长度余1合并，长度余3于长度余3合并）最终就得到了解，我们维护出每一段路径的余数</p><p>类似于</p><pre><code>void getdeep(ll x,ll fa)&#123;    tt[deep[x]%3]++;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        deep[y]=deep[x]+edge[i];        getdeep(y,x);    &#125;&#125;ll calc(ll x,ll val)&#123;    deep[x]=val;    for(ll i=0;i&lt;=2;i++)        tt[i]=0;    getdeep(x,0);    return tt[1]*tt[2]*2+tt[0]*tt[0];&#125; </code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define Inf 1008611555ll#define A 1000000ll head[A],nxt[A],ver[A],edge[A],sz[A],vis[A],tt[A],deep[A];ll size,toot,n,m,mx,ans,tot;void add(ll x,ll y,ll z)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y,edge[tot]=z;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;void gettoot(ll x,ll fa)&#123;    sz[x]=1;ll num=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        gettoot(y,x);        sz[x]+=sz[y];        num=max(num,sz[y]);    &#125;    num=max(num,size-sz[x]);    if(num&lt;mx) mx=num,toot=x;&#125;void getdeep(ll x,ll fa)&#123;    tt[deep[x]%3]++;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        deep[y]=deep[x]+edge[i];        getdeep(y,x);    &#125;&#125;ll calc(ll x,ll val)&#123;    deep[x]=val;    for(ll i=0;i&lt;=2;i++)        tt[i]=0;    getdeep(x,0);    return tt[1]*tt[2]*2+tt[0]*tt[0];&#125;ll solve(ll x)&#123;    ans+=calc(x,0);//    printf(&quot;x=%lld t1=%lld t2=%lld t0=%lld ans=%lld\n&quot;,x,tt[1],tt[2],tt[0],ans);    vis[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        ans-=calc(y,edge[i]);//        printf(&quot;ans=%lld\n&quot;,ans);        size=sz[y];        mx=Inf;        gettoot(y,0);        solve(toot);    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;n;i++)&#123;        ll x,y,z;        scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);        add(x,y,z);add(y,x,z);    &#125;    mx=Inf;    size=n;    gettoot(1,0);    solve(toot);    ll g=gcd(ans,n*n);    printf(&quot;%lld/%lld\n&quot;,ans/g,n*n/g);&#125;</code></pre><p>View Code</p><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K</p><p>思路清真，我们统计出来子树之间距离然后统计一波排序一波，点对一波就好了</p><p>类似于</p><pre><code>void getdis(ll x,ll fa)&#123;    q[++r]=d[x];    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa||vis[y]) continue;        d[y]=d[x]+edge[i];        getdis(y,x);    &#125;&#125;ll calc(ll x,ll val)&#123;    r=0;d[x]=val;    getdis(x,0);    ll sum=0;l=1;    sort(q+1,q+r+1);    while(l&lt;r)&#123;        if(q[l]+q[r]&lt;=k) sum+=r-l,++l;        else --r;    &#125;    return sum;  &#125;  </code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1100000#define Inf 1000000000llusing namespace std;ll head[A],nxt[A],ver[A],sz[A],q[A],d[A],sum[A],edge[A];ll size,toot,mx,n,m,tot=0,ans,k,l,r;bool vis[A];void add(ll x,ll y,ll z)&#123;    ver[++tot]=y,nxt[tot]=head[x],head[x]=tot,edge[tot]=z;&#125;void gettoot(ll x,ll fa)&#123;    sz[x]=1;ll num=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa||vis[y]) continue;        gettoot(y,x);        sz[x]+=sz[y];        num=max(num,sz[y]);    &#125;    num=max(size-sz[x],num);    if(num&lt;mx) mx=num,toot=x;&#125;void getdis(ll x,ll fa)&#123;    q[++r]=d[x];//    printf(&quot;   x=%lld r=%lld\n&quot;,x,r);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa||vis[y]) continue;        d[y]=d[x]+edge[i];        getdis(y,x);    &#125;&#125;ll calc(ll x,ll val)&#123;    r=0;d[x]=val;    getdis(x,0);    ll sum=0;l=1;//    printf(&quot;r=%lld l=%lld\n&quot;,l,r);    sort(q+1,q+r+1);    while(l&lt;r)&#123;        if(q[l]+q[r]&lt;=k) sum+=r-l,++l;        else --r;    &#125;    return sum;&#125;ll solve(ll x)&#123;    ans+=calc(x,0);    vis[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        ans-=calc(y,edge[i]);        size=sz[y];        mx=Inf;        gettoot(y,0);        solve(toot);    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;n;i++)&#123;        ll x,y,z;        scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);        add(x,y,z);add(y,x,z);    &#125;    scanf(&quot;%lld&quot;,&amp;k);    size=n;    mx=Inf;    gettoot(1,0);    solve(toot);    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><p>View Code</p><h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><p>路径和为k且路径的边数最少</p><p>我们开一个桶，维护出路径和为k时边数最小值，记得清零</p><p>类似这样</p><pre><code>void getdiss(ll x,ll fa,ll dp)&#123;    if(deep[x]&lt;=k)        ans=min(ans,dp+cnt[k-deep[x]]);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        deep[y]=deep[x]+edge[i];        getdiss(y,x,dp+1);    &#125;&#125;void uptoday(ll x,ll fa,ll dp,ll ooo)&#123;    if(deep[x]&lt;=k)    ooo?(cnt[deep[x]]=min(cnt[deep[x]],dp)):cnt[deep[x]]=n;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        uptoday(y,x,dp+1,ooo);    &#125;&#125;void solve(ll x)&#123;    vis[x]=1;cnt[0]=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        deep[y]=edge[i];        getdiss(y,0,1);        uptoday(y,0,1,1);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(!vis[y])            uptoday(y,0,1,0);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        mx=Inf;        size=sz[y];        gettoot(y,0);        solve(toot);    &#125;&#125;</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define Inf 1e9#define A 6100000ll t[A+10],sz[A],nxt[A],head[A],ver[A],edge[A],cnt[A],deep[A];ll mx,size,num,k,toot,ans=0,n,tot=0;bool vis[A];void add(ll x,ll y,ll z)&#123;    ver[++tot]=y,nxt[tot]=head[x],head[x]=tot,edge[tot]=z;&#125;void gettoot(ll x,ll fa)&#123;    sz[x]=1;ll num=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        gettoot(y,x);        sz[x]+=sz[y];        num=max(num,sz[y]);    &#125;    num=max(num,size-sz[x]);    if(num&lt;mx) mx=num,toot=x;&#125;void getdiss(ll x,ll fa,ll dp)&#123;    if(deep[x]&lt;=k)        ans=min(ans,dp+cnt[k-deep[x]]);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        deep[y]=deep[x]+edge[i];        getdiss(y,x,dp+1);    &#125;&#125;void uptoday(ll x,ll fa,ll dp,ll ooo)&#123;    if(deep[x]&lt;=k)    ooo?(cnt[deep[x]]=min(cnt[deep[x]],dp)):cnt[deep[x]]=n;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]||y==fa) continue;        uptoday(y,x,dp+1,ooo);    &#125;&#125;void solve(ll x)&#123;    vis[x]=1;cnt[0]=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        deep[y]=edge[i];        getdiss(y,0,1);        uptoday(y,0,1,1);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(!vis[y])            uptoday(y,0,1,0);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        mx=Inf;        size=sz[y];        gettoot(y,0);        solve(toot);    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    ans=n;    ll x,y,z;    for(ll i=1;i&lt;=n-1;i++)&#123;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;x++,y++;        add(x,y,z);add(y,x,z);    &#125;    mx=Inf;size=n;    for(ll i=1;i&lt;=k;i++) cnt[i]=n;    gettoot(1,0);    solve(toot);    if(ans==n)        puts(&quot;-1&quot;);    else         printf(&quot;%d\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>常见题目</p><p>路径和等于或小于等于k的点对（路径条数）。例如tree</p><p>路径和为某个数的倍数。没遇到过，但也应该类似于聪聪可可</p><p>路径和为k且路径的边数最少。例如race，我们只要开一个桶记录一下路径为k时最小路径</p><p>路径和mod M后为某个值。例如聪聪可可</p><p>路径上经过不允许点的个数不超过某个值，且路径和最大。例如免费旅行</p><p>大多数题开一个桶i，表示距离为i的相关信息，有时我们也可以用一些高级数据结构（例如树状数组）进行一波维护。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单的期望「状压dp」</title>
      <link href="/2025/03/14/%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%9F%E6%9C%9B%E3%80%8C%E7%8A%B6%E5%8E%8Bdp%E3%80%8D/"/>
      <url>/2025/03/14/%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%9F%E6%9C%9B%E3%80%8C%E7%8A%B6%E5%8E%8Bdp%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-22 15:07</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191022145821788-394044449.png"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>dp定义真的神,</p><p>直接的想法是$f[x][maxn]$为第$x$个操作,状态$maxn$,$maxn$1&lt;&lt;200,好像没有暴力分高</p><p>实际上我们可以这样定义$f[x][maxn][len][0&#x2F;1]$表示后八位$maxn$,第九位0\1,第九位之后连续长度为$j$概率</p><p>为什么这样定义</p><p>实际上质因数分解后2的次数就是后面0的个数</p><p>+1会破坏已有的0,操作数最多只有200个全部+1后八位已经足够</p><p>最多只会影响到后九位一次</p><p>考虑一种极限情况</p><p>111111111111111</p><p>现在在最后一位加一会进位</p><p>1000000000000000,再怎么+1都不会再影响到九位之后了</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191022150837447-1113195064.png"></p><p>转移比较简单具体看代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 #define ll long long 4 ll x,n,m,xx,opt,maxn,cnt; 5 double p,ans=0; 6 double f[210][288][310][2]; 7 ll cal(ll now)&#123; 8     ll cnt=0; 9     while(now%2==0) cnt++,now/=2;10     return cnt;11 &#125;12 int main()&#123;13 //    freopen(&quot;cnm.xlsx&quot;,&quot;w&quot;,stdout);14     scanf(&quot;%lld%lld%lf&quot;,&amp;x,&amp;n,&amp;p);15     p/=100;16     xx=x;17     xx&gt;&gt;=8;18     opt=xx&amp;1;19     maxn=(1&lt;&lt;8)-1;20     for(;xx&amp;&amp;((xx&amp;1)==opt);xx&gt;&gt;=1)21         cnt++;22     if(cnt==0) cnt++;//23     m=cnt+n;24     f[0][x&amp;maxn][cnt][opt]=1;25 //    printf(&quot;%lld\n&quot;,m);26     for(ll i=1;i&lt;=n;i++)27         for(ll pre=0;pre&lt;=maxn;pre++)28             for(ll j=1;j&lt;=m;j++)29                 for(ll t=0;t&lt;=1;t++)30                 if(f[i-1][pre][j][t])&#123;        31                     ll now,tt,jj;32                     now=pre+1;33                     if(now==(1&lt;&lt;8))&#123;34                         now=0;tt=t^1;35                         if(t==1) jj=j;36                         else jj=1;37                     &#125;38                     else jj=j,tt=t;39                     f[i][now][jj][tt]+=f[i-1][pre][j][t]*(1-p);40                     now=pre&lt;&lt;1;41                     if(((now&gt;&gt;8)&amp;1)==t) tt=t,jj=j+1;    42                     else tt=t^1,jj=1;43                     now=now&amp;maxn;44                     f[i][now][jj][tt]+=f[i-1][pre][j][t]*p;45                 &#125;46     for(ll now=1;now&lt;=maxn;now++)//47         for(ll j=1;j&lt;=m;j++)48             for(ll t=0;t&lt;=1;t++)49                 if(f[n][now][j][t])50                 ans+=f[n][now][j][t]*cal(now);51                 //,printf(&quot;f[%lld][%lld][%lld][%lld]=%lf\n&quot;,n,now,j,t,f[n][now][j][t]);52 //    printf(&quot;%.13lf\n&quot;,ans);53     for(ll j=1;j&lt;=m;j++)&#123;54         ans+=f[n][0][j][0]*(j+8)+f[n][0][j][1]*8;55 //        printf(&quot;f[%lld][0][%lld][0]=%lf f[%lld][0][%lld][1]=%lf\n&quot;,n,j,f[n][0][j][0],n,j,f[n][0][j][1]);56     &#125;57     printf(&quot;%.13lf\n&quot;,ans);58 &#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次爬虫</title>
      <link href="/2025/03/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB/"/>
      <url>/2025/03/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<p>归档于  2023-05-27 22:39</p><p>先感谢403F的帮助</p><p>要爬的是<a href="https://soutubot.moe/">https://soutubot.moe/</a></p><p>然后就遇到了问题</p><p>贯穿始终的是401未授权访问，但是请求包里不包含token一类的，cookie也放了，将整个导入到postman里面<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527213736068-1472464113.png" alt="image"><br>发现能够请求成功，然后只有请求头可能出问题，那就是请求头的问题</p><p>请求头一个一个去掉直到不能访问，比较重要的一项是x-api-key，网站用了自己自定义的生成的x-api-key，保证安全性，x-api-<br>key看起来是随机生成的base64，然后过期时间特别短，看看，即使你放置了x-api-key在请求头里，也会很快过期</p><p>然后<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527213930716-2060886057.png" alt="image"><br>在URL contains 里面过滤包含search请求的</p><p>断点卡到search这一步<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527214229584-835979519.png" alt="image"></p><p>跳步运行几步</p><p>运行完e.apply后这个函数运行结束，所以我们试试在这个函数刚开始的时候设置断点<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527214419187-1280164423.png" alt="image"></p><p>我们尝试在这个函数最上方设置断点</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527214458109-1331425422.png" alt="image"></p><p>发现了我们要找的x-api-key，在这里已经被赋值</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527214552380-677785186.png" alt="image"></p><p>接下来的</p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="“从下往上逆着找调用链”，找到谁调用的这个函数"><a href="#“从下往上逆着找调用链”，找到谁调用的这个函数" class="headerlink" title="“从下往上逆着找调用链”，找到谁调用的这个函数"></a>“从下往上逆着找调用链”，找到谁调用的这个函数</h2><p>找到callback调用链，主要要找到哪里调用了这个，找到了Oi</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527225031480-1302422755.png" alt="image"></p><p>往上追，M也被赋值了</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527225229939-1359137813.png" alt="image"></p><p>右面有明显特征的就是search了，在search里面找个断点</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527231332175-1717481427.png" alt="image"></p><p>步入，发现进入os<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527231907676-1019895029.png" alt="image"></p><p>之后会进入这里，发现M即是上文的e，这时候还没有赋值<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527232028389-1872972189.png" alt="image"></p><p>再步入直接赋上值了，基本锁定了RC是赋值函数<br><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527231805015-2061793722.png" alt="image"></p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527232140041-198636802.png" alt="image"></p><p>有个看起来很不错的字符串<br>单步运行到有个看起来很不错的字符串</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527223327003-1968098605.png" alt="image"></p><p>花絮</p><p>V0MxaFVHa3RTMFY1<br>很酷</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527223437795-1532728653.png" alt="image"></p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527223451093-811873340.png" alt="image"></p><p>然后就是X-api-KEy了<br>看看怎么实现</p><pre><code>    const RC = ()=&gt;&#123;        Q.tz.setDefault(&quot;Asia/Shanghai&quot;);        const e = (Math.pow(Q().unix(), 2) + Math.pow(window.navigator.userAgent.length, 2)).toString();        return En.encode(e).split(&quot;&quot;).reverse().join(&quot;&quot;).replace(/=/g, &quot;&quot;)    &#125;</code></pre><p>当前时间平方，+userAgent长度平方求base64，base64取反去掉等号，生成出来的x-api-key</p><p>因此爬虫只需要现算然后求值就可以了，</p><p>封装了一个api在github上</p><h1 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h1><h2 id="“从上到下”，找到调用该函数之前的一个函数，单步调试直到调用该函数"><a href="#“从上到下”，找到调用该函数之前的一个函数，单步调试直到调用该函数" class="headerlink" title="“从上到下”，找到调用该函数之前的一个函数，单步调试直到调用该函数"></a>“从上到下”，找到调用该函数之前的一个函数，单步调试直到调用该函数</h2><p>找看起来可能有意义的函数</p><p><img src="https://img2023.cnblogs.com/blog/1708132/202305/1708132-20230527222958742-1823473916.png" alt="image"></p><p>往下调用到RC，然后和后面一样了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记录几次git相关操作</title>
      <link href="/2025/03/14/%E8%AE%B0%E5%BD%95%E5%87%A0%E6%AC%A1git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/14/%E8%AE%B0%E5%BD%95%E5%87%A0%E6%AC%A1git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>归档于  2022-09-21 21:08</p><h2 id="1-无法忽略部分文件"><a href="#1-无法忽略部分文件" class="headerlink" title="1.无法忽略部分文件"></a>1.无法忽略部分文件</h2><p>git rm -r –cached .<br>解释：-r递归删除所有文件的索引，删除到add .之前的状态<br>这时候再add和commit就忽略到那部分文件了</p><h2 id="2-无法pull"><a href="#2-无法pull" class="headerlink" title="2.无法pull"></a>2.无法pull</h2><p><img src="https://img2022.cnblogs.com/blog/1708132/202209/1708132-20220921210302877-791398209.png" alt="image"></p><p>因为本地pyc二进制文件发生修改，没有提交到本地仓库，所以不能pull</p><h2 id="3-本地仓库发生修改，远程仓库发生不一样修改，无法push，提示本地版本落后"><a href="#3-本地仓库发生修改，远程仓库发生不一样修改，无法push，提示本地版本落后" class="headerlink" title="3.本地仓库发生修改，远程仓库发生不一样修改，无法push，提示本地版本落后"></a>3.本地仓库发生修改，远程仓库发生不一样修改，无法push，提示本地版本落后</h2><p><img src="https://img2022.cnblogs.com/blog/1708132/202209/1708132-20220921210449707-317012162.png" alt="image"></p><p>git stash 存下本地仓库</p><p>如果无法stash 那是本地已经commit提交到本地仓库。stash只能存add之后的<br>学长给出的建议是切换到新分支，然后git fetch，然后git reset -f git rebase<br>rebase出了点问题<br>我直接fetch 然后merge 之后删掉分支（我菜爆了</p><p>git pull 拉下远程仓库<br>git pop 放出本地仓库<br>然后vscode修改抉择哪些要改</p><h2 id="4-无法连接，在挂了梯子的情况下-或提示OpenSSL-SSL-connect-Connection-was-reset-in-connection"><a href="#4-无法连接，在挂了梯子的情况下-或提示OpenSSL-SSL-connect-Connection-was-reset-in-connection" class="headerlink" title="4.无法连接，在挂了梯子的情况下 或提示OpenSSL SSL_connect: Connection was reset in connection"></a>4.无法连接，在挂了梯子的情况下 或提示OpenSSL SSL_connect: Connection was reset in connection</h2><p>to github.com:443</p><p>需要设置git的代理</p><p><a href="https://zhuanlan.zhihu.com/p/481574024#:~:text=Git%E4%BB%A3%E7%90%86%E6%9C%89%E4%B8%A4%E7%A7%8D%E8%AE%BE%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%AA%E5%AF%B9Github%E4%BB%A3%E7%90%86%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%8F%AA%E5%AF%B9github%20%E4%BB%A3%E7%90%86%E3%80%82,%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E4%B9%9F%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86%E3%80%82%20%E6%B3%A8%E6%84%8F%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%90%86%E7%AB%AF%E5%8F%A3%E8%AE%BE%E5%AE%9A%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E7%9A%84%E4%BB%A3%E7%90%86socks%E7%AB%AF%E5%8F%A3%E6%98%AF51837%E3%80%82" title="连接">连接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记录</title>
      <link href="/2025/03/14/%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/03/14/%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>归档于  2021-12-20 18:55</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>西工大长安校区大一学生(2021)，长安校区呆到大二，大三就要去太仓校区了<br>持续更新ing，后续会把图片补上<br>内含非常主观评价，直球拉踩。各个菜品会按照个人喜好推荐。</p><p>update 2022&#x2F;4&#x2F;2<br>以后更新会加上短评（虽然理工词穷</p><p>update 2022&#x2F;8&#x2F;17<br>实在没什么写的，所以添点学校周围的小饭馆</p><h2 id="长安校区"><a href="#长安校区" class="headerlink" title="长安校区"></a>长安校区</h2><h3 id="星天苑北餐厅"><a href="#星天苑北餐厅" class="headerlink" title="星天苑北餐厅"></a>星天苑北餐厅</h3><p><del>说是最难吃餐厅也不为过，整个餐厅一楼只推荐烤盘饭，二楼陕西窗口还行，另外民族餐厅还行。</del><br>但是三楼有瑞幸咖啡，每次压力大了去那里喝一杯感觉还不错哈哈哈哈</p><p>我现在感觉星北其实也还行，其实有很多还不错的东西的</p><h4 id="星北一楼"><a href="#星北一楼" class="headerlink" title="星北一楼"></a>星北一楼</h4><h5 id="喵大叔状元鱼"><a href="#喵大叔状元鱼" class="headerlink" title="喵大叔状元鱼"></a>喵大叔状元鱼</h5><p>很一般。味道很一般很一般。不推荐，我个人的话，更喜欢鲜鱼，这种炸鱼不太喜欢。<br>算比较贵了<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111211216206-1747331127.jpg" alt="image"></p><h4 id="星北二楼"><a href="#星北二楼" class="headerlink" title="星北二楼"></a>星北二楼</h4><h5 id="藤椒鸡"><a href="#藤椒鸡" class="headerlink" title="藤椒鸡"></a>藤椒鸡</h5><p>推荐。其实还不错，算星北里好的了<br>甜咸对于我来说比较合适，味道也还不错，有点干<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111203252475-96601119.jpg" alt="image"></p><h5 id="陕西窗口"><a href="#陕西窗口" class="headerlink" title="陕西窗口"></a>陕西窗口</h5><p>陕西窗口是星北里最推荐的了，但是量都有点少</p><p>肉臊子面。推荐。<br>好吃。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111205813219-2133627598.jpg" alt="image"></p><p>油泼拉皮。推荐。<br>第一次吃油泼拉皮，我一开始一听名以为会有很多油，多到泡起来那种，实际只是一点油一泼就完事了，味道老实说不错。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111210027965-1779337553.jpg" alt="image"></p><h4 id="星北三楼"><a href="#星北三楼" class="headerlink" title="星北三楼"></a>星北三楼</h4><h5 id="瑞幸咖啡"><a href="#瑞幸咖啡" class="headerlink" title="瑞幸咖啡"></a>瑞幸咖啡</h5><p>推荐。大福好吃，大福好吃，咖啡也不错，虽然每月生活费支撑不了经常喝，偶尔喝一次还是不错的</p><h4 id="二楼民族餐厅"><a href="#二楼民族餐厅" class="headerlink" title="二楼民族餐厅"></a>二楼民族餐厅</h4><h5 id="水盆牛肉"><a href="#水盆牛肉" class="headerlink" title="水盆牛肉"></a>水盆牛肉</h5><p>不推荐<br>水盆牛肉那个碗飘着，飘着一大层油，然后肉比较少，对于18块钱来说实在有点少了，味道一般<br>饼也是软不唧唧还带点糊，实在不敢恭维<br><img src="https://img2020.cnblogs.com/blog/1708132/202112/1708132-20211220185208104-2075787154.jpg" alt="image"></p><blockquote><p>一家人就是要整整齐齐</p></blockquote><h3 id="星天苑南餐厅"><a href="#星天苑南餐厅" class="headerlink" title="星天苑南餐厅"></a>星天苑南餐厅</h3><p>好吃的窗口很多，好坏各占一半吧，相比其他餐厅有点贵</p><h4 id="三楼"><a href="#三楼" class="headerlink" title="三楼"></a>三楼</h4><h5 id="水煮厨房"><a href="#水煮厨房" class="headerlink" title="水煮厨房"></a>水煮厨房</h5><p>水煮肉卷。不推荐<br>不太好吃，没有期待中那种水煮肉片味道，肉卷是酸的，吃起来很没劲<br>和想象中差距有点大<br><img src="https://img2020.cnblogs.com/blog/1708132/202112/1708132-20211220185819187-1660405542.jpg" alt="image"></p><h5 id="烤鸭饭"><a href="#烤鸭饭" class="headerlink" title="烤鸭饭"></a>烤鸭饭</h5><p>味道很怪，叉烧和烤鸭饭味道都比较怪<br>烤鸭饭。不推荐。</p><p><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111210745175-1511805412.jpg" alt="image"></p><h5 id="铁板厨房"><a href="#铁板厨房" class="headerlink" title="铁板厨房"></a>铁板厨房</h5><p>推荐。<br>算比较好吃，中等偏上。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111210446512-158974078.jpg" alt="image"></p><h5 id="鸡扒饭"><a href="#鸡扒饭" class="headerlink" title="鸡扒饭"></a>鸡扒饭</h5><p>推荐。<br>很好吃，我个人很喜欢吃烤的鸡扒，不喜欢炸鸡扒。<br>现烤的，而且味道没得说，比那种从烤箱拿出来烤了半天的好多了（指云餐一楼和海餐二楼<br>甜咸合适，鸡扒烤的滋滋冒油，咬起来也非常嫩，量也比较大</p><p>缺点是餐具太丑了，而且正好有残缺还被我碰见了，不过瑕不掩瑜<br><img src="https://img2022.cnblogs.com/blog/1708132/202204/1708132-20220402231748963-1894953254.png" alt="image"></p><h5 id="豆花饭"><a href="#豆花饭" class="headerlink" title="豆花饭"></a>豆花饭</h5><p>第一次吃的时候觉得太淡，第二次吃的时候果断要了辣子，好吃很多了<br>（不过双皮奶不大行，实在不如云餐二楼的<br>牛腩豆花饭 推荐。<br>很好吃，尤其推荐试试加辣的<br><img src="https://img2022.cnblogs.com/blog/1708132/202204/1708132-20220402232149142-807839397.jpg" alt="image"></p><h4 id="二楼学子餐厅"><a href="#二楼学子餐厅" class="headerlink" title="二楼学子餐厅"></a>二楼学子餐厅</h4><p>肉夹馍<br>不推荐。虽然味道不是天花板，但价格是天花板，所有卖肉夹馍里卖的最贵的</p><h4 id="二楼普通餐厅"><a href="#二楼普通餐厅" class="headerlink" title="二楼普通餐厅"></a>二楼普通餐厅</h4><p>(只是为了和学子区别<br>不是学子餐厅的那个就是普通</p><h5 id="滑蛋饭"><a href="#滑蛋饭" class="headerlink" title="滑蛋饭"></a>滑蛋饭</h5><p><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111211108457-569192327.png" alt="image"><br>推荐。<br>很好吃。<br>（（（吃了一个月吃腻了</p><h5 id="精品锅仔烧"><a href="#精品锅仔烧" class="headerlink" title="精品锅仔烧"></a>精品锅仔烧</h5><p>辣子鸡。推荐。<br>很辣。我自己感觉味道还不错<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111203033618-1905586714.jpg" alt="image"></p><p>红烧肉。推荐。<br>我感觉是学校红烧肉天花板。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111210458968-1572990977.jpg" alt="image"></p><p>清炖排骨。推荐<br>炖的很烂，味道是相当好，汤也比较好喝，能在学校食堂吃到这，感觉是幸事<br><img src="https://img2022.cnblogs.com/blog/1708132/202204/1708132-20220402231423826-1281439489.jpg" alt="image"></p><p>青笋闷罐肉。一般-&gt;推荐。<br>有点肥，但味道还不错<br>但问题就是太肥了<br><img src="https://img2022.cnblogs.com/blog/1708132/202204/1708132-20220402233057825-2069433493.jpg" alt="image"></p><p>脆皮烤鸭。不推荐<br>泡汤里的脆皮烤鸭。。。。。。。。。。。。。。。。<br>都不脆完了。</p><h5 id="兰州拉面"><a href="#兰州拉面" class="headerlink" title="兰州拉面"></a>兰州拉面</h5><p>碎肉拌面。不推荐<br>咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸咸<br><img src="https://img2022.cnblogs.com/blog/1708132/202203/1708132-20220313173512671-1782521641.jpg" alt="image"></p><h3 id="云天苑"><a href="#云天苑" class="headerlink" title="云天苑"></a>云天苑</h3><h4 id="一楼"><a href="#一楼" class="headerlink" title="一楼"></a>一楼</h4><h5 id="F-牛肉饭"><a href="#F-牛肉饭" class="headerlink" title="F+牛肉饭"></a>F+牛肉饭</h5><p>不推荐。<br>同样都是F+牛肉饭，海天苑餐厅比云天苑的好得多。海天苑算好吃，云天苑是一般。<br>价格倒是不算高<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111201441963-1287136544.jpg" alt="image"></p><h5 id="卖奶茶和粥的地"><a href="#卖奶茶和粥的地" class="headerlink" title="卖奶茶和粥的地"></a>卖奶茶和粥的地</h5><p>饭团。推荐。<br>别的没试过，饭团还不错。（面条是别的窗口的热干面。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111201958879-508605334.jpg" alt="image"></p><h5 id="忘了叫什么了（往后会补上"><a href="#忘了叫什么了（往后会补上" class="headerlink" title="忘了叫什么了（往后会补上"></a>忘了叫什么了（往后会补上</h5><p>馄饨面，便宜量大，味道很清淡<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222033808-1430402909.jpg" alt="image"></p><h4 id="二楼民族餐厅-1"><a href="#二楼民族餐厅-1" class="headerlink" title="二楼民族餐厅"></a>二楼民族餐厅</h4><p>云餐二楼还不错吧，吃了一学期也没有很腻<br>福建窗口拌面，蒸饺，面条，笼仔饭，意大利面，各种汤（虽然福建窗口卖意大利面有点离谱<br>陕西窗口裤带面，肉夹馍，拌面（和福建窗口比又是一种特色），（但凉皮一般<br>山东窗口各种都还行<br>湖南窗口也都还行<br>江苏窗口除了木桶饭都还行<br>潮式窗口左面的鸡汤不错<br>麻辣香锅还不错</p><h5 id="陕西窗口-1"><a href="#陕西窗口-1" class="headerlink" title="陕西窗口"></a>陕西窗口</h5><p>裤带面（左面是面条，右面是佐料）推荐。<br><img src="https://img2020.cnblogs.com/blog/1708132/202112/1708132-20211220190701339-1128131925.jpg" alt="image"><br>便宜好吃，佐料2块钱，面1.5元<br>七块钱能吃饱</p><p>拌面。推荐。<br>口味比较重。但吃起来意外的不错。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111204054845-243445592.jpg" alt="image"></p><h5 id="福建窗口"><a href="#福建窗口" class="headerlink" title="福建窗口"></a>福建窗口</h5><p>拌面和各种汤。推荐。<br><img src="https://img2020.cnblogs.com/blog/1708132/202112/1708132-20211220190839252-288609830.jpg" alt="image"><br>芝麻酱拌面5块钱，味道很不错<br>此处汤应该是树菇母鸡汤，味道一般偏上7.5元</p><p>笼仔饭。推荐。<br>很油，不过偶尔吃一顿是不错的。味道什么的都挺好，缺点就是油大。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111203411519-1770364729.jpg" alt="image"></p><p>意面。推荐。<br>味道很不错。缺点是贵。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111205721926-1019459402.jpg" alt="image"></p><p>双皮奶。一般，相比旁边的奶茶店一般。</p><p><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111210536170-1791407950.png" alt="image"></p><h5 id="潮式窗口"><a href="#潮式窗口" class="headerlink" title="潮式窗口"></a>潮式窗口</h5><p>推荐<br>母鸡汤，虽然不知道是不是鸡汤，但味道还是不错的，那个饼也还不错。价格不算高。（下图包子是江苏窗口买的，中上<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111201733115-2131444041.jpg" alt="image"></p><h3 id="海天苑餐厅"><a href="#海天苑餐厅" class="headerlink" title="海天苑餐厅"></a>海天苑餐厅</h3><p>总体上好坏各半。但是装修的比其他餐厅都好（研究生餐厅和本科生餐厅的差距</p><h4 id="黄焖鸡"><a href="#黄焖鸡" class="headerlink" title="黄焖鸡"></a>黄焖鸡</h4><p>推荐。还不错，比很多街边小店做的好吃的多，有我印象中喜欢的那种黄焖鸡感觉了。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111204204900-1217801764.jpg" alt="image"></p><h4 id="新疆烤肉饭"><a href="#新疆烤肉饭" class="headerlink" title="新疆烤肉饭"></a>新疆烤肉饭</h4><p>肉末饭口感挺差的，但这里的柠檬鸡和烤肠味道都不错块也很大。<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222523072-1339851289.jpg" alt="image"></p><h4 id="三楼的番茄鱼"><a href="#三楼的番茄鱼" class="headerlink" title="三楼的番茄鱼"></a>三楼的番茄鱼</h4><p>海天苑脚底板。拉低了海天苑平均水平。<br>后续可能会补图。</p><h4 id="渝味小碟"><a href="#渝味小碟" class="headerlink" title="渝味小碟"></a>渝味小碟</h4><p>味道其实不错，明天再吃顿可能会补张图，鸡汤很好喝<br>种类很多，每天都不一样。每个月又不一样<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817221702375-1054083537.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817221817078-705364212.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222226878-49478843.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222235353-1174315502.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222314424-741955068.jpg" alt="image"></p><h4 id="陕北手工面"><a href="#陕北手工面" class="headerlink" title="陕北手工面"></a>陕北手工面</h4><p>拌面味道不错<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222413181-1304433204.jpg" alt="image"></p><h3 id="翱翔小食（校内小店"><a href="#翱翔小食（校内小店" class="headerlink" title="翱翔小食（校内小店"></a>翱翔小食（校内小店</h3><p>推荐。很多都不错。</p><h4 id="蛋炒饭"><a href="#蛋炒饭" class="headerlink" title="蛋炒饭"></a>蛋炒饭</h4><p>推荐。好！</p><h4 id="黑椒鸡扒饭"><a href="#黑椒鸡扒饭" class="headerlink" title="黑椒鸡扒饭"></a>黑椒鸡扒饭</h4><p>推荐。<br>完完全全吊打星天苑北餐厅。星北是什么臭鱼烂虾。星北的黑椒鸡扒饭吃起来想吐，是真的想吐，真的是太难吃了。星北所有种类的其实都用的一样的鸡扒，各种味道全靠最后挤一堆味道特别难吃也难闻也难看的酱。难吃的要命。<br><img src="https://img2020.cnblogs.com/blog/1708132/202201/1708132-20220111204602894-2054877160.jpg" alt="image"></p><h3 id="学校周围的小饭馆"><a href="#学校周围的小饭馆" class="headerlink" title="学校周围的小饭馆"></a>学校周围的小饭馆</h3><h4 id="花雕醉鸡"><a href="#花雕醉鸡" class="headerlink" title="花雕醉鸡"></a>花雕醉鸡</h4><p>大块的肉，吃着特别爽，味道也是相当的香，味道真的不错。<br>我能想到的缺点就是花样少，只卖花雕醉鸡，吃几次可能会腻<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817222847618-191478575.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817223055456-672623311.jpg" alt="image"></p><h4 id="八亩地biangbiang面"><a href="#八亩地biangbiang面" class="headerlink" title="八亩地biangbiang面"></a>八亩地biangbiang面</h4><p>相当大一份，味道挺不错的（就是口相对比较重），量相当大还能免费添面<br>碗比头大<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817223929711-1316659391.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817223754261-1795460888.jpg" alt="image"></p><h4 id="二朴炸鸡社"><a href="#二朴炸鸡社" class="headerlink" title="二朴炸鸡社"></a>二朴炸鸡社</h4><p>（我味觉比较迟钝）<br>（我感觉炸鸡只要不是炸焦了，就味道差不多）<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817224139222-855962227.jpg" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817224156250-1313665440.jpg" alt="image"></p><h2 id="太仓校区"><a href="#太仓校区" class="headerlink" title="太仓校区"></a>太仓校区</h2><h3 id="民族窗口"><a href="#民族窗口" class="headerlink" title="民族窗口"></a>民族窗口</h3><h4 id="牛肉刀削面"><a href="#牛肉刀削面" class="headerlink" title="牛肉刀削面"></a>牛肉刀削面</h4><p>普通的刀削面，很好吃<br><img src="https://img2022.cnblogs.com/blog/1708132/202208/1708132-20220817221912804-1476243484.jpg" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计划</title>
      <link href="/2025/03/14/%E8%AE%A1%E5%88%92/"/>
      <url>/2025/03/14/%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-17 17:30</p><p>赤</p><p>wqs二分</p><p><a href="https://www.cnblogs.com/Juve/p/11479423.html">https://www.cnblogs.com/Juve/p/11479423.html</a></p><p><a href="https://www.cnblogs.com/Rorschach-XR/p/11479602.html">https://www.cnblogs.com/Rorschach-XR/p/11479602.html</a></p><p>反悔贪心</p><p><a href="https://www.cnblogs.com/cjyyb/p/9367948.html">https://www.cnblogs.com/cjyyb/p/9367948.html</a></p><p><a href="https://www.cnblogs.com/Miracevin/p/9795871.html">https://www.cnblogs.com/Miracevin/p/9795871.html</a></p><p><a href="https://blog.csdn.net/weixin_34344677/article/details/94456977">https://blog.csdn.net/weixin_34344677/article/details/94456977</a></p><p>影魔</p><p><a href="https://www.cnblogs.com/Gkeng/p/11509140.html">https://www.cnblogs.com/Gkeng/p/11509140.html</a></p><p>树上问题</p><p><a href="https://www.cnblogs.com/Slrslr/p/9398205.html">https://www.cnblogs.com/Slrslr/p/9398205.html</a></p><p>欧拉回路好题</p><p><a href="https://blog.csdn.net/A1847225889/article/details/84624877">https://blog.csdn.net/A1847225889/article/details/84624877</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>换根dp「小奇的仓库·randomwalking·」</title>
      <link href="/2025/03/14/%E6%8D%A2%E6%A0%B9dp%E3%80%8C%E5%B0%8F%E5%A5%87%E7%9A%84%E4%BB%93%E5%BA%93%C2%B7randomwalking%C2%B7%E3%80%8D/"/>
      <url>/2025/03/14/%E6%8D%A2%E6%A0%B9dp%E3%80%8C%E5%B0%8F%E5%A5%87%E7%9A%84%E4%BB%93%E5%BA%93%C2%B7randomwalking%C2%B7%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-28 11:59</p><p>把以前考试换根题集中写一下</p><p>随便选一个点做根一遍$dfs$求子树内贡献,再通过特殊手段算$ans[1]$,最后$dfs$求其他$ans$</p><p>拆成子树内,子树外分别算贡献差,得儿子是很常见套路了</p><h2 id="小奇的仓库"><a href="#小奇的仓库" class="headerlink" title="小奇的仓库"></a>小奇的仓库</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190928113645414-1950224240.png"></p><p>$M&lt;&#x3D;15$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很久之前做的换根dp,当时觉得真是神仙,现在看还是觉得很神仙</p><p>不同于一般换根dp,这个题$n^2$并不好写</p><p>所以$n^2$算法就省略了</p><p>考虑$M$非常小,可以计算$M$对答案影响</p><p>一个直接的想法是先算出来原答案,再减去现在答案</p><pre><code>            //本来为j现在异或M，变化了j-delta            //你都按j算的            //本来j，现在j-1 delta=1            //所有结果减1</code></pre><p>考虑如何算出原答案,对于一个点来说很好算,我们要用一次换根算出来其他点答案</p><p>$ans[1]&#x3D;\sum\limits_{i&#x3D;2}^{n}dis[i]$</p><p>换根</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190928114621331-1162509790.png"></p><p>思考 从x转移到y,那么你子树内点贡献减少edg,子树外点贡献增加edg</p><p>那么$ans[y]&#x3D;ans[x]-sz[y]*edg+(n-sz[y])*edg$</p><p>然后考虑算delta</p><p>$f[x][i]$表示x子树内路径长mod16后为i条数</p><p>转移$f[x][i+edg]&#x3D;\sum\limits_{y}^{y\in son} f[y][i]$</p><p>$g[x][i]$表示整棵树内路径长mod16后为i条数</p><p>初始$g[1]&#x3D;f[1]$</p><p>考虑换根</p><p>分为几部分贡献,子树内,子树外</p><p>子树内很简单$g[y][i]+&#x3D;f[y][i]$</p><p>子树外$g[y][edg+j]+&#x3D;g[x][j]$即子树外距离当前为$j$的加上当前$edg$即为到当前点$edg+j$的</p><p>但这样会算重,$g[x][j]$我们把它当作子树外的了,实际它是整棵树贡献,$g$要减去子树内贡献</p><p>$-f[y][j-edg]$即可,子树内要到x距离为$j$那么到$y$距离肯定为$j-edg$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101#define mod 16ll head[A],ver[A],nxt[A],edg[A],f[A][30],g[A][30],sum[A],dis[A],sz[A],ans[A];ll tot=1,n,m,M;void add(ll x,ll y,ll z)&#123;    ver[++tot]=y,nxt[tot]=head[x],head[x]=tot,edg[tot]=z;&#125;void dfs(ll x,ll pre)&#123;    sz[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dis[y]=dis[x]+edg[i];        dfs(y,x);        sz[x]+=sz[y];    &#125;&#125;void dfs0(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        ans[y]=ans[x]-(sz[y]*edg[i])+((n-sz[y])*edg[i]);        dfs0(y,x);    &#125;&#125;void dfs1(ll x,ll pre)&#123;    f[x][0]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dfs1(y,x);        for(ll j=0;j&lt;=15;j++)            f[x][(j+edg[i])%mod]+=f[y][j];    &#125;&#125;void dfs2(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        for(ll j=0;j&lt;=15;j++)            g[y][(j+edg[i])%mod]+=f[y][(j+edg[i])%mod]+(g[x][j]-f[y][(j-edg[i]%mod+mod)%mod]);//        dfs2(y,x);    &#125;&#125;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;M);    for(ll i=1,a,b,c;i&lt;=n-1;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);add(b,a,c);    &#125;    dis[0]=0;    dfs(1,0);    for(ll i=2;i&lt;=n;i++)        ans[1]+=dis[i];    dfs0(1,0);    dfs1(1,0);    for(ll i=0;i&lt;=15;i++)        g[1][i]=f[1][i];    dfs2(1,0);    for(ll i=1;i&lt;=n;i++)&#123;        g[i][0]--;        for(ll j=0;j&lt;=15;j++)&#123;            ll delta;            delta=(j-(j^M));            //本来为j现在异或M，变化了j-delta            //你都按j算的            //本来j，现在j-1 delta=1            //所有结果减1            ans[i]-=delta*g[i][j];//            printf(&quot;g[%lld][%lld]=%lld\n&quot;,i,j,g[i][j]);        &#125;        printf(&quot;%lld\n&quot;,ans[i]);    &#125;&#125;</code></pre><p>View Code</p><h2 id="randomwalking"><a href="#randomwalking" class="headerlink" title="randomwalking"></a>randomwalking</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190928115842892-819296740.png"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$n^2$很简单,考虑换根</p><p>$f[x][0]$表示子树内走到当前期望</p><p>随便选一个做根</p><p>对于非根节点:$f[x][0]&#x3D;a[x]+\sum\limits_{y}^{y\in son[x]} \frac{1}{deg[x]-1} f[y][0]$</p><p>对于根:$f[x][0]&#x3D;a[x]+\sum\limits_{y}^{y\in son[x]} \frac{1}{deg[x]} f[y][0]$</p><p>$f[x][1]$表示整棵树走到当前期望</p><p>$f[1][1]&#x3D;f[1][0]$</p><p>考虑换根</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190928114621331-1162509790.png"></p><p>仍分为子树内子树外</p><p>子树内贡献就是$(f[y][0]-a[y])*(deg[y]-1)$</p><p>子树外看似很难求但还是可求的</p><p>看从$x$转移到$y$</p><p>$(f[x][1]-a[x])*deg$求出$y$子树和别的子树贡献</p><p>$(f[x][1]-a[x])*deg-f[y][0]$就是子树外的</p><p>还有一个注意点,本来$x$为根现在$y$为根了,$x$本来出度为$2$现在变为了$1$deg也要变化</p><p>$f[y][1]&#x3D;\frac{(\frac{((f[x][1]-a[x])<em>deg[x]-f[y][0])}{(deg[x]-1)}+a[x]+(f[y][0]-a[y])</em>(deg[y]-1))}{deg[y]}+a[y];$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2222222ll sz[A],a[A],head[A],nxt[A],ver[A];ll n,tot,id;double deg[A],f[A][2];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void dpfs(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dpfs(y,x);        if(pre==0) f[x][0]+=f[y][0]*1/(deg[x]);        else f[x][0]+=f[y][0]*1/(deg[x]-1);        &#125;    f[x][0]+=a[x];//    printf(&quot;f[%lld]=%.3lf\n&quot;,x,f[x][0]);&#125;void dpfs2(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        double tmp1=(f[x][1]-a[x])*deg[x];        double tmp2=tmp1-f[y][0];        double tmp3=(f[y][0]-a[y])*(deg[y]-1);        if(deg[x]&gt;1)            f[y][1]=(tmp2/(deg[x]-1)+a[x]+tmp3)/deg[y]+a[y];        else f[y][1]=(a[x]+tmp3)/deg[y]+a[y];//        printf(&quot;x=%lld tmp1=%.3lf f[%lld]=%.3lf deg=%.3lf tmp2=%.3lf tmp3=%.3lf f[%lld][1]=%.3lf\n&quot;,x,tmp1,x,f[x][1]-a[x],deg[x],tmp2,tmp3,y,f[y][1]);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dpfs2(y,x);    &#125;&#125;void sub_task1()&#123;    dpfs(1,0);f[1][1]=f[1][0];    dpfs2(1,0);    id=1;    for(ll i=1;i&lt;=n;i++)        if(f[i][1]&lt;f[id][1]) id=i;    printf(&quot;%lld\n&quot;,id);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);    &#125;    for(ll i=1,c,b;i&lt;n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;b,&amp;c);        add(b,c);add(c,b);        deg[b]++,deg[c]++;    &#125;    sub_task1();&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>合法括号匹配[简单的序列,合法括号匹配]</title>
      <link href="/2025/03/14/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%5B%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%8F%E5%88%97,%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%5D/"/>
      <url>/2025/03/14/%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%5B%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%8F%E5%88%97,%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%5D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-15 14:57</p><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h2 id="简单的序列"><a href="#简单的序列" class="headerlink" title="简单的序列"></a>简单的序列</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a><a href="https://www.cnblogs.com/znsbc-13/p/11474038.html">题解</a></h3><p>A过一遍,再做时却错了</p><p>真是具有讽刺意味</p><h2 id="合法括号匹配"><a href="#合法括号匹配" class="headerlink" title="合法括号匹配"></a>合法括号匹配</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>每次可以在末尾加(,),或删除最末位,(长度为0时也可进行删除操作)</p><p>问最后合法方案数(长度任意)</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>设$g[i][j]$表示进行i次操作,最终长度为j方案数</p><p>最终答案就是$\sum\limits_{i&#x3D;0}^{i&lt;&#x3D;n}g[n][i]*catalan()$</p><p>模数可能不是质数$n^2$推一下catalan</p><p>然而$g$我推挂了</p><p>因为我们要求的是长度为j方案,直接的想法是将(,)等效,</p><p>$g[i][j]&#x3D;g[i-1][j-1]+g[i-1][j+1]$</p><p>但实际上(,)在删除时是不等效的$[添加时仍是等效的!]$</p><p>((删除最末位,()删除最末位最终得到都是(</p><p>但这么算就算少了,</p><p>$g[i][j]&#x3D;g[i-1][j-1]+g[i-1][j+1]*2$</p><p>这才是这个题要点</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define A 5101ll f[A][A],g[A][A];ll n,mod;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;mod);    f[0][0]=1;    for(ll i=1;i&lt;=n;i++)        for(ll j=0;j&lt;=i;j++)&#123;            if(j!=0)                f[i][j]=(f[i-1][j-1]+f[i-1][j+1])%mod;            else                 f[i][j]=f[i-1][j+1];        &#125;    g[0][0]=1;    for(ll i=1;i&lt;=n;i++)        for(ll j=0;j&lt;=i;j++)&#123;            if(j==0)//j==0                g[i][j]=(g[i-1][j]+g[i-1][j+1]*2)%mod;            else                 g[i][j]=(g[i-1][j-1]+g[i-1][j+1]*2)%mod;        &#125;    ll ans=0;    for(ll i=0;i&lt;=n;i++)&#123;//        printf(&quot;f[%lld][0]=%lld g[%lld][%lld]=%lld\n&quot;,i,f[i][0],n,i,g[n][i]);        ans=(ans+f[i][0]*g[n][i])%mod;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>管道取珠</title>
      <link href="/2025/03/14/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0/"/>
      <url>/2025/03/14/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-25 07:11</p><p>平方转化为两个人取到相同的方案,这是一个小trick</p><p>为什么这样是对的?</p><p>假设第一个人取方案是$x$,第二个人取方案是$y$,根据乘法原理就是$x*y$,又因为两个人取得方案数相同所以$x&#x3D;&#x3D;y$,即$x^2$</p><p>所以设f[a][b][c][d]表示第一个人从第一个管道取a,第一个人从管道取b,第二个人从管道取c,第二个人从管道取d</p><p>优化一下可以去掉一维</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 551#define mod 1024523ll f[2][A][A];//方案数相同那么取得个数必然相同,i表示总个数,j表示甲在a取了多少,q表示乙在a取了多少ll n,m;char up[510],down[510];int main()&#123;//  freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//  freopen(&quot;ans.sol&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    scanf(&quot;%s&quot;,up+1);    scanf(&quot;%s&quot;,down+1);    reverse(up+1,up+n+1);    reverse(down+1,down+m+1);    memset(f,0,sizeof(f));    f[0][0][0]=1;    for(ll i=1;i&lt;=n+m;i++)&#123;        memset(f[i&amp;1],0,sizeof(f[i&amp;1]));        for(ll a1=0;a1&lt;=min(n,i);a1++)&#123;            for(ll a2=0;a2&lt;=min(n,i);a2++)&#123;                ll b1=i-a1,b2=i-a2;                if(b1&lt;0||b2&lt;0) continue ;                //两个都从b取//              if(b1&lt;=0||b2&lt;=0) continue ;//              printf(&quot;b1=%lld b2=%lld\n&quot;,b1,b2);                if(down[b1]==down[b2])                    (f[i&amp;1][a1][a2]+=f[(i-1)&amp;1][a1][a2])%=mod;                //一个从up一个从down                if(a1)                    if(up[a1]==down[b2])                        (f[i&amp;1][a1][a2]+=f[(i-1)&amp;1][a1-1][a2])%=mod;                if(a2)                    if(up[a2]==down[b1])                        (f[i&amp;1][a1][a2]+=f[(i-1)&amp;1][a1][a2-1])%=mod;                //都从上                if(a1&amp;&amp;a2)                    if(up[a1]==up[a2])                        (f[i&amp;1][a1][a2]+=f[(i-1)&amp;1][a1-1][a2-1])%=mod;//              printf(&quot;f[%lld][%lld][%lld]=%lld a=%lld b=%lld c=%lld d=%lld e=%lld\n&quot;,i,a1,a2,f[i&amp;1][a1][a2],f[(i-1)&amp;1][a1][a2],f[(i-1)&amp;1][a1-1][a2],f[(i-1)&amp;1][a1][a2-1],f[(i-1)&amp;1][a1-1][a2-1],f[0][0][0]);            &#125;        &#125;    &#125;ll ans=0;    printf(&quot;%lld&quot;,f[(n+m)&amp;1][n][n]);&#125;</code></pre><p>View Code</p><p>不会做$noip-$难度题了</p><p>早就想写但代码在bzoj</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>古代猪文</title>
      <link href="/2025/03/14/%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/"/>
      <url>/2025/03/14/%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-23 17:38</p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定q ，n 求$q^{\sum\limits {d|n} C_{n}^{d} }mod 999911659$</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先如果你直接算次方上的数的话会炸掉，因为欧拉定理我们可以得到</p><p>$q^{\sum\limits {d|n} C_{n}^{d} mod999911658}mod 999911659$</p><p>因为mod的数是个合数</p><p>我们尝试分解质因数 $999911658&#x3D;2\times 3\times 4679\times 35617$</p><p>遇到这种式子不要急着$ex_lucas$，观察性质，$999911658 $中分解的数都为$1$次</p><p>所以我们可以直接用$lucas$求出来$mod$ $2$，$3$，$4679$，$35617$下各自的值，最后中国剩余定理合并即可</p><p>具体实现看代码</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 40000ll a[A],b[A],k,p,n;ll w[6]=&#123;0,2,3,4679,35617,999911659&#125;;ll jie[5][A],ni[5][A];ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)&#123;        x=1;        y=0;        return a;    &#125;    ll gcd=exgcd(b,a%b,x,y);    ll t=x;    x=y;    y=t-a/b*y;    return gcd;&#125;ll meng(ll x,ll k,ll cix)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%w[cix])        if(k&amp;1)            ans=ans*x%w[cix];    return ans;&#125;ll china()&#123;    ll x,y,a=0,m,n=1;    for(ll i=1;i&lt;=4;i++)        n*=w[i];    for(ll i=1;i&lt;=4;i++)&#123;        m=n/w[i];        exgcd(w[i],m,x,y);        a=(a+y*m*b[i])%n;    &#125;    if(a&gt;0) return a;    return a+n;&#125;ll jic(ll n,ll m,ll cix)&#123;    if(m&gt;n) return 0;    if(m==0) return 1;//    printf(&quot;jie=%lld ni=%lld ni2=%lld n=%lld m=%lld\n&quot;,jie[cix][n],ni[cix][n-m],ni[cix][m],n,m);    return jie[cix][n]%w[cix]*ni[cix][n-m]%w[cix]*ni[cix][m]%w[cix];&#125;ll lucas(ll n,ll m,ll cix)&#123;    if(n==0)return 1;//    printf(&quot;jic=%lld n=%lld m=%lld cix=%lld n=%lld m=%lld\n&quot;,jic(n%w[cix],m%w[cix],cix),n%w[cix],m%w[cix],cix,n,m);    return jic(n%w[cix],m%w[cix],cix)*lucas(n/w[cix],m/w[cix],cix)%w[cix];&#125;using namespace std;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p);    if(n==999911659)&#123;        cout&lt;&lt;0&lt;&lt;endl;        return 0;    &#125;    for(ll i=1;i&lt;=4;i++)&#123;        jie[i][0]=1;        ni[i][0]=1;        for(ll j=1;j&lt;w[i];j++)            jie[i][j]=jie[i][j-1]*j%w[i];        ni[i][w[i]-1]=meng(jie[i][w[i]-1],w[i]-2,i);//        printf(&quot;jie=%lld ni=%lld\n&quot;,jie[i][w[i]-1],ni[i][w[i]-1]);        for(ll j=w[i]-2;j&gt;=1;j--)&#123;            ni[i][j]=ni[i][j+1]*(j+1)%w[i];//if(j&gt;=35600)            printf(&quot;ni[%lld][%lld]=%lld\n&quot;,i,j,ni[i][j]);        &#125;        for(ll j=1;j*j&lt;=n;j++)&#123;            if((n%j)==0)&#123;//                printf(&quot;luc=%lld i=%lld j=%lld\n&quot;,lucas(n,j,i),i,j);                (b[i]+=lucas(n,j,i))%=w[i];                            if(j*j!=n)&#123;                    (b[i]+=lucas(n,n/j,i))%=w[i];                &#125;            &#125;//            printf(&quot;b[%lld]=%lld j=%lld\n&quot;,i,b[i],j);//            printf(&quot;b[%lld]=%lld j=%lld\n&quot;,i,b[i],j);        &#125;    &#125;//    for(ll i=1;i&lt;=4;i++)//        printf(&quot;%lld\n&quot;,b[i]);    ll j=china();//    cout&lt;&lt;j&lt;&lt;endl;    ll k=meng(p,china(),5);    cout&lt;&lt;k&lt;&lt;endl;    //模w「i」 剩余b「i」    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>概率充电器</title>
      <link href="/2025/03/14/%E6%A6%82%E7%8E%87%E5%85%85%E7%94%B5%E5%99%A8/"/>
      <url>/2025/03/14/%E6%A6%82%E7%8E%87%E5%85%85%E7%94%B5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-05 10:44</p><h1 id="概率充电器"><a href="#概率充电器" class="headerlink" title="概率充电器"></a>概率充电器</h1><p>内存限制：256 MiB 时间限制：2000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>著名的电子产品品牌 SHOI 刚刚发布了引领世界潮流的下一代电子产品——概率充电器:<br>“采用全新纳米级加工技术,实现元件与导线能否通电完全由真随机数决定!SHOI 概率充电器,您生活不可或缺的必需品!能充上电吗?现在就试试看吧!”<br>SHOI 概率充电器由 n-1 条导线连通了 n 个充电元件。进行充电时,每条导线是否可以导电以概率决定,每一个充电元件自身是否直接进行充电也由概率决定。<br>随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。<br>作为 SHOI 公司的忠实客户,你无法抑制自己购买 SHOI 产品的冲动。在排了一个星期的长队之后终于入手了最新型号的 SHOI 概率充电器。<br>你迫不及待地将 SHOI 概率充电器插入电源——这时你突然想知道,进入充电状态的元件个数的期望是多少呢?</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数:n。概率充电器的充电元件个数。充电元件由 1-n 编号。<br>之后的 n-1 行每行三个整数 a, b, p,描述了一根导线连接了编号为 a 和 b 的充电元件,通电概率为 p。<br>第 n+2 行 n 个整数:qiq_iq​i​​。表示 i 号元件直接充电的概率为 qi。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行一个实数,为进入充电状态的元件个数的期望,四舍五入到六位小数</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>3 1 2 50 1 3 50 50 0 0</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>1.000000</code></pre><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>对于 100%的数据,n≤500000,0≤p,qi≤100。</p><p><code>见到期望首先想dp。</code></p><p><code>直接想联通的概率比较难码，故思考f表示不联通的概率，最终用1-f就表示联通的概率。</code></p><p><code>f[x]=不连通的概率，p[x]表示这个点直接联通概。</code></p><p>&#96;&#96;&#96;我们为了避免后效性高斯消元（高斯消元消不起）必须选择其他方法。&#96;</p><p><code>思考：我们先求出来父亲对儿子贡献，再求出儿子对父亲贡献就好了（其实就是常规树形dp）。</code></p><p><code>我们先考虑儿子对父亲的贡献。`   </code>父亲可以由每一个儿子转移过来，<code>   ```父亲不连通的概率等于自己本身不连的概率乘以所有自己儿子不相连的概率</code><br>&#96;&#96;&#96;&#96;首先儿子需要联通才可以由儿子联通转移过来<code>，用1-f[x]表示自己儿子联通的概率</code><br><code>(1-f)*w表示当儿子联通的时候由儿子转移过来的概率`   </code>1-…等于不连通的概率<code>  ```再让他们都相乘</code><br><code>于是得到</code>  </p><p>$f[x]&#x3D;(1-p[x])*Π1-(1-f[son])*联通概率$</p><p><code>然后计算儿子的概率由父亲贡献</code><br>&#96;&#96;&#96;考虑f[v]表示除了v以外贡献&#96;</p><p><code>首先f[v]=1-当所有父亲被联通概率-其联通时的概率*这个边联通的概率 </code><br><code>得到</code>  </p><p>$f[v]&#x3D;(1-\frac{1-f[x]}{1-(1-f[son])}*联通概率)*联通概率$<br>思考<br><code>父亲被别的点转移过来的概率(除去v点)</code>$1-{\frac{f[x]}{1-(1-f[v]*w)}}$</p><p><code>1-f`` 表示自己儿子被转移过来的概率``(1-f)*w表示父亲与这个点相连的概率</code><br><code>1-..表示包含v在内的不相连的概率 </code><br><code>再用 f[x]/...不连通的概率</code><br><code>至于为什么除呢 ？``例如得不病 1/5 ，不得乙病3/5 ，不甲病1/3。那么1/5*5/3=1/3=不甲病 ，1-表示联通的概率</code></p><p><code>以下依然是本人丑陋代码</code></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>/*31 2 251 3 2550 10 201.057500先搜下再搜上     从底往上传 先搜下再搜上     从底往上传 先搜下再搜上     从底往上传 */#include&lt;bits/stdc++.h&gt;#define ll int#define db double#define e 1e-9#define inf 0x7fffffff#define A 1000100using namespace std;ll n,m,head[A],ver[A],next[A],tot=0,xx,yy;db gai[A],zz,gl[A],f[A];bool flag[A];void add(ll x,ll y,db gailv)&#123;    next[++tot]=head[x];    head[x]=tot;    ver[tot]=y;    gai[tot]=gailv*0.01;&#125;inline ll R()&#123;    ll X=0,F=1;char c=getchar();    while(!isdigit(c)) c==&#39;-&#39;?F=-1:F=F,c=getchar();    while(isdigit(c)) X=(X&lt;&lt;1)+(X&lt;&lt;3)+(c-&#39;0&#39;),c=getchar();    return F*X;&#125;db dfs1(ll x,ll fa)&#123;    for(ll i=head[x];i;i=next[i])    &#123;        ll y=ver[i];db g=gai[i];        if(y==fa) continue;            //        printf(&quot;x=%d y=%d fx=%lf fy=%lf %lf=(1-f[y])*g\n&quot;,x,y,f[x],f[y],(1-f[y])*g);        dfs1(y,x);f[x]*=(1-(1-f[y])*g);    &#125;&#125;void dfs2(ll x,ll fa)&#123;    db r;    for(ll i=head[x];i;i=next[i])    &#123;        ll y=ver[i];db g=gai[i];        if(y==fa) continue;        r=1.0-(f[x])/(1-(1-f[y])*g);        if(fabs(r)&gt;e&amp;&amp;fabs(f[y])&gt;e)        f[y]*=1-r*g;        dfs2(y,x);    &#125;&#125;int main()&#123;    n=R();    for(ll i=1;i&lt;n;i++)    &#123;        xx=R(),yy=R();scanf(&quot;%lf&quot;,&amp;zz);        add(xx,yy,zz);        add(yy,xx,zz);    &#125;    for(ll i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%lf&quot;,&amp;gl[i]);        gl[i]*=0.01;        f[i]=1-gl[i];    &#125;    memset(flag,0,sizeof(flag));dfs1(1,inf);    memset(flag,0,sizeof(flag));dfs2(1,inf);    db ans=0;    for(ll i=1;i&lt;=n;i++)    &#123;        ans+=1-f[i];    &#125;    printf(&quot;%.6lf\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>通过写这个题解，我深查自己语言表达能力欠缺。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分手是住院「期望dp」</title>
      <link href="/2025/03/14/%E5%88%86%E6%89%8B%E6%98%AF%E4%BD%8F%E9%99%A2%E3%80%8C%E6%9C%9F%E6%9C%9Bdp%E3%80%8D/"/>
      <url>/2025/03/14/%E5%88%86%E6%89%8B%E6%98%AF%E4%BD%8F%E9%99%A2%E3%80%8C%E6%9C%9F%E6%9C%9Bdp%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-01 21:09</p><p>这个题如果各位大神做的话肯定是”当时秒切”</p><p>像我这种据若就算了吧</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑没有随机的情况</p><p>从大到小枚举看是最优的,</p><p>感性理解,你大的一定要选,你如果小的选了之后你大的可能让当前小的翻转,你当前选的可能是无意义的,</p><p>(说人话就是你选大的可能会对小的造成影响,你选小的一定不会对大的造成影响)</p><p>设f[i]表示当你还剩i个开关要按时期望步数</p><p>那么题目中说最后k步选最优策略就没用了,f[i]一定会选择最优即一定按需要按的必须选的灯f[i]&#x3D;1</p><p>那么考虑随机,</p><p>贡献分两部分,1.按你需要按的$\frac{i}{n}$2.按不需按的是$\frac{n-i}{n}*(f[i+1]+f[i]+1)$</p><p>解释一下,你选到不该选的,你要用$1$步到$f[i+1]$状态,然后你要用$f[i+1]$步翻转回来,,回到当前状态之后你还要花$f[i]$步达到当前选到正确灯状态(这个式子让我们想起了tree这个题,很像不是吗)</p><p>关于求必选集合,用$vector$维护约数就行了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101#define mod 100003ll f[A],a[A],inv[A];ll cnt=0,n,k;vector &lt;ll&gt; vec[A];int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);    f[n]=1;inv[1]=1;    for(ll i=2;i&lt;=n;i++)         inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;    for(ll i=1,v;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    for(ll i=1;i&lt;=n;i++)        for(ll j=i;j&lt;=n;j+=i)            vec[j].push_back(i);    for(ll i=n;i&gt;=1;i--)&#123;        if(!a[i]) continue ;        for(ll j=0;j&lt;vec[i].size();j++)            a[vec[i][j]]^=1;        cnt++;    &#125;    for(ll i=n-1;i&gt;k;i--)        f[i]=(n+(n-i)*f[i+1]%mod)*inv[i]%mod;    for(ll i=k;i&gt;=1;i--)        f[i]=1;    ll ans=0;    for(ll i=1;i&lt;=cnt;i++)        (ans+=f[i])%=mod;    for(ll i=1;i&lt;=n;i++)        ans=ans*i%mod;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2025/03/14/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2025/03/14/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-30 10:53</p><p>以下博客在一派胡言,大家当我口胡就行</p><p>满足决策单调性,因为满足四边形不等式所以满足决策单调性</p><p>四边形不等式:</p><p>a&lt;b&lt;c&lt;d</p><p>val(a,d)+val(b,c)&gt;&#x3D;val(a,b)+val(c,d)</p><p>拓展若val(a,b+1)+val(a+1,b)&gt;&#x3D;val(a,b)+val(a+1,b+1)则满足四边形不等式</p><p>定理形如$f[i]&#x3D;min(f[j]+val(j,i))$dp式子,若$val(j,i)$满足四边形不等式则满足决策单调性</p><h2 id="注意这里是min-max可能不成立"><a href="#注意这里是min-max可能不成立" class="headerlink" title="注意这里是min,,,,max可能不成立"></a>注意这里是min,,,,max可能不成立</h2><p>证明:</p><p>设$p[i]$为$i$转移点最优决策,$j\in[1,p[i]-1]$</p><p>有$f[p[i]]+val(p[i],i)&lt;&#x3D;f[j]+val(j,i)$</p><p>设$i_2\in[i+1,n]$</p><p>$val$满足四边形不等式</p><p>$j&lt;p[i]&lt;i&lt;i_2$</p><p>故$val(j,i_2)+val(p[i],i)&gt;&#x3D;val(j,p[i])+val(i,i_2)$</p><p>所以$val(j,p[i])-val(p[i],i)&lt;&#x3D;val(j,i_2)-val(i,i_2)$</p><p>与上面式子相加$f[p[i]]+val(p[i],i_2)&lt;&#x3D;f[j]+val(j,i_2)$</p><p>表示所有&lt;&#x3D;p[i]转移点都不优,换句话说就是 决策点单调递增,p[i+1]&gt;&#x3D;p[i],p[i+2]&gt;&#x3D;p[i+1]</p><p>二维$dp$证明略</p><p>下面证明二维$dp$,若满足四边形不等式设$juec[i][j]$为$f[i][j]$转移点,则$juec[i][j-1]&lt;&#x3D;juec[i][j]&lt;&#x3D;juec[i+1][j]$</p><p>$juec[i][j]&gt;&#x3D;juec[i][j-1]$,设$p&#x3D;juec[i][j-1]$</p><p>有$f[i][p]+f[p][j]+val(i,j)&lt;&#x3D;f[i][k]+f[k][j]+val(i,j)$</p><p>于是$!@#%!@!^&amp;*$什么,这个题不是四边形不等式??????????????????????</p><p>我们假装是四边形不等式,套用</p><blockquote><p>val(a,b+1)+val(a+1,b)&gt;&#x3D;val(a,b)+val(a+1,b+1)</p></blockquote><p>于是满足决策单调</p><p>于是是$n^2$了</p><p>好傻逼</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>抵制克苏恩</title>
      <link href="/2025/03/14/%E6%8A%B5%E5%88%B6%E5%85%8B%E8%8B%8F%E6%81%A9/"/>
      <url>/2025/03/14/%E6%8A%B5%E5%88%B6%E5%85%8B%E8%8B%8F%E6%81%A9/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-17 14:26</p><h1 id="抵制克苏恩"><a href="#抵制克苏恩" class="headerlink" title="抵制克苏恩"></a>抵制克苏恩</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。如果你不玩炉石传说，不必担心，小Q同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个<br>30 点血量的英雄，并且可以用牌召唤至多 7<br>个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白告诉他使用奴隶主这张牌就可以啦。如果你不明白我上面在说什么，不必担心，小Q同学会告诉你他想让你做什么。现在小Q同学会给出克苏恩的攻击力是<br>K ，表示克苏恩会攻击 K 次，每次会从对方场上的英雄和随从中随机选择一个并对其产生 1<br>点伤害。现在对方有一名克苏恩，你有一些奴隶主作为随从，每名奴隶主的血量是给定的。如果克苏恩攻击了你的一名奴隶主，那么这名奴隶主的血量会减少 1<br>点，当其血量小于等于 0 时会死亡，如果受到攻击后不死亡，并且你的随从数量没有达到 7 ，这名奴隶主会召唤一个拥有 3<br>点血量的新奴隶主作为你的随从；如果克苏恩攻击了你的英雄，你的英雄会记录受到 1<br>点伤害。你应该注意到了，每当克苏恩进行一次攻击，你场上的随从可能发生很大的变化。小Q同学为你假设了克苏恩的攻击力，你场上分别有 1 点、 2 点、 3<br>点血量的奴隶主数量，你可以计算出你的英雄受到的总伤害的期望值是多少吗？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多局游戏。<br>第一行包含一个整数 T (T&lt;100) ，表示游戏的局数。<br>每局游戏仅占一行，包含四个非负整数 K, A, B 和 C ，表示克苏恩的攻击力是 K ，你有 A 个 1 点血量的奴隶主， B 个 2 点血量的奴隶主，<br>C 个 3 点血量的奴隶主。<br>保证 K 是小于 50 的正数， A+B+C 不超过 7 。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每局游戏，输出一个数字表示总伤害的期望值，保留两位小数。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>11 1 1 1</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>0.25</code></pre><p>$瞎扯$</p><hr><p>我记得我版本初痛下狠心和了一套克苏恩德，然后就被各种动物园等卡组掉打，然后我就和了一套动物园</p><p>克苏恩真是太慢了，启动慢，容易被很多卡组针对，事实上克苏恩比青玉德还慢</p><p>话说为什么对方有奴隶主自己还要下克苏恩，话说奴隶主什么时候退的环境</p><p>还有这个题非常符合原游戏，因为英雄可能有护甲所以期望可能大于30</p><p>$题解$</p><hr><p>期望题，我们考虑倒着转移，</p><p>因为可能有三血，二血，一血奴隶主，我们想到f一定要包含这些</p><p>先不考虑随从超限</p><p>首先当你打三血奴隶主时，你三血奴隶主数量不变，多一个二血</p><p>打二血奴隶主，你三血奴隶主加一个，二血减一个，一血加一个</p><p>打一血，一血减一个</p><p>那么分开转移就完了</p><p>完了</p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll int#define A 52using namespace std;ll t,a,b,c,k;double geshu=0,ans;double f[A][A][A][A];void bfs()&#123;        for(ll i=1;i&lt;=50;i++)            for(ll a=0;a&lt;=7;a++)                for(ll b=0;a+b&lt;=7;b++)                    for(ll c=0;a+b+c&lt;=7;c++)                    &#123;                        double p=1/(double(a)+double(b)+double(c)+double(1.0));                        if(a) f[i][a][b][c]+=f[i-1][a-1][b][c]*a*p;                        if(b) f[i][a][b][c]+=f[i-1][a+1][b-1][a+b+c+1&lt;=7?c+1:c]*b*p;                        if(c) f[i][a][b][c]+=f[i-1][a][b+1][a+b+c+1&lt;=7?c:c-1]*c*p;                        f[i][a][b][c]+=(f[i-1][a][b][c]+1)*p;                    &#125;        &#125;int main()&#123;    memset(f,0,sizeof(f));    bfs();    scanf(&quot;%d&quot;,&amp;t);    while(t--)    &#123;        ans=0;        scanf(&quot;%d%d%d%d&quot;,&amp;k,&amp;a,&amp;b,&amp;c);        double a1=double(a),b1=double(b),c1=double(c),k1=double(k);        printf(&quot;%.2lf\n&quot;,f[k][a][b][c]);    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>低级错误反思</title>
      <link href="/2025/03/14/%E4%BD%8E%E7%BA%A7%E9%94%99%E8%AF%AF%E5%8F%8D%E6%80%9D/"/>
      <url>/2025/03/14/%E4%BD%8E%E7%BA%A7%E9%94%99%E8%AF%AF%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-14 06:11</p><p>模拟测试72</p><p>对拍发现暴力挂了,没改暴力继续拍,直接交了,正解挂成15</p><p><em><strong>对拍是人类进步的阶梯</strong></em></p><p>一定要拍,不拍就挂,</p><p><em><strong>要对自己代码水平心中有b数</strong></em></p><p><em><strong>要对自己代码习惯心中有b数</strong></em></p><p>模拟测试73</p><p>不要相信大样例,大样例对了,你的程序也有可能锅掉,</p><h1 id="模拟题千万不要复制粘贴"><a href="#模拟题千万不要复制粘贴" class="headerlink" title="模拟题千万不要复制粘贴"></a><em><strong>模拟题千万不要复制粘贴</strong></em></h1><p>模拟测试74</p><p>set不可重,multiset</p><p>模拟测试87</p><p>暴力和(伪)正解犯的同一个sb错误0分</p><h2 id="不要过于相信对拍"><a href="#不要过于相信对拍" class="headerlink" title="不要过于相信对拍"></a>不要过于相信对拍</h2><p>模拟测试87改题</p><h6 id="不开multiset见祖宗"><a href="#不开multiset见祖宗" class="headerlink" title="不开multiset见祖宗"></a><strong><em>不开multiset见祖宗</em></strong></h6><p>(一场挂100)*2</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191028173925012-600821989.png"></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191028173942534-549074065.png"></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191028174003091-623230322.png"></p><h1 id="又是过于相信对拍"><a href="#又是过于相信对拍" class="headerlink" title="又是过于相信对拍"></a>又是过于相信对拍</h1><h1 id="暴力要重码不要在你打的正解基础上改"><a href="#暴力要重码不要在你打的正解基础上改" class="headerlink" title="暴力要重码不要在你打的正解基础上改"></a>暴力要重码不要在你打的正解基础上改</h1><p>模拟测试94</p><p>炸内存了</p><p>100挂成0</p><p>没事不要全开long long</p><p>注意空间,</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="打模拟对拍如果方便重构可以再打一遍-第一遍拍第二遍"><a href="#打模拟对拍如果方便重构可以再打一遍-第一遍拍第二遍" class="headerlink" title="打模拟对拍如果方便重构可以再打一遍,第一遍拍第二遍"></a>打模拟对拍如果方便重构可以再打一遍,第一遍拍第二遍</h2><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191105135728243-1981628803.png"></p><p>少清空一个r</p><p>这种错误还在犯</p><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191109114340550-561197957.png"></p><p>倒是避免了多测不清空………………………………………………..</p><p>WA0代码</p><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191109114503006-227871103.png"></p><p>AC代码</p><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191109114533112-1990209574.png"></p><p>正解挂成0</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 610000ll head[A],ver[A],nxt[A],edg[A],maxx[A][21],f[A][21],fa[A],dep[A];ll t,tot,n,m,q;struct node&#123;    ll x,y,z;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.z&lt;b.z;    &#125;&#125;e[A];ll find(ll x)&#123;    if(fa[x]!=x) fa[x]=find(fa[x]);    return fa[x];&#125;void add(ll x,ll y,ll z)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;edg[tot]=z;&#125;void merge(ll x,ll y)&#123;    x=find(x),y=find(y);    if(x!=y)&#123;        fa[x]=y;    &#125;&#125;ll lca(ll x,ll y)&#123;    ll maxn=0;    if(dep[x]&gt;dep[y]) swap(x,y);    for(ll i=t;i&gt;=0;i--)&#123;        if(dep[x]&lt;=dep[f[y][i]])&#123;            maxn=max(maxn,maxx[y][i]);            y=f[y][i];        &#125;        if(dep[x]==dep[y]) break;    &#125;    if(x==y) return maxn;    for(ll i=t;i&gt;=0;i--)&#123;        if(f[x][i]!=f[y][i])&#123;            maxn=max(maxn,maxx[x][i]);            maxn=max(maxn,maxx[y][i]);            x=f[x][i],y=f[y][i];        &#125;    &#125;    return maxn;&#125;void dfs(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        f[y][0]=x;        maxx[y][0]=edg[i];        dep[y]=dep[x]+1;        dfs(y,x);    &#125;&#125;int main()&#123;    freopen(&quot;graph.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;graph.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;q);    t=log(n)/log(2)+1;    for(ll i=1;i&lt;=n;i++) fa[i]=i;    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;e[i].x,&amp;e[i].y,&amp;e[i].z);    &#125;    sort(e+1,e+m+1);    for(ll i=1;i&lt;=m;i++)&#123;        ll x=e[i].x,y=e[i].y;        x=find(x),y=find(y);        if(x!=y)&#123;            merge(x,y);            add(e[i].x,e[i].y,e[i].z);            add(e[i].y,e[i].x,e[i].z);        &#125;    &#125;    f[1][0]=1;dfs(1,0);    for(ll j=1;j&lt;=t;j++)&#123;        for(ll i=1;i&lt;=n;i++)&#123;            ll now=f[i][j-1];            f[i][j]=f[now][j-1];            maxx[i][j]=max(maxx[now][j-1],maxx[i][j-1]);        &#125;    &#125;    for(ll i=1;i&lt;=q;i++)&#123;        ll x,y,xx,yy;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);        if(find(x)!=find(y))&#123;            printf(&quot;-1\n&quot;);        &#125;        else &#123;            printf(&quot;%lld\n&quot;,lca(x,y));        &#125;    &#125;&#125;</code></pre><p>View Code</p><h1 id="倍增一定要注意直接与lca相连的边"><a href="#倍增一定要注意直接与lca相连的边" class="headerlink" title="倍增一定要注意直接与lca相连的边"></a>倍增一定要注意直接与lca相连的边</h1><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191112193736915-1922055431.png"></p><p>如果对拍不了一定要静态查错</p><p>cnt写成n，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>传递闭包学习</title>
      <link href="/2025/03/14/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/14/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-14 06:33</p><p>在交际网络中，给定若干个元素和若干对二元关系，且关系具有传递性。通过传递性推导出尽可能多的元素之间的关系叫做传递闭包。</p><p>简单来说</p><p>若1与2连通，2与3连通。那么1与3连通。这样推导的过程就叫做传递闭包。</p><p>简单的代码实现</p><p>可以用弗洛伊德实现，这样是$n^3$的</p><p>例题</p><p>bzoj2208</p><h2 id="2208-Jsoi2010-连通数"><a href="#2208-Jsoi2010-连通数" class="headerlink" title="2208: [Jsoi2010]连通数"></a>2208: [Jsoi2010]连通数</h2><p>Time Limit: 20 Sec Memory Limit: 512 MB<br>Submit: 4758 Solved: 2026<br>[<a href="https://www.lydsy.com/JudgeOnline/submitpage.php?id=2208">Submit</a>][<a href="https://www.lydsy.com/JudgeOnline/problemstatus.php?id=2208">Status</a>][<a href="https://www.lydsy.com/JudgeOnline/bbs.php?id=2208">Discuss</a>]</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>求每个点能到达的顶点数</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入数据第一行是图顶点的数量，一个正整数N。 接下来N行，每行N个字符。第i行第j列的1表示顶点i到j有边，0则表示无边。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一行一个整数，表示该图的连通数。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>010<br>001<br>100</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>9</p><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>对于100%的数据，N不超过2000。</p><p>我们可以传递闭包但$n^3$肯定会超时怎么办呢？</p><p>我们可以用bitset优化</p><pre><code>    for(ll j=1;j&lt;=n;j++)        for(ll i=1;i&lt;=n;i++)        if(w[i][j])            w[i]|=w[j];</code></pre><p>首先如果i与j连通，那么所有j能到达的点i都能够到达</p><p>|就完了 j为阶段数，所以j要放在i外面</p><p>我们巧妙省掉一层循环。使变为$\frac{n^3}{32}$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>部分noip题解</title>
      <link href="/2025/03/14/%E9%83%A8%E5%88%86noip%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/03/14/%E9%83%A8%E5%88%86noip%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-11 20:55</p><h2 id="NOIP2011"><a href="#NOIP2011" class="headerlink" title="NOIP2011"></a>NOIP2011</h2><h2 id="Mayan游戏"><a href="#Mayan游戏" class="headerlink" title="Mayan游戏"></a>Mayan游戏</h2><h3 id="模拟题"><a href="#模拟题" class="headerlink" title="模拟题"></a>模拟题</h3><p>比较有意思的搜索,需要剪枝</p><p>无脑枝:1.只有两个方块时直接return(不可能再消掉了) 2.不换颜色相同的</p><p>有脑枝:发现左移和右移其实是一样的,当前块与右面块交换等于右面块与当前块交换</p><p>然而左面为空时左移右移不同,特判一下</p><p>(其实就是向左移只当左面为空时才移,其他任意一种情况都与右移等价)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll mp[8][6],vis[10][10],sta[10],del[10][10];ll top,tt;const ll n=7,m=5;struct node&#123;    ll x,y;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b)&#123;x=a,y=b;&#125;&#125;;struct an&#123;    ll x,y,g;    an()&#123;&#125;    an(const ll &amp;a,const ll &amp;b,const ll &amp;c)&#123;x=a,y=b,g=c;&#125;&#125;ans[7];deque&lt;node&gt; q,p;ll ok(ll x,ll y,ll opt)&#123;    if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m&amp;&amp;mp[x][y]==opt&amp;&amp;!vis[x][y]) return 1;     return 0;&#125;void print()&#123;    puts(&quot;wwb&quot;);    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=m;j++)&#123;            printf(&quot;%lld &quot;,mp[i][j]);        &#125;&#125;void down()&#123;    for(ll i=1;i&lt;=m;i++)&#123;        top=0;        for(ll j=1;j&lt;=n;j++)            if(mp[j][i])                sta[++top]=mp[j][i];        for(ll j=1;j&lt;=n;j++)            mp[j][i]=0;        for(ll j=1;j&lt;=top;j++)            mp[j][i]=sta[j];    &#125;&#125;void xiao()&#123;    ll ok=0;    down();        memset(del,0,sizeof(del));    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(mp[i][j])&#123;                if(i&gt;1&amp;&amp;i&lt;n)&#123;                    if(mp[i][j]==mp[i+1][j]&amp;&amp;mp[i][j]==mp[i-1][j])&#123;                        del[i][j]=1,del[i+1][j]=1,del[i-1][j]=1;                        ok=1;                    &#125;                &#125;                if(j&gt;1&amp;&amp;j&lt;m)&#123;                    if(mp[i][j]==mp[i][j-1]&amp;&amp;mp[i][j]==mp[i][j+1])&#123;                        del[i][j]=1,del[i][j-1]=1,del[i][j+1]=1;                        ok=1;                    &#125;                &#125;            &#125;        &#125;    if(!ok) return ;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            if(del[i][j])                mp[i][j]=0;    down();    xiao();    return ;&#125;ll ttt;ll check()&#123;    for(ll i=1;i&lt;=m;i++)        if(mp[1][i]) return 0;    return 1;&#125;void cpy(ll x[][6],ll y[][6])&#123;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            x[i][j]=y[i][j];&#125;void dfs(ll cnt)&#123;//    printf(&quot;%lld\n&quot;,cnt);    if(check()&amp;&amp;cnt==tt+1)&#123;        for(ll i=1;i&lt;=tt;i++)            printf(&quot;%lld %lld %lld\n&quot;,ans[i].x,ans[i].y,ans[i].g);        exit(0);    &#125;    if(cnt&gt;=tt+1) return ;    ll mem[8][6];    for(ll j=1;j&lt;=m;j++)        for(ll i=1;i&lt;=n;i++)&#123;            if(mp[i][j])&#123;                                if(j!=m&amp;&amp;mp[i][j]!=mp[i][j+1])&#123;                    cpy(mem,mp);                    ans[++ttt]=an(j-1,i-1,1);                    swap(mp[i][j],mp[i][j+1]);                    xiao();                    dfs(cnt+1);ttt--;                    cpy(mp,mem);                &#125;                if(j!=1&amp;&amp;mp[i][j]!=mp[i][j-1])&#123;                    cpy(mem,mp);                    ans[++ttt]=an(j-1,i-1,-1);                    swap(mp[i][j],mp[i][j-1]);                    xiao();                    dfs(cnt+1);ttt--;                    cpy(mp,mem);                &#125;            &#125;        &#125;&#125;ll cnt[7];int main()&#123;    scanf(&quot;%lld&quot;,&amp;tt);ll x;    x=1;while(x!=0)&#123;scanf(&quot;%lld&quot;,&amp;x);mp[++cnt[1]][1]=x;&#125;    x=1;while(x!=0)&#123;scanf(&quot;%lld&quot;,&amp;x);mp[++cnt[2]][2]=x;&#125;    x=1;while(x!=0)&#123;scanf(&quot;%lld&quot;,&amp;x);mp[++cnt[3]][3]=x;&#125;    x=1;while(x!=0)&#123;scanf(&quot;%lld&quot;,&amp;x);mp[++cnt[4]][4]=x;&#125;    x=1;while(x!=0)&#123;scanf(&quot;%lld&quot;,&amp;x);mp[++cnt[5]][5]=x;&#125;    xiao();    dfs(1);    puts(&quot;-1&quot;);&#125;</code></pre><p>View Code</p><h2 id="NOIP2014"><a href="#NOIP2014" class="headerlink" title="NOIP2014"></a>NOIP2014</h2><h2 id="联合权值"><a href="#联合权值" class="headerlink" title="联合权值"></a>联合权值</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>花5分钟写了写</p><p>发现根本不用$Dp$,</p><p>$O(n^2)$,max显然就是最大值*次大值,总和思考怎么算</p><p>发现就是(sum[i]-w[y])*w[y],sum表示是所有与i相连点权值之和,</p><p>$O(n)$式子</p><p>显然可以优化,${sum[i]}^2-\sum\limits_{y}{w[y]}^2$随便维护一下</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define mod 10007#define A 1111111ll tot,n,m,t,ans,mx;ll sum[A],nxt[A],ver[A],x[A],y[A],head[A],w[A],maxx[A],cimaxx[A],pingf[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);m=n-1;    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]);        add(x[i],y[i]);add(y[i],x[i]);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;w[i]);    &#125;    for(ll i=1;i&lt;=m;i++)&#123;        (sum[x[i]]+=w[y[i]])%=mod,(sum[y[i]]+=w[x[i]])%=mod;        (pingf[x[i]]+=w[y[i]]*w[y[i]])%=mod;        (pingf[y[i]]+=w[x[i]]*w[x[i]])%=mod;        if(w[y[i]]&gt;maxx[x[i]])&#123;            cimaxx[x[i]]=maxx[x[i]];            maxx[x[i]]=w[y[i]];        &#125;        else if(w[y[i]]&gt;cimaxx[x[i]])&#123;            cimaxx[x[i]]=w[y[i]];        &#125;        if(w[x[i]]&gt;maxx[y[i]])&#123;            cimaxx[y[i]]=maxx[y[i]];            maxx[y[i]]=w[x[i]];        &#125;        else if(w[x[i]]&gt;cimaxx[y[i]])&#123;            cimaxx[y[i]]=w[x[i]];        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        (ans+=sum[i]*sum[i]%mod-pingf[i])%mod;        mx=max(cimaxx[i]*maxx[i],mx);    &#125;    ans%=mod;    printf(&quot;%lld &quot;,mx);    printf(&quot;%lld\n&quot;,(ans+mod)%mod);&#125;</code></pre><p>View Code</p><h2 id="NOIP2016"><a href="#NOIP2016" class="headerlink" title="NOIP2016"></a>NOIP2016</h2><h2 id="蚯蚓"><a href="#蚯蚓" class="headerlink" title="蚯蚓"></a>蚯蚓</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>暴力就是开一个堆维护,然后每次取出最大值,维护mark表示标准差可以85分</p><p>正解是根据单调性不算标准差</p><p>因为每次取出最大值,取出的最大值越来小,另外维护两个队列,维护切出的两部分蚯蚓</p><p>剩下两部分蚯蚓也满足单调不升性质</p><p>单调队列维护</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longdeque&lt;ll&gt; w[4];ll n,m,q,u,v,t;ll mark,cnt,mxid,mx;ll ans[31111111],dl[31111111],o[31111111];double p;ll cmp(ll x,ll y)&#123;    return x&gt;y;&#125;ll gettop()&#123;    mx=-123456789101112,mxid=0;    if(!w[1].empty())&#123;        if(w[1].front()&gt;mx)&#123;            mx=w[1].front();            mxid=1;        &#125;    &#125;    if(!w[2].empty())&#123;        if(w[2].front()&gt;mx)&#123;            mx=w[2].front();            mxid=2;        &#125;    &#125;    if(!w[3].empty())&#123;        if(w[3].front()&gt;mx)&#123;            mx=w[3].front();            mxid=3;        &#125;    &#125;    w[mxid].pop_front();    return mx;&#125;ll wempty()&#123;    if(w[1].empty()&amp;&amp;w[2].empty()&amp;&amp;w[3].empty()) return 1;    return 0;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;o[i]);    &#125;    sort(o+1,o+n+1,cmp);    for(ll i=1;i&lt;=n;i++)&#123;        w[1].push_back(o[i]);    &#125;        p=(double)(u)/(double)(v);    for(ll i=1;i&lt;=m;i++)&#123;        ll x=gettop()+mark;        double xx=p*x;        ll x1=floor(p*x),x2=x-x1;        mark+=q;                w[2].push_back(x1-mark),w[3].push_back(x2-mark);        ans[i]=x;    &#125;    while(!wempty())&#123;        dl[++dl[0]]=gettop()+mark;    &#125;    for(ll i=t;i&lt;=m;i+=t)        printf(&quot;%lld &quot;,ans[i]);    printf(&quot;\n&quot;);    for(ll i=t;i&lt;=dl[0];i+=t)        printf(&quot;%lld &quot;,dl[i]);    printf(&quot;\n&quot;);&#125;</code></pre><p>View Code</p><h2 id="NOIP2017"><a href="#NOIP2017" class="headerlink" title="NOIP2017"></a>NOIP2017</h2><h2 id="列队"><a href="#列队" class="headerlink" title="列队"></a>列队</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>易发现m列有些特殊</p><p>前m-1列和m列拆开考虑</p><p>开n棵线段树维护n行,在开一棵线段树维护最后一列</p><p>每一次操作可简化为</p><h4 id="依次进行-1-当前行删除y-2-当前行前移-3-最后列删除x-4-最后列前移"><a href="#依次进行-1-当前行删除y-2-当前行前移-3-最后列删除x-4-最后列前移" class="headerlink" title="依次进行 1.当前行删除y 2.当前行前移 3.最后列删除x 4.最后列前移"></a><code>依次进行 1.当前行删除y 2.当前行前移 3.最后列删除x 4.最后列前移</code></h4><p>线段树维护查询第k大操作</p><p>代码实现有很多技巧,很考验代码能力</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>//依次进行//1.当前行删除y//2.当前行前移//3.最后列删除x//4.最后列前移#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 11111111vector&lt;ll&gt; vec[A];ll ls[A],rs[A],v[A],toot[A];ll n,m,tot,cnt,q;void change(ll &amp;x,ll l,ll r,ll val)&#123;    if(!x) x=++cnt;    v[x]++;    if(l==r) return ;    ll mid=(l+r)&gt;&gt;1;    if(mid&gt;=val) change(ls[x],l,mid,val);    else change(rs[x],mid+1,r,val);&#125;ll ask(ll &amp;x,ll l,ll r,ll k)&#123;    if(l==r) return l;    ll mid=(l+r)&gt;&gt;1;    ll sum=mid-l+1-v[ls[x]];    if(sum&gt;=k) return ask(ls[x],l,mid,k);    else return ask(rs[x],mid+1,r,k-sum);&#125;ll callast(ll x)&#123;    //查询最后一列    ll r=ask(toot[n+1],1,tot,x);    change(toot[n+1],1,tot,r);    return r&lt;=n?(r-1)*m+m:vec[n+1][r-n-1];&#125;ll calcommon(ll x,ll y)&#123;    ll r=ask(toot[x],1,tot,y);    change(toot[x],1,tot,r);    return r&lt;m?(x-1)*m+r:vec[x][r-m];&#125;int main()&#123;    ll ret,tmp;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;q);    tot=max(n,m)+q;    while(q--)&#123;        ll x,y;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);        if(y==m)&#123;            ret=callast(x);            vec[n+1].push_back(ret);            printf(&quot;%lld\n&quot;,ret);        &#125;        else&#123;            ret=calcommon(x,y);            printf(&quot;%lld\n&quot;,ret);            vec[n+1].push_back(ret);            tmp=callast(x);            vec[x].push_back(tmp);        &#125;    &#125;&#125;</code></pre><p>View Code</p><h2 id="NOIP2018"><a href="#NOIP2018" class="headerlink" title="NOIP2018"></a>NOIP2018</h2><h2 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>性质,1.最简系统一定是给定系统子集</p><p>2.最简系统任意一种货币不能被其他货币表示</p><p>2是显然的</p><p>1证明:假设非子集元素为x</p><p>若x可以被最简系统表示加入它没用,若不能被表示出,你原本不能表示x,现在加上x可以表示x与最简系统矛盾了</p><p>所以可以无脑背包</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编写评测过程零碎知识点</title>
      <link href="/2025/03/14/%E7%BC%96%E5%86%99%E8%AF%84%E6%B5%8B%E8%BF%87%E7%A8%8B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2025/03/14/%E7%BC%96%E5%86%99%E8%AF%84%E6%B5%8B%E8%BF%87%E7%A8%8B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>归档于  2022-09-23 13:07</p><h2 id="1-lua-gettable"><a href="#1-lua-gettable" class="headerlink" title="[1.lua gettable"></a>[1.lua gettable</h2><p>pushstring](<a href="https://blog.csdn.net/yifan_lym/article/details/49889505?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-">https://blog.csdn.net/yifan_lym/article/details/49889505?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-</a><br>task-<br>blog-2%7Edefault%7ECTRLIST%7ERate-1-49889505-blog-17450213.pc_relevant_aa_2&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_t0.none-<br>task-<br>blog-2%7Edefault%7ECTRLIST%7ERate-1-49889505-blog-17450213.pc_relevant_aa_2&amp;utm_relevant_index&#x3D;1<br>“1.lua gettable pushstring”)</p><p>先pushstring压住键值 此时栈中有键值和table<br>然后gettable(L , -2)从table中获取值并覆盖掉键值放入栈中<br>之后从-1的栈顶获取值进行操作pop</p><h2 id="2-seccomp"><a href="#2-seccomp" class="headerlink" title="2.seccomp"></a>2.seccomp</h2><p>seccomp限制fork不会影响到execve</p><h2 id="3-linux内核"><a href="#3-linux内核" class="headerlink" title="3.linux内核"></a>3.linux内核</h2><p><a href="https://www.cnblogs.com/tongye/p/9517935.html" title="我看的博客">我看的博客</a></p><h4 id="1-关于fork"><a href="#1-关于fork" class="headerlink" title="1.关于fork"></a>1.关于fork</h4><p>fork()用于创建子进程<br>fork()的返回值有以下三种：</p><p>a）在父进程中，fork() 返回新创建子进程的 PID；</p><p>b）在子进程中，fork() 返回0；</p><p>c）如果 fork() 调用出错，则返回负值</p><h4 id="2-关于wait"><a href="#2-关于wait" class="headerlink" title="2.关于wait"></a>2.关于wait</h4><p>wait是进程相关，当父进程调用wait后会立刻阻塞自己，子进程中如果有结束的就收集子进程的消息并销毁，没有就将阻塞在这<br>四种wait wait() waitpid() wait3() wait4()</p><p>wait()会等待所有子进程的消息<br>waitpid(pid_t,*status,options)</p><p>pid_t&lt;-1 等待进程组ID等于|pid|的子进程<br>pid_t&#x3D;-1 等待任何子进程<br>pid&#x3D;0 等待当前进程的任何子进程<br>pid&gt;0 等待任何子进程ID为pid的子进程</p><p>options:<br><img src="https://img2022.cnblogs.com/blog/1708132/202209/1708132-20220925141955133-569186859.png" alt="image"></p><p>waitpid() 返回值</p><p>a) 正常返回时，waitpid()返回子进程pid</p><p>b) 调用出错返回-1</p><p>c) 设置了WNOHANG的情况下如果没有结束的进程会返回0</p><p>wait3()wait4()<br><img src="https://img2022.cnblogs.com/blog/1708132/202209/1708132-20220925142114442-1633447847.png" alt="image"></p><h3 id="3-phread"><a href="#3-phread" class="headerlink" title="3.phread_"></a>3.phread_</h3><pre><code>int pthread_create(pthread_t *thread,                   const pthread_attr_t *attr,                   void *(*start_routine) (void *),                   void *arg);</code></pre><p>创建线程</p><h3 id="4-dup2"><a href="#4-dup2" class="headerlink" title="4.dup2"></a>4.dup2</h3><p><a href="https://blog.nowcoder.net/n/1337e6e77d2f402b851f86795b32b0ad" title="参考的博客">参考的博客</a><br>用于输入输出的重定向<br><img src="https://img2022.cnblogs.com/blog/1708132/202209/1708132-20220929110544574-1028047920.png" alt="image"><br>例如原本有printf(“%d”,i);<br>应当输出到终端里<br>我们将STDOUT_FILENO指向文件，那将输出重定向到文件里了<br>newfd原本是终端，执行dup2后终端输出关闭，并且将oldfd的fd赋值给了newfd使得输出到了文件中</p><h3 id="5-execve"><a href="#5-execve" class="headerlink" title="5.execve"></a>5.execve</h3><p>execve我弄的不是很清，我遇到的问题是相当多的<br>execve 会保留setuid之后的uid<br>第一个参数传可执行文件或python&#x2F;java的解释器路径<br>第二个参数，传一个以空字符结尾的字符指针数组的指针，以NULL结尾，按照惯例，第一个元素应该是执行程序的名称<br>第三个参数，环境变量<br>比如运行python类型文件：</p><pre><code>argv[]=&#123;&quot;python&quot;,&quot;./helloworld.py&quot;,NULL&#125;;//解释器路径的名称+参数execve(&quot;/usr/bin/python3&quot;,argv,envp);</code></pre><p>运行c的二进制文件</p><pre><code>argv[]=&#123;&quot;helloword&quot;,NULL&#125;;//可执行文件的名称，这里直接传NULL也行execve(&quot;./helloworld&quot;,argv,envp);//</code></pre><p>运行会直接覆盖掉原进程，然后若运行失败会有返回值-1</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>比赛</title>
      <link href="/2025/03/14/%E6%AF%94%E8%B5%9B/"/>
      <url>/2025/03/14/%E6%AF%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-09 08:30</p><p>我竟然浪费一下午改题时间做了这个sb题</p><p>从2.00改到6.00</p><p>搜索题还要看代码</p><p>我是不是废了</p><p>记忆化,但怎么记忆化,记忆化划分状态不太好划分,你不知道哪些队比过了,哪些队没有比过</p><p>也就是只拿一些队得分情况划分状态表示不全</p><p>我们不能搜到一个状态,记录,return,因为会出现当前本应非法但你取用了记忆化的值就错了</p><p>有一种做法就是再记录队之间比赛过状态,然而空间不够</p><p>因为任意两支队伍都要比赛一场我们可以列出来比赛是下三角类型的,</p><p>队伍1 2 3 4</p><p>1 1 1 1 1</p><p>2 1 1 1</p><p>3 1 1</p><p>1 1</p><p>枚举当前比赛队伍和枚举的队伍,(拿4举例就是枚举1 2 3和4比赛,然后向前推进到3,枚举1 2 和3比赛,向前推进到2,枚举1和2比赛,最后推进到1)</p><p>这样我们dp定义f[x][state]表示推进到第x列,当前球队得分状态是state的得分,有多少种合法方案,这样我们可以间接知道比赛情况</p><p>依然会炸内存,但是可以hash表维护</p><p>当我们搜完一列时看有没有记忆化,如果没有记忆化就接着搜完下一列</p><p>再加一些剪枝</p><p>可行性剪枝</p><p>如果当前还剩x场比赛,球队i分数a[i],即使x场比赛全赢都得不了a[i]分就return</p><p>搜索顺序剪枝</p><p>sort排序</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 12const ll modd=1e9+7;pair&lt;ll,ll&gt; e[A*A];ll a[A];ll n,cnt,ans;struct Hash_Table&#123;    #define mod 1030829    ll nxt[mod],val[mod],ver[mod],head[mod];    ll tot;    ll &amp;operator [](const ll &amp;H)&#123;        ll x=H%mod;        for(ll i=head[x];i;i=nxt[i])&#123;            if(ver[i]==H) return val[i];        &#125;        nxt[++tot]=head[x];        ver[tot]=H;        head[x]=tot;        return val[tot];    &#125;&#125;H;ll cmp(ll x,ll y)&#123;return x&gt;y;&#125;ll gethash(ll x)&#123;    ll tmp[11],hh=x;    for(ll i=1;i&lt;=x;i++)        tmp[i]=a[i];    sort(tmp+1,tmp+x+1);    for(ll i=1;i&lt;=x;i++)        hh=hh*28+tmp[i];    return hh;&#125;ll dfs(ll x,ll pla)&#123;    if(a[pla]&gt;(pla-x)*3) return 0;    if(x==pla)&#123;        if(pla==1) return 1;        else &#123;            ll hh=gethash(pla-1);            if(H[hh]!=-1) &#123;//                printf(&quot;h=%lld \n&quot;,hh);                return H[hh];            &#125;            else return H[hh]=dfs(1,pla-1);        &#125;    &#125;    ll d=0;    if(a[x]&gt;=3)&#123;        a[x]-=3;        d+=dfs(x+1,pla);        if(d&gt;=modd) d-=modd;            a[x]+=3;    &#125;    if(a[pla]&gt;=3)&#123;        a[pla]-=3;        d+=dfs(x+1,pla);        if(d&gt;=modd) d-=modd;            a[pla]+=3;    &#125;    if(a[x]&gt;=1&amp;&amp;a[pla]&gt;=1)&#123;        a[x]--,a[pla]--;        d+=dfs(x+1,pla);        if(d&gt;=modd) d-=modd;            a[x]++,a[pla]++;    &#125;    return d;&#125;int main()&#123;    memset(H.val,-1,sizeof(H.val));    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    sort(a+1,a+n+1,cmp);    printf(&quot;%lld\n&quot;,dfs(1,n)%modd);&#125;</code></pre><p>View Code</p><p>csps退役前,我最后悔的事就是做了这个sb题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>w</title>
      <link href="/2025/03/14/w/"/>
      <url>/2025/03/14/w/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-02 06:27</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191002060237659-1530985438.png"></p><p>dp</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先第一问就是奇度点个数&#x2F;2</p><p>直接$dp$不好$dp$,考虑关于奇度点来设立</p><p>边权下放到节点</p><p>$f[x][0&#x2F;1]$结构体定义,$f[x][0].c1$表示$x$与父亲连边不反转时奇度点个数,$f[x][0].c2$表示$x$与父亲连边翻转是要的最小操作数$f[x][1]$表示翻转</p><p>转移就是分情况讨论,我们首先要将子树合并完,最后再上传到当前节点</p><p>w1表示子树有一条边指向当前节点代价(奇度点个数为奇)</p><p>w2表示子树没有边指向当前节点代价(奇度点个数为偶)</p><p>分别转移</p><p>$w1&#x3D;min(w2+f[y][1],w1+f[y][0])$</p><p>解释一下保证奇度点个数为奇可以是当前<strong>已考虑子树</strong> 内两两合,并翻转当前这条边;或者<strong>已考虑子树</strong> 内伸出一条边当前边不伸</p><p>$w2&#x3D;min(w1+f[y][1],w2+f[y][0])$</p><p>和上面类似</p><p>那么对于当前来说</p><p>$f[x][0]$由两部分转移,可以是没操作$w2$可以当前点和子树一奇度点结合$c1&#x3D;w1.c1+1,c2&#x3D;w1.c2$(路径长度不+1是因为在下面统计过了)</p><p>$f[x][1]$由两部分转移,可以是让子树伸的边继续延伸$c1&#x3D;w1.c1,c2&#x3D;w1.c2+1$可以是当前边翻转然后当前点成为奇点$c1&#x3D;w2.c1+1,c2&#x3D;w2.c2+1$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 1e9+7#define A 1111111ll head[A],nxt[A],ver[A],edg[A];ll tot,n;void add(ll x,ll y,ll opt)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y,edg[tot]=opt;&#125;struct node&#123;    ll c1,c2;    node()&#123;&#125;    node (const ll &amp;a,const ll &amp;b)&#123;        c1=a,c2=b;    &#125;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return (a.c1==b.c1)?(a.c2&lt;b.c2):(a.c1&lt;b.c1);    &#125;    friend node operator +(const node &amp;a,const node &amp;b)&#123;        node c;c.c1=0,c.c2=0;        c.c1=a.c1+b.c1,c.c2=a.c2+b.c2;        return c;    &#125;&#125;f[A][2];void dfs(ll x,ll pre,ll opt)&#123;    node w1(inf,inf),w2(0,0),n1,n2;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dfs(y,x,edg[i]);        n1=min(w1+f[y][0],w2+f[y][1]);        n2=min(w2+f[y][0],w1+f[y][1]);        w1=n1,w2=n2;    &#125;//    printf(&quot;w1.c1=%lld w1.c2=%lld w2.c1=%lld w2.c2=%lld\n&quot;,w1.c1,w1.c2,w2.c1,w2.c2);    if(opt==2)&#123;        f[x][1]=min(node(w1.c1,w1.c2+1),node(w2.c1+1,w2.c2+1));        f[x][0]=min(node(w1.c1+1,w1.c2),node(w2.c1,w2.c2));    &#125;    else if(opt==1)&#123;//must        f[x][1]=min(node(w1.c1,w1.c2+1),node(w2.c1+1,w2.c2+1));        f[x][0]=node(inf,inf);    &#125;    else if(opt==0)&#123;//must`not        f[x][0]=min(node(w1.c1+1,w1.c2),node(w2.c1,w2.c2));        f[x][1]=node(inf,inf);    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;n;i++)&#123;        ll x,y,opt,case1,case2;        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;case1,&amp;case2);        if(case2==2)&#123;            add(x,y,2);add(y,x,2);        &#125;        else if(case1==case2)&#123;            add(x,y,0);add(y,x,0);        &#125;        else if(case1!=case2)&#123;            add(x,y,1);add(y,x,1);        &#125;    &#125;    dfs(1,0,0);    printf(&quot;%lld %lld\n&quot;,f[1][0].c1&gt;&gt;1,f[1][0].c2);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>v·y「状压dp」</title>
      <link href="/2025/03/14/v%C2%B7y%E3%80%8C%E7%8A%B6%E5%8E%8Bdp%E3%80%8D/"/>
      <url>/2025/03/14/v%C2%B7y%E3%80%8C%E7%8A%B6%E5%8E%8Bdp%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-01 21:41</p><p>一直对状压dp怀有一种恐惧感</p><p>不会打,不会调,关键是不会调</p><p>做了这两道题,虽然还是不会状压dp,但总比之前好了一些</p><h2 id="y"><a href="#y" class="headerlink" title="y"></a>y</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191001212811399-1079425735.png"></p><p>普通状压应该很好打</p><p>复杂度$O(2^d<em>n</em>(n+m))$</p><pre><code>    for(ll i=2;i&lt;=d;i++)&#123;        for(ll state=0;state&lt;=maxn;state++)&#123;            for(ll x=1;x&lt;=n;x++)&#123;                for(ll j=head[x];j;j=nxt[j])&#123;                    ll y=ver[j];                    if(!f[i-1][x][state]) continue ;                    f[i][y][(state&lt;&lt;1)|edg[j]]|=f[i-1][x][state];                &#125;            &#125;        &#125;    &#125;</code></pre><p>那么该怎么优化,</p><p>折半搜索,你起点是确定的,枚举中间点,这样复杂度就降低成$O(2^{\frac{d}{2}}<em>n</em>(m+n)+2^d*n)$</p><p>最终枚举中间点,</p><p>这样做思想很重要</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 10101010bool f1[21][93][1&lt;&lt;12],f2[21][93][1&lt;&lt;12],hash_map[1&lt;&lt;22];ll nxt[A],ver[A],head[A],edg[A];ll n,m,q,ans,tot,d;void add(ll x,ll y,ll z)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y,edg[tot]=z;&#125;void turn(ll x,ll n)&#123;     ll t=x,num=0,xx[100];     while(x) xx[num++]=x%2,x/=2;         for(ll i=num;i&lt;n;i++)printf(&quot;0&quot;);     for(ll i=num-1;i&gt;=0;i--)cout&lt;&lt;xx[i]; //    puts(&quot;&quot;);&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;d);    for(ll i=1,a,b,c;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);add(b,a,c);    &#125;    for(ll i=head[1];i;i=nxt[i])&#123;        ll y=ver[i];        f1[1][y][edg[i]]=1;    &#125;    ll d1=d/2,d2=d-d1;    ll maxn1=(1&lt;&lt;(d1))-1,maxn2=(1&lt;&lt;(d2))-1;//    printf(&quot;d1=%lld d2=%lld\n&quot;,d1,d2);    for(ll i=2;i&lt;=d1;i++)&#123;        for(ll state=0;state&lt;=((1&lt;&lt;i)-1);state++)&#123;            for(ll x=1;x&lt;=n;x++)&#123;                for(ll j=head[x];j;j=nxt[j])&#123;                    ll y=ver[j];                    if(!f1[i-1][x][state]) continue ;                    f1[i][y][(state&lt;&lt;1)|edg[j]]|=f1[i-1][x][state];                &#125;            &#125;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=head[i];j;j=nxt[j])&#123;            ll y=ver[j];            f2[1][y][edg[j]]=1;        &#125;    &#125;//    printf(&quot;f2[1][1][1]=%lld\n&quot;,1ll*f2[1][1][1]);    for(ll i=2;i&lt;=d2;i++)&#123;        for(ll state=0;state&lt;=((1&lt;&lt;i)-1);state++)&#123;            for(ll x=1;x&lt;=n;x++)&#123;                for(ll j=head[x];j;j=nxt[j])&#123;                    ll y=ver[j];                    if(!f2[i-1][x][state]) continue ;                    //                    printf(&quot;f2[%lld][%lld][%lld]=%lld\n&quot;,i-1,x,state,1ll*f2[i-1][x][state]);                    f2[i][y][(state&lt;&lt;1)|edg[j]]|=f2[i-1][x][state];//                    printf(&quot;f2now[%lld][%lld][%lld]=1\n&quot;,i,y,(state&lt;&lt;1)|edg[j]);                &#125;            &#125;        &#125;    &#125;    for(ll state=0;state&lt;=maxn1;state++)&#123;        for(ll state1=0;state1&lt;=maxn2;state1++)            for(ll i=1;i&lt;=n;i++)&#123;//                printf(&quot;f1[%lld][%lld][%lld]=%lld f2[%lld][%lld][%lld]=%lld state1=%lld\n&quot;,d1,i,state,1ll*f1[d1][i][state],d2,i,state1,1ll*f2[d2][i][state1],maxn2);                if(f1[d1][i][state]&amp;&amp;f2[d2][i][state1])&#123;                    ll sum=state&lt;&lt;d2|state1;//                    printf(&quot;***** i=%lld state=%lld state2=%lld\n&quot;,i,state,state1);//                    turn(sum,1);//                    printf(&quot;\n&quot;);                    if(!hash_map[sum])                        hash_map[sum]=1,ans++;                &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="v"><a href="#v" class="headerlink" title="v"></a>v</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191001214141242-1713474976.png"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>记忆化搜索+hash表</p><p>关于题目中说的编号右移,二进制下模拟一下就行了</p><pre><code>        st3=(st&gt;&gt;(l-p+1)&lt;&lt;(l-p))|((st&amp;((1&lt;&lt;(l-p))-1)));</code></pre><p>先右移再左移消掉这一位,然后后面保持原样</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define mod 19260817struct hash_map&#123;    ll head[mod],nxt[mod],ver[mod];    ll cnt;    short len,L[mod];    double val[mod];    double &amp;operator [] (const ll &amp; st)&#123;        int x=1ll*st*len%mod;        for(ll i=head[x];i;i=nxt[i])            if(ver[i]==st&amp;&amp;L[i]==len)                return val[i];        nxt[++cnt]=head[x],head[x]=cnt,ver[cnt]=st,L[cnt]=len,val[cnt]=-1;        return val[cnt];    &#125;&#125;f;ll n,k;char c[33];double dfs(ll l,ll st)&#123;    if(l==n-k) return 0;    f.len=l;    if(f[st]&gt;-0.5) return f[st];    ll lst[33];    ll rst=st;    f[st]=0;    for(ll i=1;i&lt;=l;i++) lst[i]=rst&amp;1,rst&gt;&gt;=1;    for(ll i=1;i&lt;=l/2;i++)&#123;        ll j=l-i+1,st1=(st&gt;&gt;(l-i+1)&lt;&lt;(l-i))|(st&amp;((1&lt;&lt;(l-i))-1)),st2=(st&gt;&gt;(l-j+1)&lt;&lt;(l-j))|(st&amp;((1&lt;&lt;(l-j))-1));        double ans1=dfs(l-1,st1)+lst[j],ans2=dfs(l-1,st2)+lst[i];        f.len=l;f[st]+=2.0/((double)l)*max(ans1,ans2);    &#125;    if(l&amp;1)&#123;        ll p=l/2+1,st3=(st&gt;&gt;(l-p+1)&lt;&lt;(l-p))|((st&amp;((1&lt;&lt;(l-p))-1)));        double ans3=dfs(l-1,st3)+lst[p];        f.len=l;f[st]+=1.0/l*ans3;    &#125;    return f[st];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    scanf(&quot;%s&quot;,c+1);    ll st=0,cnt=0;    for(ll i=1;i&lt;=n;i++)&#123;        st=((st&lt;&lt;1)|(c[i]==&#39;W&#39;));        if(c[i]==&#39;W&#39;) cnt++;    &#125;    if(k==n)&#123;        printf(&quot;%d\n&quot;,cnt);        return 0;    &#125;    printf(&quot;%.8lf\n&quot;,dfs(n,st));&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>usaco Cow Pedigrees</title>
      <link href="/2025/03/14/usaco%20Cow%20Pedigrees/"/>
      <url>/2025/03/14/usaco%20Cow%20Pedigrees/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-14 21:45</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有n个节点二叉树,每个节点有0\2个儿子,给定最大深度k,求方案数%9901</p><p>n&lt;&#x3D;500</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$dp$定义很</p><p>$f[i][j]$表示i个节点组成至多j层方案数</p><p>考虑答案</p><p>$f[n][k]$表示包含$1-k$所有层数方案数</p><p>$f[n][k-1]$表示包含$1-(k-1)$所有层数方案数</p><p>于是$f[n][k]-f[n][k-1]$就是答案</p><p>转移就是枚举除了根节点分给两个子树多少个</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define mod 9901ll f[520][520];ll n,k;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);    for(ll i=1;i&lt;=k;i++)        f[1][i]=1;    for(ll i=1;i&lt;=k;i++)        for(ll j=3;j&lt;=n;j+=2)            for(ll q=1;q&lt;j;q+=2)                (f[j][i]+=(f[j-q-1][i-1]*f[q][i-1])%mod)%=mod;    printf(&quot;%lld\n&quot;,(f[n][k]-f[n][k-1]+mod)%mod);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="/2025/03/14/tree/"/>
      <url>/2025/03/14/tree/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-25 18:19</p><p>随机走,看期望</p><p>由于zzn过于sb,考试推出来式子因为统计时间不对没有$AC$(应dfs前统计)</p><p>zzn实在过于sb,式子和题解完全不一样,所以看题解的可以走了</p><p>记录tofa[x]表示当前点走到父亲期望步数</p><p>可以直接走到父亲 贡献$\frac{1}{deg[x]}$</p><p>走到儿子再走到父亲$\frac{1}{deg[x]}*(1+tofa[y]+tofa[x])<br>$解释一下,花一步走到$y$,花$tofa[y]$走到$x$最后还是要走到$fa$</p><p>总$tofa[x]&#x3D;\frac{1}{deg[x]}+\sum\limits_{y}^{y\in son[x]} \frac{1}{deg[x]}<br>(1+tofa[y]+tofa[x])$</p><p>记录toson[x]表示从父亲走到x步数</p><p>考虑toson[y]转移</p><p>从$x$直接走到$y$ $\frac{1}{deg[x]}$</p><p>走到$x$父亲再走到$y$ $\frac{1}{deg[x]}*(toson[x]+1+toson[y])$</p><p>走到$y$兄弟走到$y$ $\frac{1}{deg[x]}*(1+tofa[y]+toson[y])$</p><p>总$toson[y]&#x3D;\frac{1}{deg[x]}+\frac{1}{deg[x]}*(toson[x]+1+toson[y])<br>+\sum\limits_{y2}^{y2\in son[x] &amp; y2!&#x3D;y} *(1+tofa[y2]+toson[y])$</p><p>然后移项</p><p>$tofa[x]&#x3D;deg[x]+\sum\limits_{y}^{y\in son[x]}tofa[y]$</p><p>$toson[y]&#x3D;deg[x]+toson[x]+\sum\limits_{y2}^{y2\in son[x] &amp; y2!&#x3D;y} tofa[y2]$</p><p>统计即可</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 222222ll n,tot,canqj;ll vis[A],nxt[A],head[A],ver[A];double f[A],dis[A],tofa[A],toson[A],deg[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void dfs(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        f[y]=2+f[x];        dis[y]=dis[x]+f[x];        dfs(y,x);    &#125;&#125;void dpfs1(ll x,ll pre)&#123;    tofa[x]=deg[x];    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dpfs1(y,x);        tofa[x]+=tofa[y];    &#125;//    printf(&quot;tofa[%lld]=%.3lf\n&quot;,x,tofa[x]);&#125;void dpfs2(ll x,ll pre)&#123;    ll sum=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        toson[y]=deg[x]+toson[x];        sum+=tofa[y];//        printf(&quot;toson[%lld]=%.3lf\n&quot;,y,toson[y]);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        toson[y]+=sum-tofa[y];//        printf(&quot;toson[%lld]=%.3lf\n&quot;,y,toson[y]);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dpfs2(y,x);    &#125;&#125;void dfs3(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dis[y]=dis[x]+toson[y];        dfs3(y,x);        //        printf(&quot;dis[%lld]=%.3lf  dis[%lld]=%.3lf\n&quot;,y,dis[y],x,dis[x]);    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    f[1]=1;    dis[1]=1;    canqj=1;    for(ll i=1,a,b;i&lt;n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);        deg[a]++,deg[b]++;        if(deg[a]&gt;2||deg[b]&gt;2) canqj=0;    &#125;/*    dfs(1,0);    for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;%.3lf\n&quot;,dis[i]);    &#125;        */    for(ll i=head[1];i;i=nxt[i])&#123;        ll y=ver[i];        toson[y]=1;    &#125;    for(ll i=2;i&lt;=n;i++)&#123;        if(deg[i]==1)&#123;            tofa[i]=1;        &#125;    &#125;//    memset(dis,0,sizeof(dis));    dis[1]=1;    dpfs1(1,0);    dpfs2(1,0);    dfs3(1,0);    for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;%.3lf\n&quot;,dis[i]);    &#125;//    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sum「莫队」</title>
      <link href="/2025/03/14/sum%E3%80%8C%E8%8E%AB%E9%98%9F%E3%80%8D/"/>
      <url>/2025/03/14/sum%E3%80%8C%E8%8E%AB%E9%98%9F%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-09 19:39</p><p>在格尔巴乔夫新思维带领下数学题也可以用莫队了</p><p>觉得思路很棒,主要是莫队思想在数学题上应用</p><p>题目让求的是$\sum\limits_{i&#x3D;0}^{i&lt;&#x3D;m} C_{n}^{m}$十万组询问,$n,m$范围十万</p><p>设$S_{n}^{m}&#x3D;\sum\limits_{i&#x3D;0}^{i&lt;&#x3D;m} C_{n}^{m}$,</p><p>根据定义$S_{n}^{m}&#x3D;S_{n}^{m-1}+C_{n}^{m}$</p><p>又因为$C_{n}^{m}+C_{n}^{m-1}&#x3D;C_{n+1}^{m}$</p><p>把上面柿子展开得到$S_{n}^{m}&#x3D;2*S{n-1}^{m}-C(n-1,m)$</p><p>于是就可以愉快的莫队了</p><p>$S_{l}^{r}&#x3D;2*S_{l}^{r-1}-C_{r-1}^{l}$</p><p>$S_{l}^{r}&#x3D;S_{l-1}^{r}+C_{r,l}$</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111const ll mod=1e9+7;ll id,q,n,m,l=1,r=0;ll ans=1,t;ll jie[A],ni[A],realans[A],belong[A];struct node&#123;    ll l,r,id;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return belong[a.l]==belong[b.l]?a.r&lt;b.r:a.l&lt;b.l;    &#125;&#125;mo[A];ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;ll C(ll x,ll y)&#123;    return jie[x]*ni[y]%mod*ni[x-y]%mod;&#125;//s_n,m=2*s_n-1,m-C(n-1,m)//s_r,l=2*s_r-1,l-C(r-1,l)//s_r,l=s_r,l-1+C(r,l)//S_l,r=2*S_l,r-1-C(r-1,l)//S_l,r=S_l-1,r+C(r,l)int main()&#123;    scanf(&quot;%lld&quot;,&amp;id);    scanf(&quot;%lld&quot;,&amp;q);    jie[0]=ni[0]=1;    t=sqrt(100000);    for(ll i=1;i&lt;=100100;i++)        jie[i]=jie[i-1]*i%mod,belong[i]=(i-1)/t+1;    ni[100100]=meng(jie[100100],mod-2);    for(ll i=100099;i&gt;=1;i--)        ni[i]=ni[i+1]*(i+1)%mod;    for(ll i=1;i&lt;=q;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;mo[i].r,&amp;mo[i].l);        mo[i].id=i;    &#125;    sort(mo+1,mo+q+1);    for(ll i=1;i&lt;=q;i++)&#123;        while(l&lt;mo[i].l) l++,ans=(ans+C(r,l))%mod;        while(l&gt;mo[i].l) ans=(ans-C(r,l)+mod)%mod,l--;        while(r&lt;mo[i].r) r++,ans=(2*ans-C(r-1,l)+mod)%mod;        while(r&gt;mo[i].r) ans=(((ans+C(r-1,l)))*meng(2,mod-2))%mod,r--;//        printf(&quot;n=%lld m=%lld ans=%lld\n&quot;,mo[i].r,mo[i].l,ans);        realans[mo[i].id]=ans;    &#125;    for(ll i=1;i&lt;=q;i++)&#123;        printf(&quot;%lld\n&quot;,realans[i]);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>simple,跳楼机,[同余系最短路]</title>
      <link href="/2025/03/14/simple,%E8%B7%B3%E6%A5%BC%E6%9C%BA,%5B%E5%90%8C%E4%BD%99%E7%B3%BB%E6%9C%80%E7%9F%AD%E8%B7%AF%5D/"/>
      <url>/2025/03/14/simple,%E8%B7%B3%E6%A5%BC%E6%9C%BA,%5B%E5%90%8C%E4%BD%99%E7%B3%BB%E6%9C%80%E7%9F%AD%E8%B7%AF%5D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-09 09:25</p><p>觉得之前写的跟shi一样，看了我博客的都更懵逼了，重写一部分</p><h2 id="同余系最短路"><a href="#同余系最短路" class="headerlink" title="同余系最短路"></a>同余系最短路</h2><p>Q:同余系是什么</p><p>A:所谓同余系最短路并不是拿同余方程跑最短路,而是跑最短路用同余方程优化</p><p>暴力的话就是暴力建边然后跑最短路,然而这样你肯定不行</p><p>Q:为什么要最短路</p><p>A:假设现在有$a,b,c,Z,e,f$</p><p>$a$是$a,b,c$中最小的</p><p>现在$e&#x3D;a<em>x_1+Z$,$f&#x3D;a</em>x_2+Z$</p><p>现在有$e&lt;f$,那么有$e+a*y&#x3D;f$</p><p>那么e+a可以凑出来的一些数,f是根本凑不出来的</p><p>e可以表示更多数</p><p>最短路中dis[o]中o对应的是e,o对应的是Z,我们把Z抽象成一个个位置,这样跑最短路找到用b,c可以凑出%a意义下为u的最小值</p><p>实际比如现在有一个数w,先%a得出i,那么dis[i]&lt;&#x3D;w表示可以凑出来(i可以通过加若干个a得到w),dis[i]若&gt;w表示怎么样也凑不出来(越加越大),</p><p>所以要最短路</p><p>Q:为什么是对的</p><p>A:%a得到(0-a-1)可以证明+若干a达到1-正无穷每个数</p><p>解决了上述问题开始看几道题</p><h2 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这里给出一种傻逼做法,同余系最短路,</p><p>考虑简单容斥,拿$q-可以达到的解$</p><p>在得出一个可以达到的解我们可以任意拓展+任意多别的数达到其他值,我们可以利用这一优良性质</p><p>例如现在有$x&#x3D;1,y&#x3D;3$,$y$可以达到$3$那么我们可以$3+1<em>x,3+2</em>x,3+3*x$得到其他所有解,剩余还能有解的个数就是$(q-dis[i])&#x2F;x+1$</p><p>于是构造在同余于$x$下的同余系,$dis[i]$表示 <em><strong>不用</strong></em><br>$x$在$%x后&#x3D;i$需要的最少步数(例如现在有$x$,$y$,$z$,构造同余系$dis[i]$表示单纯用$y,z$到达$i$的最小步数)</p><p>为什么要$dis[i]$尽量小,$dis[i]$达到高度小,我们就可以用更多$x$来填充剩下路径</p><p>考虑暴力$dp$ $dis[(i+y)%x]&#x3D;min(dis[i]+y)$,形式相当于最短路形式,建从$i-&gt;(i+y)%x$边跑$spfa$即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 555555ll head[A],nxt[A],ver[A],edg[A],dis[A],vis[A];ll t,tot,n,m,q;void add(ll x,ll y,ll z)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y,edg[tot]=z;&#125;void spfa(ll o)&#123;    memset(dis,63,sizeof(dis));    memset(vis,0,sizeof(vis));    deque&lt;ll&gt; q;    dis[0]=0;    vis[0]=1;    q.push_back(0);    while(!q.empty())&#123;        ll x=q.front();        q.pop_front();        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i];            if(dis[y]&gt;dis[x]+edg[i])&#123;                dis[y]=dis[x]+edg[i];                if(!vis[y])&#123;                    vis[y]=1;                    q.push_back(y);                &#125;            &#125;        &#125;        vis[x]=0;    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;q);        if(n&gt;m) swap(n,m);//n较小值        memset(head,0,sizeof(head));        memset(nxt,0,sizeof(nxt));        tot=0;        for(ll i=0;i&lt;n;i++)&#123;            add(i,(i+m)%n,m);        &#125;        spfa(0);        ll ans=0;        for(ll i=0;i&lt;n;i++)&#123;            if(dis[i]&lt;=q)            ans+=(q-dis[i])/n+1;        &#125;        ans--;        printf(&quot;%lld\n&quot;,q-ans);    &#125;&#125;</code></pre><p>View Code</p><h2 id="跳楼机"><a href="#跳楼机" class="headerlink" title="跳楼机"></a>跳楼机</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>求$k_1<em>x+k_2</em>y+k_3*z&#x3D;[1,q]$解个数</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>同样构造同余系最短路,$dis[i]$和上面定义类似,只用$y,z$走到的点$%x&#x3D;i$需要最短距离,</p><p>连边$add(i,(i+y)%x,y)$,$add(i,(i+z)%x,z)$求解,从当前点走还能走多少步$\sum\limits_{i&#x3D;0}^{i&lt;x}<br>(q-dis[i])&#x2F;x+1$</p><p>代码和上面基本一样不放了</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>可以同余系最短路做，套路和上面一样</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define fhAK 666666ll bag[fhAK],val[fhAK],flag[fhAK],tim[fhAK];ll n,m,pos,L,C;int main()&#123;    ll mod=0x7fffffffff;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;val[i]);        mod=min(mod,val[i]);    &#125;    sort(val+1,val+n+1);    memset(bag,0x3f,sizeof(bag));    memset(tim,0x3f,sizeof(tim));    scanf(&quot;%lld%lld&quot;,&amp;L,&amp;C);        pos=n;    for(ll i=1;i&lt;=n;i++)&#123;        if(val[i]&gt;=L)&#123;            pos=i-1;            break;        &#125;    &#125;    deque&lt;ll&gt; q;    bag[0]=0,tim[0]=0;    q.push_back(0);    while(!q.empty())&#123;        ll x=q.front();        q.pop_front();        flag[x]=0;        for(ll i=1;i&lt;=n;i++)&#123;            ll tmp=(x+val[i])%mod;            if(i&gt;pos&amp;&amp;tim[x]==C) break ;            if(bag[tmp]&gt;bag[x]+val[i])&#123;                bag[tmp]=bag[x]+val[i];                if(i&gt;pos) tim[tmp]=tim[x]+1;                else tim[tmp]=tim[x];                if(!flag[tmp])&#123;                    q.push_back(tmp);                    flag[tmp]=1;                &#125;            &#125;            else if(bag[tmp]==bag[x]+val[i])&#123;                if(i&lt;=pos)&#123;                    if(tim[tmp]&gt;tim[x])&#123;                        tim[tmp]=tim[x];                        if(!flag[tmp])&#123;                            q.push_back(tmp);                            flag[tmp]=1;                        &#125;                    &#125;                &#125;                else&#123;                     if(tim[tmp]&gt;tim[x]+1)&#123;                        tim[tmp]=tim[x]+1;                        if(!flag[tmp])&#123;                            q.push_back(tmp);                            flag[tmp]=1;                        &#125;                    &#125;                &#125;            &#125;        &#125;     &#125;     for(ll i=1;i&lt;=m;i++)&#123;         ll w,x;         scanf(&quot;%lld&quot;,&amp;x);         w=x%mod;         if(bag[w]&lt;=x)         printf(&quot;Yes\n&quot;);         else printf(&quot;No\n&quot;);     &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redundant Paths 分离的路径</title>
      <link href="/2025/03/14/Redundant%20Paths%20%E5%88%86%E7%A6%BB%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2025/03/14/Redundant%20Paths%20%E5%88%86%E7%A6%BB%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-14 06:22</p><h1 id="Redundant-Paths-分离的路径"><a href="#Redundant-Paths-分离的路径" class="headerlink" title="Redundant Paths 分离的路径"></a>Redundant Paths 分离的路径</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>为了从F(1≤F≤5000)个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树．奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择．<br>每对草场之间已经有至少一条路径．给出所有R(F-1≤R≤10000)条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量,<br>路径由若干道路首尾相连而成．两条路径相互分离，是指两条路径没有一条重合的道路．但是，两条分离的路径上可以有一些相同的草场．<br>对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路．</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行输入F和R，接下来R行，每行输入两个整数，表示两个草场，它们之间有一条道路．</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>最少的需要新建的道路数．</p><p>首先我们容易得出一个结论，环上任意两点都有两条分离路径</p><p>然后我们如果将这个图缩点后将会得到一个新图，（先缩点为敬）</p><p>我们需要添加路径使变成边双连通图，边双连通图上每一条边都一定在一个环内，我们让每两个叶子节点连边使它构成环就行了。</p><p>那么问题就变成了求叶子节点个数。</p><p>然后如果叶子数为奇数我们需要再将这个点与任意一个点相连。（叶子+1）&#x2F;2就完了</p><p>如果为偶数直接就是（叶子）&#x2F;2</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 2000000#define read(a) scanf(&quot;%lld&quot;,&amp;a)#define put(a) printf(&quot;%lld\n&quot;,a)using namespace std;map&lt;pair&lt;ll,ll&gt;,bool&gt; mp;ll low[A],size[A],dfn[A],head[A],ver[A],nxt[A],cut[A],ans[A],sz[A];ll ver2[A],nxt2[A],head2[A],out[A],belong[A],sta[A],ru[A],sb=0;string s;bool ins[A],flag[A],via[A];vector&lt;ll&gt; scc[A];ll n,m,num=0,root,top=0,tot=0,tot2=0,sum=0,cnt=0;void add2(ll x,ll y)&#123;    ver2[++tot2]=y;nxt2[tot2]=head2[x];head2[x]=tot2;out[x]++;ru[y]++;return ;&#125;void add(ll x,ll y)&#123;    ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;return ;&#125;inline void rebuilt()&#123;    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=head[i];j;j=nxt[j])&#123;            ll y=ver[j];            if(y!=i)            if(belong[i]!=belong[y]/*&amp;&amp;*/)                add2(belong[i],belong[y])/*,,,printf(&quot;belong i=%lld,belong y=%lld\n&quot;,belong[i],belong[y])*/;        &#125;    &#125;&#125;void tarjan(ll x,ll pre)&#123;    low[x]=dfn[x]=++num;    sta[++top]=x;ins[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue;        if(!dfn[y])&#123;            tarjan(y,x);            low[x]=min(low[x],low[y]);        &#125;        else if(ins[y])&#123;            low[x]=min(low[x],dfn[y]);        &#125;    &#125;    if(dfn[x]==low[x])&#123;        ++cnt;ll yy=0;        while(1)&#123;            yy=sta[top--];            ins[yy]=0;            belong[yy]=cnt;            sz[cnt]++;            scc[cnt].push_back(yy);            if(yy==x) break;        &#125;    &#125;&#125;void shuchu()&#123;        for(ll i=1;i&lt;=cnt;i++)        &#123;//            printf(&quot;第%lld个scc  size=%lld\n&quot;,i,sz[i]);            for(ll j=0;j&lt;scc[i].size();j++)            &#123;                cout&lt;&lt;scc[i][j]&lt;&lt;&quot; &quot;;            &#125;            cout&lt;&lt;endl;        &#125;&#125;void dfs(ll x)&#123;    flag[x]=1;if(ru[x]==1) sb++;    for(ll i=head2[x];i;i=nxt2[i])&#123;        ll y=ver2[i];//        printf(&quot;x=%lld y=%lld outx=%lld\n&quot;,x,y,out[x]);        if(flag[y]) continue;        dfs(y);    &#125;&#125;int main()&#123;        read(n);read(m);        for(ll i=1;i&lt;=m;i++)&#123;            ll xx,yy;read(xx),read(yy);            if(!mp[make_pair(xx,yy)]&amp;&amp;!mp[make_pair(yy,xx)])            &#123;                add(xx,yy);add(yy,xx);mp[make_pair(xx,yy)]=1,mp[make_pair(yy,xx)]=1;            &#125;        &#125;        for(ll i=1;i&lt;=n;i++)            if(!dfn[i])root=i,tarjan(i,0);                rebuilt();//        shuchu();        for(ll i=1;i&lt;=cnt;i++)        &#123;//            printf(&quot;ru%lld=%lld\n&quot;,i,ru[i]);            if(ru[i]==1) sb++;        &#125;        cout&lt;&lt;(sb+1)/2&lt;&lt;endl;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rectangle</title>
      <link href="/2025/03/14/rectangle/"/>
      <url>/2025/03/14/rectangle/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-03 11:46</p><p>我颓代码了,我不是人</p><p>要是不颓代码我绝对不会想到树状数组可以这么搞</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191003110536432-950445581.png"></p><p>$n&lt;&#x3D;10000,m&lt;&#x3D;2500$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$2^n$算法,枚举子集</p><p>$n^4$算法,枚举四个点,这样绝对不重不漏</p><p>$n^2*log$算法,一层循环枚举$l$这一列,一层循环枚举$r$,这一列</p><p>考虑如何计算卡在$l,r$之间的值,考虑枚举上边界(这里所说的上边界就是$l$对应列,$r$对应列上的所有点,按照$y$排序后从小到大枚举点)</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191003112807492-866274401.png"></p><p>数字是枚举顺序</p><p>考虑上边界和下边界之间贡献</p><p>设上边界$y1$,下边界$y2$,之间点个数为$cnt$,下面有$w$个点</p><p>之间每个点都会与下面点形成新的矩形,那么这样贡献就是$\sum\limits_{ynow}^{y1&lt;&#x3D;ynow&lt;&#x3D;y2}$<br>$\sum\limits_{ypre}^{ypre&lt;y1} (ynow -ypre)*(r-l)$(之前每个矩形都可以扩大这些)</p><p>那么现在我们要快速查$ynow$-$ypre$不同值的和</p><p>树状数组即可</p><p>这里,树状数组实现很$sb$,然后求出来这之间$y$之和,再$-$下面所有$y$下标,这样得到了真实长度,</p><p>给一下实现,$ask2$是求和,$ask1$是求个数</p><p>1<br>(ans+&#x3D;((ask2(nxt-1)-ask2(cur-1))*ask1(down)%mod-((ask1(nxt-1)-ask1(cur-1)))<em>ask2(down)%mod)</em>(i-j))%mod;</p><p>$(ask2(nxt-1)-ask2(cur-1))*ask1(down)$是求出来这一段下标之和,每一个下面的点都会有$ask2(nxt-1)-ask2(cur-1)$贡献,$(ask1(nxt-1)-ask1(cur-1)))*ask2(down)$是求出来下面下标和,每一个点下面下标和即为$ask2$</p><p>大致长这样</p><p>这里实现还有一些小注意点,</p><p>1.枚举$r$然后你从大到小枚举$l$这样你每次树状数组不用再清空可以重复利用上次值</p><p>2.枚举上边界可以单调指针扫</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2510#define fi first#define se second#define m 2500const ll mod=1e9+7;ll f[A][A],cnt[A],sum[A],vec[A][A],c[A],vis[A];ll ans,n;ll ask1(ll x)&#123;    ll ans=0;    for(ll i=x;i&gt;=1;i-=i&amp;-i)        ans+=cnt[i];    return ans;&#125;ll ask2(ll x)&#123;    ll ans=0;    for(ll i=x;i&gt;=1;i-=i&amp;-i)        ans+=sum[i];    return ans;&#125;//1个数,2总和void add1(ll x,ll d)&#123;    for(ll i=x;i&lt;=m;i+=i&amp;-i)        cnt[i]+=d;&#125;void add2(ll x,ll d)&#123;    for(ll i=x;i&lt;=m;i+=i&amp;-i)        sum[i]+=d;&#125;void update(ll x)&#123;    if(vis[x]) return ;    //printf(&quot;i=%lld\n&quot;,x),    vis[x]=1;    add1(x,1);add2(x,x);&#125;void init()&#123;    memset(sum,0,sizeof(sum));    memset(cnt,0,sizeof(cnt));    memset(vis,0,sizeof(vis));&#125;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1,x,y;i&lt;=n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);        vec[x][++c[x]]=y;    &#125;        for(ll i=1;i&lt;=m;i++)&#123;        sort(vec[i]+1,vec[i]+c[i]+1);        vec[i][c[i]+1]=m+1;    &#125;    for(ll i=1;i&lt;=m;i++)&#123;//枚举上边界,然后更新数组        printf(&quot;%lld\n&quot;,i);        if(c[i])&#123;            init();            for(ll j=1;j&lt;=c[i];j++) update(vec[i][j]);            for(ll j=i-1;j&gt;=1;j--)&#123;//                printf(&quot;j=%lld\n&quot;,j);                if(c[j])&#123;                    ll ita=1,itb=1,cur=max(vec[i][ita],vec[j][itb]);                    for(ll k=1;k&lt;=c[j];k++) update(vec[j][k]);//                    printf(&quot;ita=%lld itb=%lld cur=%lld\n&quot;,ita,itb,cur);                    while(vec[i][ita+1]&lt;=cur) ita++;                    while(vec[j][itb+1]&lt;=cur) itb++;                    while(ita&lt;=c[i]&amp;&amp;itb&lt;=c[j])&#123;                        ll nxt=min(vec[i][ita+1],vec[j][itb+1]),down=min(vec[i][ita],vec[j][itb]);//上边界                        (ans+=((ask2(nxt-1)-ask2(cur-1))*ask1(down)%mod-((ask1(nxt-1)-ask1(cur-1)))*ask2(down)%mod)*(i-j))%mod;                        //sb容斥                        cur=nxt;                        if(vec[i][ita+1]&lt;=cur) ita++;                        if(vec[j][itb+1]&lt;=cur) itb++;                    &#125;                &#125;            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>qgc 编译运行</title>
      <link href="/2025/03/14/qgc%20%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/"/>
      <url>/2025/03/14/qgc%20%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>归档于  2023-03-27 21:46</p><p>实际是吐槽，并不是教程</p><h2 id="wsl2上"><a href="#wsl2上" class="headerlink" title="wsl2上"></a>wsl2上</h2><p>qt编译安装过程按照某博客来的基本没什么问题<br>编译安装源码后发现少组件，安装了两个之后，剩下的github里没找到，没法编译安装，而且没有Maintenance，最后charts和texttospeech没法处理放弃了</p><h2 id="windows上"><a href="#windows上" class="headerlink" title="windows上"></a>windows上</h2><p>呃，一开始版本不对，qgc至少得要5.15版本的qt，然后又去更新<br>觉得更新可能会出问题，又直接卸载重装了5.15.即使用了梯子等，速度还是奇慢无比50kb&#x2F;s</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>purfer序列</title>
      <link href="/2025/03/14/purfer%E5%BA%8F%E5%88%97/"/>
      <url>/2025/03/14/purfer%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-21 14:54</p><h2 id="prufer序列求法"><a href="#prufer序列求法" class="headerlink" title="prufer序列求法"></a>prufer序列求法</h2><p>对于一个无根无向图我们可以应用prufer序列操作使它缩成一个序列。</p><p>具体操作</p><p>一，每次选出来树中编号最小的点且度数为一（即叶子节点）</p><p>二，将与被删去的点相连的节点加入prufer序列中</p><p>重复一，二，操作直到只剩下两个点（具体为什么剩下两个点在后文）</p><h2 id="将prufer序列转换为树"><a href="#将prufer序列转换为树" class="headerlink" title="将prufer序列转换为树"></a>将prufer序列转换为树</h2><p>因为prufer与一颗无根树一一对应，所以对于一个prufer序列我们还可以把它还原成无根树</p><p>具体操作</p><p>设prufer序列长度为len</p><p>设定一个序列s为$1,2,3,…… len+2$</p><p>每次取prufer序列的队头为pfrist</p><p>在s中寻找一个满足prufer中不含你所选的数的<strong>最小</strong> 数</p><p>将pfrist与你选的数连边，将s中你选的数删去，</p><p>每次进行该操作，直到s剩下最后两个数时再将剩下的两个数之间连边</p><p>经过这样的操作就得到了一棵树</p><p>例如prufer序列为1 2 2，s序列为 1 2 3 4 5</p><p>先让1和3连边，</p><p>此时prufer序列剩下2 2 ，s剩下 1 2 4 5</p><p>再让2和1连边</p><p>此时prufer序列剩下2 ，s剩下 2 4 5</p><p>然后再让2与4连边</p><p>s剩下2 5 2 5之间再连边</p><p>因为只用n-2个数就可以确定一棵树，所以如果将一个树转换为prufer序列剩下两个点再加入prufer中是没有意义的</p><h2 id="prufer序列性质"><a href="#prufer序列性质" class="headerlink" title="prufer序列性质"></a>prufer序列性质</h2><p>一，一棵无根树共有$n^{n-2}$种</p><p>因为prufer序列中数唯一对应一棵树</p><p>，对于prufer序列共有n-2个数，每个数可以是1-n中任何一个数，所以得到$n^{n-2}$</p><p>二，prufer序列中每个点出现次数为该点在无根树中度数-1</p><p>观察我们将树转化为prufer序列过程可以得到二</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h5 id="明明的烦恼（待做）"><a href="#明明的烦恼（待做）" class="headerlink" title="明明的烦恼（待做）"></a>明明的烦恼（待做）</h5><h5 id="树的统计"><a href="#树的统计" class="headerlink" title="树的统计"></a>树的统计</h5><p>题解：<a href="https://www.cnblogs.com/znsbc-13/p/11222262.html">https://www.cnblogs.com/znsbc-13/p/11222262.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试49·50「养花·折射·画作·施工·蔬菜·联盟」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9549%C2%B750%E3%80%8C%E5%85%BB%E8%8A%B1%C2%B7%E6%8A%98%E5%B0%84%C2%B7%E7%94%BB%E4%BD%9C%C2%B7%E6%96%BD%E5%B7%A5%C2%B7%E8%94%AC%E8%8F%9C%C2%B7%E8%81%94%E7%9B%9F%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9549%C2%B750%E3%80%8C%E5%85%BB%E8%8A%B1%C2%B7%E6%8A%98%E5%B0%84%C2%B7%E7%94%BB%E4%BD%9C%C2%B7%E6%96%BD%E5%B7%A5%C2%B7%E8%94%AC%E8%8F%9C%C2%B7%E8%81%94%E7%9B%9F%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-24 17:52</p><p>一套题</p><h2 id="养花"><a href="#养花" class="headerlink" title="养花"></a>养花</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>分块\主席树</p><p>这里我用的是主席树</p><p>查询分段$1-(k-1)$找最大的,能向右找就向右找</p><pre><code>        for(ll nowl=1,nowr=k-1;nowl&lt;=maxx;nowl+=k,nowr+=k,nowr=min(nowr,maxx))        &#123;            if(ans==mod-1) break;            chose(rt[r],rt[l-1],nowl,nowr,1,maxx);        &#125;</code></pre><p>复杂度分析,调和级数$√n*log(n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define rs(x) tr[x].son[1]#define ls(x) tr[x].son[0]#define A 10000000struct tree&#123;    ll son[2],sz;&#125;tr[A];ll tot,n,m,ans,maxx,mod;ll a[500000],rt[500000];void insert(ll &amp;p,ll v,ll num,ll l,ll r)&#123;    if(!p) p=++tot;    if(l==r) &#123;        tr[p].sz=tr[v].sz+1;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    ll opt=num&gt;mid,L,R;    if(opt) L=mid+1,R=r;    else L=l,R=mid;    tr[p].son[opt^1]=tr[v].son[opt^1];    insert(tr[p].son[opt],tr[v].son[opt],num,L,R);    tr[p].sz=tr[ls(p)].sz+tr[rs(p)].sz;&#125;void find(ll p,ll v,ll l,ll r)&#123;        if(r%mod&lt;ans) return ;//    printf(&quot;l=%d r=%d\n&quot;,l,r);    if(l==r)&#123;        ans=max(ans,l%mod);        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    if(tr[rs(p)].sz-tr[rs(v)].sz) find(rs(p),rs(v),mid+1,r);    else if(tr[ls(p)].sz-tr[ls(v)].sz)find(ls(p),ls(v),l,mid);&#125;void chose(ll p,ll v,ll ql,ll qr,ll l,ll r)&#123;    if(tr[p].sz-tr[v].sz==0)return ;    if(l&gt;=ql&amp;&amp;r&lt;=qr)&#123;        find(p,v,l,r);        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    if(mid&gt;=ql) chose(ls(p),ls(v),ql,qr,l,mid);    if(mid&lt;qr) chose(rs(p),rs(v),ql,qr,mid+1,r);&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%d&quot;,&amp;a[i]);        maxx=max(a[i],maxx);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        insert(rt[i],rt[i-1],a[i],1,maxx);    &#125;    for(ll i=1,l,r,k;i&lt;=m;i++)&#123;        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);        ans=0;        mod=k;        for(ll nowl=1,nowr=k-1;nowl&lt;=maxx;nowl+=k,nowr+=k,nowr=min(nowr,maxx))        &#123;            if(ans==mod-1) break;            chose(rt[r],rt[l-1],nowl,nowr,1,maxx);        &#125;        printf(&quot;%d\n&quot;,ans);    &#125;&#125;</code></pre><p>View Code</p><h2 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$n^2,dp$</p><p>$f[i][0&#x2F;1]$表示向左延伸的光线,向右延伸的光线</p><p>按照$x$排序,然后考虑转移</p><p>枚举比当前点小的点$j$</p><p>若$j.y&gt;i.y$</p><p>$f[j][1]+&#x3D;f[i][0]$</p><p>$j.y&lt;i.y$</p><p>$f[i][0]+&#x3D;f[j][1]$</p><p>你会发现这样转移会有不和法的</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190924174801778-317632606.png"></p><p>不要容斥,更改枚举顺序从大到小枚举</p><p>设最上点$x$,中间点为$y$,下面点为$z$</p><p>假设这次$y$贡献要加$1$,$x$加上$f[y]$如果是逆序就没加上当前贡献</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 6100const ll mod=1e9+7;ll f[A][2];ll n,ans;struct node&#123;    ll x,y;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.x&lt;b.x;    &#125;&#125;poi[A];int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;poi[i].x,&amp;poi[i].y);    &#125;    sort(poi+1,poi+n+1);    for(ll i=1;i&lt;=n;i++)&#123;        f[i][0]=f[i][1]=1;        for(ll j=i-1;j&gt;=1;j--)&#123;            if(poi[j].y&gt;poi[i].y)                (f[j][1]+=f[i][0])%=mod;            else (f[i][0]+=f[j][1])%=mod;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        (ans+=f[i][0]+f[i][1])%=mod;    &#125;    ans-=n;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="画作-同bzoj2638"><a href="#画作-同bzoj2638" class="headerlink" title="画作(同bzoj2638)"></a>画作(同bzoj2638)</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>轮流染色</p><p>将同色方块缩点建图</p><p>枚举每个点为根求bfs树</p><p>按深度从深至浅顺序染色</p><p>树的深度-(最深叶节点为白色?1:0)为以这个点为中心染色的最少操作次数</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 55char c[A][A];ll dis[A*10000],head[A*10000],nxt[A*10000],ver[A*10000],col[A*10000],id[A][A];ll n,m,tot,ide,mx=0,ans=0x7fffffffff;deque&lt;ll &gt;q;void add(ll x,ll y)&#123;//    printf(&quot;x=%lld y=%lld\n&quot;,x,y);    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;ll ok(ll x,ll y)&#123;    if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m) return 1;    return 0;&#125;const ll nowx[5]=&#123;0,1,0,0,-1&#125;;const ll nowy[5]=&#123;0,0,1,-1,0&#125;;void dfs(ll x,ll y,ll now)&#123;//    printf(&quot;x=%lld y=%lld now=%lld c[x][y]-&#39;0&#39;=%lld ide=%lld\n&quot;,x,y,now,1ll*(c[x][y]-&#39;0&#39;),ide);    if(id[x][y]||c[x][y]-&#39;0&#39;!=now)            return ;    id[x][y]=ide;//    printf(&quot;n=%lld m=%lld\n&quot;,n,m);    for(ll i=1;i&lt;=4;i++)&#123;        ll xnow=nowx[i]+x,ynow=nowy[i]+y;    //        printf(&quot;x=%lld y=%lld xnow=%lld ynow=%lld\n&quot;,x,y,xnow,ynow);        if(ok(xnow,ynow))            dfs(xnow,ynow,now);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%s&quot;,c[i]+1);    &#125;        for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=1;j&lt;=m;j++)&#123;            if(!id[i][j])&#123;                col[++ide]=c[i][j]-&#39;0&#39;;                dfs(i,j,c[i][j]-&#39;0&#39;);            &#125;        &#125;    &#125;/*    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))&#123;        for(ll j=1;j&lt;=m;j++)&#123;            printf(&quot;%lld&quot;,id[i][j]);        &#125;    &#125;*/    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;m;j++)            if(id[i][j]!=id[i][j+1])                 add(id[i][j],id[i][j+1]),add(id[i][j+1],id[i][j]);    for(ll i=1;i&lt;n;i++)        for(ll j=1;j&lt;=m;j++)            if(id[i][j]!=id[i+1][j])                add(id[i][j],id[i+1][j]),add(id[i+1][j],id[i][j]);    for(ll i=1;i&lt;=ide;i++)&#123;        for(ll j=1;j&lt;=ide;j++) dis[j]=0x7ffffffff;        q.clear();mx=0;        q.push_back(i);        dis[i]=0;        while(!q.empty())&#123;            ll x=q.front();            q.pop_front();//            printf(&quot;x=%lld col=%lld\n&quot;,x,col[i]);            if(dis[x]&gt;mx) mx=dis[x];            for(ll k=head[x];k;k=nxt[k])&#123;                ll y=ver[k];//                printf(&quot;x=%lld y=%lld col=%lld dis[x]=%lld dis[y]=%lld mx=%lld\n&quot;,x,y,col[i],dis[x],dis[y],mx);                if(dis[y]&gt;dis[x]+1)&#123;                    dis[y]=dis[x]+1;                            q.push_back(y);                &#125;            &#125;        &#125;        if(col[i]==1&amp;&amp;!(mx&amp;1)) mx++;        if(col[i]==0&amp;&amp;(mx&amp;1)) mx++;        if(mx&lt;ans) ans=mx;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="蔬菜"><a href="#蔬菜" class="headerlink" title="蔬菜"></a>蔬菜</h2><p>裸二维莫队</p><h2 id="施工"><a href="#施工" class="headerlink" title="施工"></a>施工</h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>模拟\dp</p><p>wwwwwwb的题解</p><p><strong>可以想象到最优情况一定是将两端高于中间的一段平原填成一段平的坑，不然如果坑内存在高度差那么我们即使只将一部分抬升也肯定没有用处，并且如果中间的坑已经高于了两端，再向上升也肯定不优，然后就中间的坑可以很很小，也可以很长，对于这个模型我们首先想到n^2*h的DP</strong></p><p><strong>设当前表示的f[i]表示当前到了i节点并且i节点高度不变时的花费，那么能转移到他的其实只有高于i节点高度的点，那么我们</strong></p><p><strong>其实可以考虑用单调栈维护</strong></p><p><strong>然后对于h的最优高度化简后是一个二次函数的形式，然后直接求解就好，然后求二次函数时要注意解的范围，也要注意解是否为整数，然后打了很久……….</strong></p><p>我的理解填坑是肯定的,不一定要把坑填满,但不会漏情况,你考虑之前点时包含了没把坑填满的情况,</p><p>然后单调栈维护,维护单调递减的情况,我们选到之前点继承了之前最短的情况,不一定要填满</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190927173820904-5015093.png"></p><p>填中间</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190927173852274-1975645141.png"></p><p>这样情况是考虑了的我们并没有漏掉这种情况,我们填当前先覆盖了一遍</p><p>另一个点是</p><pre><code>        while(top&gt;1&amp;&amp;a[sta[top]]&lt;=a[i])&#123;            if(top&gt;=2)&#123;                f[i]=min(f[i],f[sta[top-1]]+gedit(sta[top-1],i,a[sta[top]]));            &#125;            top--;        &#125;        sta[++top]=i;</code></pre><p>为什么栈顶之前一个位置,这是决策点,sta[top]是这之间最大值,至少要填到a[sta[top]]</p><h2 id="联盟"><a href="#联盟" class="headerlink" title="联盟"></a>联盟</h2><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>危险最大值就是直径,断直径上的点才会使答案变优,</p><p>连边的话,我们要连边且让新的直径代价最小,连两个子树直径的中点代价才会最小,(感性理解,如果你不在中点取,直径可以是链接这条直径较长端)</p><p>因此我们可以轻易得到一个$n^2$算法,枚举断边,然后求子树内直径</p><p>如何优化时间,发现子树内直径就是子树内最长链+次长链,</p><p>于是我们就可以O1查出来了</p><p>思维并不算难,代码也不算难打</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define A 600005#define ll long longll f[2][A],head[A],nxt[A],ver[A],dis[A],edgst[A],edged[A],dl[A],bl[A],zj[A],tmpans[A],iszj[A];ll st,ed,n,m,cnt=0,ans=0x7fffffffffff,tot=1,ban=-1,ban2=-1;using namespace std;void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;ll dfs1(ll x,ll pre,ll opt)&#123;    ll mx=0;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        ll d=dfs1(y,x,opt);        f[opt][x]=max(f[opt][x],f[opt][y]);        f[opt][x]=max(f[opt][x],d+mx);        mx=max(mx,d);    &#125;//    子树内直径特殊求法    return mx+1;&#125;void dfs2(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre||i==ban||(i^1)==ban) continue ;        dis[y]=dis[x]+1;        dfs2(y,x);        bl[y]=i;        edgst[i&gt;&gt;1]=x;        edged[i&gt;&gt;1]=y;    &#125;&#125;void getfa()&#123;    ll edd=ed;    while(edd!=st)&#123;    //        printf(&quot;edd=%lld bl[%lld]=%lld st=%lld ed=%lld\n&quot;,edd,edd,bl[edd],st,ed);        iszj[bl[edd]&gt;&gt;1]=1;        zj[++cnt]=edd;        edd=ver[bl[edd]^1];    &#125;    zj[++cnt]=st;&#125;void want_print(ll x)&#123;    ban=x&lt;&lt;1;    cnt=0;    ll tobe1=edgst[x],tobe2=edged[x];    st=1,ed=1;    memset(dis,0,sizeof(dis));    dfs2(tobe1,0);    for(ll i=1;i&lt;=n;i++)        if(dis[i]&gt;dis[st]) st=i;    dis[st]=0;dfs2(st,0);    for(ll i=1;i&lt;=n;i++)        if(dis[i]&gt;dis[ed]) ed=i;    getfa();//    for(ll i=1;i&lt;=cnt;i++)&#123;//        printf(&quot;zj%lld\n&quot;,zj[i]);//    &#125;    printf(&quot;%lld &quot;,zj[(cnt+1)&gt;&gt;1]);    cnt=0;    st=1,ed=1;    memset(dis,0,sizeof(dis));    dfs2(tobe2,0);    for(ll i=1;i&lt;=n;i++)        if(dis[i]&gt;dis[st]) st=i;    dis[st]=0;dfs2(st,0);    for(ll i=1;i&lt;=n;i++)        if(dis[i]&gt;dis[ed]) ed=i;    getfa();    printf(&quot;%lld &quot;,zj[(cnt+1)&gt;&gt;1]);&#125;void sub_task()&#123;    st=1,ed=1;    dis[st]=0;dfs2(st,0);//找到直径起始点    for(ll i=1;i&lt;=n;i++)        if(dis[i]&gt;dis[st]) st=i;    dis[st]=0;dfs2(st,0);//找到直径终止点    for(ll i=1;i&lt;=n;i++)        if(dis[i]&gt;dis[ed]) ed=i;    dfs1(st,0,0);//处理子树最大直径    dfs1(ed,0,1);//处理子树最大直径    getfa();//处理直径上的边    ll len=dis[ed]-dis[st];    for(ll i=1;i&lt;n;i++)&#123;        tmpans[i]=0;        if(iszj[i]) tmpans[i]=max(max(f[0][edged[i]],f[1][edgst[i]]),(f[0][edged[i]]+1)/2+(f[1][edgst[i]]+1)/2+1);        else tmpans[i]=max(len,min((f[1][edged[i]]+1)/2,(f[1][edgst[i]]+1)/2)+1+(len+1)/2);        ans=min(ans,tmpans[i]);//        printf(&quot;tmpans[%lld]=%lld len=%lld iszj[%lld]=%lld f[0][%lld]=%lld f[1][%lld]=%lld\n&quot;,i,ans,len,i,iszj[i],edged[i],f[0][edged[i]],edgst[i],f[1][edgst[i]]);    &#125;    printf(&quot;%lld\n&quot;,ans);    for(ll i=1;i&lt;n;i++)&#123;        if(tmpans[i]==ans) dl[++dl[0]]=i;    &#125;    printf(&quot;%lld &quot;,dl[0]);    for(ll i=1;i&lt;=dl[0];i++)        printf(&quot;%lld &quot;,dl[i]);    printf(&quot;\n&quot;);    for(ll i=1;i&lt;n;i++)&#123;        if(tmpans[i]==ans)&#123;            printf(&quot;%lld %lld &quot;,ver[i&lt;&lt;1|1],ver[i&lt;&lt;1]);            want_print(i);            break;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1,a,b;i&lt;n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);    &#125;    sub_task();&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试39,思维禁锢专场「工业题·玄学题·卡常题」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9539,%E6%80%9D%E7%BB%B4%E7%A6%81%E9%94%A2%E4%B8%93%E5%9C%BA%E3%80%8C%E5%B7%A5%E4%B8%9A%E9%A2%98%C2%B7%E7%8E%84%E5%AD%A6%E9%A2%98%C2%B7%E5%8D%A1%E5%B8%B8%E9%A2%98%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9539,%E6%80%9D%E7%BB%B4%E7%A6%81%E9%94%A2%E4%B8%93%E5%9C%BA%E3%80%8C%E5%B7%A5%E4%B8%9A%E9%A2%98%C2%B7%E7%8E%84%E5%AD%A6%E9%A2%98%C2%B7%E5%8D%A1%E5%B8%B8%E9%A2%98%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-07 18:11</p><h2 id="工业题"><a href="#工业题" class="headerlink" title="工业题"></a>工业题</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>抱歉,题解没时间写了</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190914142054044-1755120289.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 6666666#define mod 998244353ll jie[A],ni[A],acnt[A],bcnt[A];ll fheng[A],fshu[A];ll n,m,a,b;ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;ll C(ll x,ll y)&#123;    return jie[x]*ni[x-y]%mod*ni[y]%mod;&#125;int main()&#123;//    freopen(&quot;a_sample2.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;a,&amp;b);    a%=mod,b%=mod;    jie[0]=1;ni[0]=1;    acnt[0]=bcnt[0]=1;    for(ll i=1;i&lt;=n+m;i++)        jie[i]=jie[i-1]*i%mod,acnt[i]=acnt[i-1]*a%mod,bcnt[i]=bcnt[i-1]*b%mod;    ni[n+m]=meng(jie[n+m],mod-2);    for(ll i=n+m-1;i&gt;=1;i--)        ni[i]=ni[i+1]*(i+1)%mod;    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;fheng[i]),fheng[i]%=mod;    for(ll j=1;j&lt;=m;j++)        scanf(&quot;%lld&quot;,&amp;fshu[j]),fshu[j]%=mod;    ll ans=0;    for(ll i=n;i&gt;=1;i--)&#123;//        printf(&quot;acnt=%lld bcnt=%lld &quot;)//        printf(&quot;fheng[]=%lld n-i+m=%lld m=%lld i=%lld c=%lld acnt=%lld bcnt=%lld\n&quot;,fheng[i],n-i+m,m,i,C(n-i+m,m),acnt[m],bcnt[n-i]);        ans=(ans+fheng[i]*((acnt[m]%mod*bcnt[n-i]%mod)%mod)%mod*C(n-i+m-1,m-1)%mod)%mod;    &#125;    for(ll i=1;i&lt;=m;i++)&#123;//        printf(&quot;fheng[]=%lld n-i+m=%lld m=%lld i=%lld c=%lld acnt=%lld bcnt=%lld\n&quot;,fshu[i],n-i+m,m,i,C(n-i+m,m),acnt[m-i],bcnt[n]);        ans=(ans+fshu[i]*((acnt[m-i]%mod*bcnt[n]%mod)%mod)%mod*C(n-i+m-1,n-1)%mod)%mod;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="玄学题"><a href="#玄学题" class="headerlink" title="玄学题"></a>玄学题</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题目中说求$\sum\limits_{i&#x3D;1}^{i&lt;&#x3D;n}(-1)^{\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;m} d(i*j)}$<br>$d$表示约数个数</p><p>$(-1)^{\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;m}<br>d(i<em>j)}$只和奇偶性有关,如果$d(i</em>j)$为偶数,那么它是没用,偶+偶&#x3D;偶,偶+奇&#x3D;奇</p><p>那么只考虑约数个数为奇就可以了,发现约数个数为奇当且仅当为完全平方数</p><p>我们把$i$ 拆成 $p<em>q^2$($p$ 没有平方因子),那 $j$ 必须有 $p</em>r^2$ 的形式,所以对于每个 $i$,都有<br>$sqrt(\frac{m}{p})$ 个 $j$ 产生贡献。</p><p>可以埃筛(需要卡常)可以线筛</p><p>我用的埃筛</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 11111111long long m,n,ans;ll a[A];int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)        a[i]=i;    ll haha=sqrt(n);    for(ll i=haha;i&gt;=2;i--)&#123;        ll now=i*i;        for(ll j=now;j&lt;=n;j+=now)&#123;            while(a[j]%now==0)                a[j]/=now;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        long long now=m/a[i];        now=sqrt(now);        if(now&amp;1) ans--;        else ans++;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="卡常题"><a href="#卡常题" class="headerlink" title="卡常题"></a>卡常题</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h2 id="考试经历"><a href="#考试经历" class="headerlink" title="考试经历"></a>考试经历</h2><p>🕊</p><p>$t1$沉迷打表</p><p>范围很大,我觉得可能是$n+m$的</p><p>我总觉得$f[n][m]$可拆,拆成$w1*(?<em>a</em>?*b)<em>f[n][0]+w2</em>(?<em>a</em>?<em>b)f[n-1][0]+…….w.</em>(?<em>a</em>?*b)f[0][m]$</p><p>$?$很简单,可以推出来$a$,$b$系数,然后我就开始推总体系数$w$</p><p>然后我就打了$75$分钟表,</p><p>当然也有一丁点收获</p><pre><code>11 21 3 61 4 10 201 5 15 35 701 6 21 56 126 2521 7 28 84 210 462 924</code></pre><p>$update$</p><p>这个表就是组合数表,呵呵.终于认清自己傻逼本质</p><p>一直到$20$行我只截取了7行</p><p>然而并没有什么卵用,</p><p>这个式子屁用没有</p><p>然后开始想$t2$</p><p>$t2$让我想起了</p><pre><code>     God Knows</code></pre><p>然后我开始想$区间dp$</p><p>然后我想了很长时间,依然没有任何收获</p><p>转移起来跟.一样</p><p>然后看$t3$,</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试38「金·斯诺·赤」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9538%E3%80%8C%E9%87%91%C2%B7%E6%96%AF%E8%AF%BA%C2%B7%E8%B5%A4%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9538%E3%80%8C%E9%87%91%C2%B7%E6%96%AF%E8%AF%BA%C2%B7%E8%B5%A4%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-07 12:17</p><h2 id="金"><a href="#金" class="headerlink" title="金"></a>金</h2><p>辗转相减见祖宗</p><p>高精</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define A 2000#define P 1#define N 10#define ll long longll n,T;char sjdfj[A];struct bignum&#123;    ll n[A],l;    bignum()&#123;l=1,memset(n,0,sizeof(n));&#125;    void clear()&#123;while(l&gt;1&amp;&amp;!n[l-1]) l--;&#125;    void print()&#123;        printf(&quot;%lld&quot;,n[l-1]);        for(ll i=l-2;i&gt;=0;i--)&#123;            printf(&quot;%0*lld&quot;,P,n[i]);        &#125;        printf(&quot;\n&quot;);    &#125;    void read()&#123;        l=0;        scanf(&quot;%s&quot;,sjdfj+1);        l=strlen(sjdfj+1);        reverse(sjdfj+1,sjdfj+l+1);        for(ll i=0;i&lt;l;i++)&#123;            n[i]=sjdfj[i+1]-&#39;0&#39;;        &#125;    &#125;    ll ok()&#123;        //若为0 return1         //若%2==0 return2        //若%2!=0 return3        if(n[0]==0&amp;&amp;l==1) return 1;//        if(n[0]==1&amp;&amp;l==1) return 1;        if(n[0]%2==0) return 2;        if(n[0]%2!=0) return 3;    &#125;    bool operator &lt;(bignum x) const    &#123;        bignum t=*this,tep;        if(t.l!=x.l)    return t.l&lt;x.l;        for(ll i=t.l-1;i&gt;=0;i--)        &#123;            if(t.n[i]!=x.n[i]) return t.n[i]&lt;x.n[i];        &#125;        return 0;    &#125;    bool operator &gt;(bignum x) const    &#123;        bignum t=*this;        if(t.l!=x.l) return t.l&gt;x.l;        for(ll i=t.l-1;i&gt;=0;i--)        &#123;            if(t.n[i]!=x.n[i]) return t.n[i]&gt;x.n[i];        &#125;        return 0;    &#125;    bignum operator -(bignum x) const    &#123;        bignum t=*this;        if(t&lt;x) swap(t,x);        ll jie=0;    //    t.print();x.print();        for(ll i=0;i&lt;t.l;i++)        &#123;            t.n[i]-=x.n[i];            while(t.n[i]&lt;0)            &#123;                t.n[i]+=N;                jie++;            &#125;            t.n[i+1]-=jie;            jie=0;                    &#125;        while(!t.n[t.l-1]&amp;&amp;t.l&gt;1) t.l--;        return t;    &#125;    bignum operator *(bignum x) const&#123;        bignum t=*this,tep;        tep.l=t.l+x.l+1;        for(ll i=0;i&lt;t.l;i++)            for(ll j=0;j&lt;x.l;i++)&#123;                tep.n[i+j]+=t.n[i]*x.n[j];            &#125;        for(ll i=0;i&lt;tep.l;i++)&#123;            if(tep.n[i]&gt;=N)             &#123;                tep.n[i+1]+=tep.n[i]/N;                tep.n[i]%=N;            &#125;        &#125;        tep.clear();        return tep;    &#125;    bignum operator +(bignum x)const&#123;        bignum t=*this;        if(t.l&lt;x.l) t.l=x.l;        t.l++;        for(ll i=0;i&lt;t.l;i++)&#123;            t.n[i]+=x.n[i];            if(t.n[i]&gt;=N)&#123;                t.n[i+1]+=t.n[i]/N;                t.n[i]%=N;            &#125;        &#125;        t.clear();        return t;    &#125;    bignum operator =(ll x)&#123;        l=0;        while(x)&#123;            n[l++]=x%N;            x/=N;        &#125;        return *this;    &#125;    bignum operator *(const ll &amp;b)&#123;        bignum t=*this,r;        r.l=0;        ll g=0;        for(ll i=0;i&lt;t.l||g;i++)&#123;            ll x;            if(i&lt;t.l)                x=t.n[i]*b+g;            else x=g;            r.n[r.l++]=x%N;            g=x/N;        &#125;        return r;    &#125;    bignum operator /(const ll &amp;x)&#123;        bignum t=*this,r;        ll tmp=0;        r.l=t.l;        for(ll i=t.l-1;i&gt;=0;i--)&#123;            tmp+=t.n[i];            if(tmp&gt;=x)&#123;                r.n[i]=tmp/x;                tmp%=x;            &#125;            tmp*=N;        &#125;        r.clear();        return r;    &#125;&#125;a,b,c;ll gcd()&#123;        //若为0 return1         //若%2==0 return2        //若%2!=0 return3    while((a.ok()!=1&amp;&amp;b.ok()!=1))&#123;//        printf(&quot;a=%lld &quot;,a.ok());//        a.print();//        printf(&quot;b=%lld &quot;,b.ok());//        b.print();        ll ok1=a.ok(),ok2=b.ok();        if(ok1==2&amp;&amp;ok2==2)&#123;            return 0;            a=a/2,b=b/2;        &#125;        else if(ok1==3&amp;&amp;ok2==3)&#123;            if(a&lt;b) swap(a,b);            a=a-b;        &#125;        else if(ok1==2&amp;&amp;ok2==3)&#123;            a=a/2;        &#125;        else if(ok1==3&amp;&amp;ok2==2)&#123;            b=b/2;        &#125;    &#125;&#125;int main()&#123;/*1 1023 3072*///    freopen(&quot;bf.txt&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;T);    for(ll i=1;i&lt;=T;i++)&#123;        a.read(),b.read();    //    a=a-b;        gcd();//        a.print(),b.print();        if(a.n[0]==0&amp;&amp;b.n[0]==1&amp;&amp;b.l==1&amp;&amp;a.l==1)&#123;            printf(&quot;Yes\n&quot;);        &#125;        else if(a.n[0]==1&amp;&amp;b.n[0]==0&amp;&amp;b.l==1&amp;&amp;a.l==1)&#123;            printf(&quot;Yes\n&quot;);        &#125;        else printf(&quot;No\n&quot;);    &#125;&#125;</code></pre><p>View Code</p><h2 id="斯诺"><a href="#斯诺" class="headerlink" title="斯诺"></a>斯诺</h2><p>考试代码改了改,数组开小见祖宗</p><p>考试时候$re$了</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190907120158155-229048996.png"></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190907120242242-190144103.png"></p><p>大概就是这样</p><p>考试时也维护的前缀和</p><p>$60%$算法</p><p>只含$0,1$</p><p>我们可以将$0$看作减$1$,$1$看作加一</p><p>那么合法方案数就是$sum[r]-sum[l-1]&#x3D;&#x3D;0$的个数</p><p>我们开一个桶存$sum[l]$,那么当前符合就是桶里$sum[i]$个数</p><p>查完个数再把$sum[r]$压进桶就行了</p><p>注意初始化,当你$sum&#x3D;&#x3D;0$时也是合法方案,方案数为桶里$sum&#x3D;&#x3D;0$个数$+1$,你可以先在桶里$0$压一个再进行操作</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define mod 5000000ll tong[mod+mod+mod+mod],sum[mod+mod][3],sumtp[21111111],sum2[111111111];ll n,ans=0,all;char a[mod+mod];void solve(ll ql,ll qr)&#123;    if(ql==qr) return ;    ll mid=(ql+qr)&gt;&gt;1;    solve(ql,mid);solve(mid+1,qr);    ans=rand();&#125;ll check(ll l,ll r)&#123;    ll len=(r-l+1)/2;//    printf(&quot;l=%lld r=%lld len=%lld\n&quot;,l,r,len);//    printf(&quot;sum0=%lld 1=%lld 2=%lld\n&quot;,sum[r][0]-sum[l-1][0],sum[r][1]-sum[l-1][1],sum[r][2]-sum[l-1][2]);    if(sum[r][0]-sum[l-1][0]&gt;len) return 0;    if(sum[r][1]-sum[l-1][1]&gt;len) return 0;    if(sum[r][2]-sum[l-1][2]&gt;len) return 0;    return 1;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    scanf(&quot;%s&quot;,a+1);    all=1;    for(ll i=1;i&lt;=n;i++)&#123;        sum[i][0]=sum[i-1][0];        sum[i][1]=sum[i-1][1];        sum[i][2]=sum[i-1][2];        if(a[i]==&#39;0&#39;) sum[i][0]++;        if(a[i]==&#39;1&#39;) sum[i][1]++;        if(a[i]==&#39;2&#39;) sum[i][2]++,all=0;    &#125;    if(all&amp;&amp;n&gt;1000)&#123;        tong[mod]=1;        for(ll i=1;i&lt;=n;i++)&#123;            sumtp[i]=sumtp[i-1];            if(a[i]==&#39;0&#39;) &#123;//                if(a[i-1]==&#39;1&#39;) sumtp[i]=0;//                if(sumtp[i]&lt;0) ans++;                sumtp[i]++;            &#125;            else &#123;//                if(a[i-1]==&#39;0&#39;) sumtp[i]=0;//                if(sumtp[i]&gt;0) ans++;                sumtp[i]--;            &#125;        &#125;        for(ll i=1;i&lt;=n;i++)&#123;            ans+=tong[mod+sumtp[i]];            tong[mod+sumtp[i]]++;//            printf(&quot;sumtp=%lld\n&quot;,sumtp[i]);                    &#125;        printf(&quot;%lld\n&quot;,ans);        return 0;    &#125;    if(n&lt;=1000)    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=i+1;j&lt;=n;j++)&#123;            if(check(i,j))&#123;                ans++;            &#125;        &#125;    &#125;    else solve(1,n);    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>从$40%$算法寻找思路</p><p>$60%$算法$2$</p><p>维护三个$sum$,当为$0$,$sum[0]– sum[1]++ sum[2]++$这样就又和上面类似了</p><p>然而合法方案数不止$sum[r]-sum[l-1]&#x3D;&#x3D;0$</p><p>合法很难维护找非法的,最后答案就是合法减非法</p><p>发现非法$sum$相减肯定$&lt;0$</p><p>那么就转化为逆序对问题</p><p>树状数组求逆序对</p><p>(其实你常数优秀可以$AC$</p><p>$100%$算法</p><p>发现前后差异不大,假设你当前答案$1$为QAQ,若这一位仍为$1$,答案就要对应$-$,另外$2$,$0$答案就要$+$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试34「次芝麻·呵呵呵·长寿花」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9534%E3%80%8C%E6%AC%A1%E8%8A%9D%E9%BA%BB%C2%B7%E5%91%B5%E5%91%B5%E5%91%B5%C2%B7%E9%95%BF%E5%AF%BF%E8%8A%B1%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9534%E3%80%8C%E6%AC%A1%E8%8A%9D%E9%BA%BB%C2%B7%E5%91%B5%E5%91%B5%E5%91%B5%C2%B7%E9%95%BF%E5%AF%BF%E8%8A%B1%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-03 17:53</p><h2 id="次芝麻"><a href="#次芝麻" class="headerlink" title="次芝麻"></a>次芝麻</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>大力打表,发现快速幂,</p><p>例如初始$5$ $6$,那么第一次就是$5<em>2%11&#x3D;10$,$6</em>2%11&#x3D;1$.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n,m,k,d;ll g(ll x,ll k,ll s=1)&#123;    for(;k;k&gt;&gt;=1,x=x*x%d)        if(k&amp;1) s=s*x%d;    return s;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    d=n+m;    printf(&quot;%lld\n&quot;,min((n*g(2,k))%d,(m*g(2,k))%d));&#125;</code></pre><p>View Code</p><h2 id="喝喝喝"><a href="#喝喝喝" class="headerlink" title="喝喝喝"></a>喝喝喝</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>把$a[i]%a[j]&#x3D;k$转化为$a[i]-k&#x3D;y*a[i]$,</p><p>开桶维护$a[i]-k$</p><p>每次枚举$y$,看桶里是否有对应值,找到当前$i$<strong>左侧</strong> 的最右能形成坏对的$v$,然后坏对个数就是$v$,,最后容斥就完了</p><p>考试时打的$n^2$,剪一个小枝能$70$分,然而我没减</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 4444444ll a[A],ve[A],tong[A];ll n,K,ans=0,maxx=0,jc=0;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;K);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]),maxx=max(maxx,a[i]);    ll num=0;    for(ll i=1;i&lt;=n;i++)&#123;        ve[i]=max(ve[i],ve[i-1]);        if(a[i]&lt;K) continue ;        ll maxid=0;        for(ll b=0;b*a[i]&lt;=maxx;b++)            if(tong[b*a[i]])                maxid=max(maxid,tong[b*a[i]]);        tong[a[i]-K]=i;                if(a[i]==K) continue ;        if(maxid!=i) ve[i]=max(maxid,ve[i]);    &#125;    for(ll i=1;i&lt;=n;i++)        if(ve[i])            ans+=(ve[i]);    printf(&quot;%lld\n&quot;,n*(n+1)/2-ans+jc);&#125;</code></pre><p>View Code</p><h2 id="长寿花"><a href="#长寿花" class="headerlink" title="长寿花"></a>长寿花</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>部分分状压$dp$,然而很难打,打了状压就陷进去了,具体$m$不用考虑</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#define LL long longusing namespace std;int n,m,p;int a[1000010];LL g[1010][1&lt;&lt;11],t[1&lt;&lt;11];LL f[1010][1&lt;&lt;11];LL poww(LL a,int b)&#123;        LL ans=1;    while(b)    &#123;        if(b&amp;1)ans=ans*a%p;        a=a*a%p;b=b&gt;&gt;1;    &#125;    return ans;&#125;inline int read();signed main()&#123;    n=read(),m=read(),p=read();    for(int i=1;i&lt;=n;i++)a[i]=read();    if(m&lt;=10)    &#123;        for(int i=1;i&lt;=n;i++)            for(int k=0;k&lt;(1&lt;&lt;m);k++)            &#123;                int tem=k,num=0;while(tem)&#123;num+=tem&amp;1;tem=tem&gt;&gt;1;&#125;                g[i][k]=num*poww(num-1,a[i]-1)%p;            &#125;        for(int i=1;i&lt;=n;i++)        &#123;            for(int k=0;k&lt;(1&lt;&lt;m);k++)            for(int l=0;l&lt;(1&lt;&lt;m);l++)                if(l!=k&amp;&amp;(l|k)==k)g[i][k]=((g[i][k]-g[i][l])%p+p)%p;        &#125;        LL sum=0;        for(int k=0;k&lt;(1&lt;&lt;m);k++)f[1][k]=g[1][k],sum=(sum+f[1][k])%p;        for(int i=2;i&lt;=n;i++)        &#123;            for(int k=0;k&lt;(1&lt;&lt;m);k++)                f[i][k]=((sum-f[i-1][k])%p+p)%p*g[i][k]%p;            sum=0;            for(int k=0;k&lt;(1&lt;&lt;m);k++)                sum=(sum+f[i][k])%p;        &#125;/*        for(int i=1;i&lt;=n;i++)            for(int k=0;k&lt;(1&lt;&lt;m);k++)            &#123;                bitset&lt;3&gt;t(k);                cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;g[i][k]&lt;&lt;endl;            &#125;*/        printf(&quot;%lld\n&quot;,sum%p);        return 0;    &#125;&#125;inline int read()&#123;    int s=0,f=1;char a=getchar();    while(a&lt;&#39;0&#39;||a&gt;&#39;9&#39;)&#123;if(a==&#39;-&#39;)f=-1;a=getchar();&#125;    while(a&gt;=&#39;0&#39;&amp;&amp;a&lt;=&#39;9&#39;)&#123;s=s*10+a-&#39;0&#39;;a=getchar();&#125;    return s*f;&#125;</code></pre><p>Al_Ca的代码</p><p>正解</p><p>设$f[i][j]$为到第$i$<em><strong>层</strong></em> ,当前颜色$j$<em><strong>种</strong></em></p><p>$f[i][j]&#x3D;\sum\limits_{k&#x3D;1}^{k&lt;&#x3D;a[i-1]} f[i-1]<a href="%E4%B9%8B%E5%89%8D%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%E8%B4%A1%E7%8C%AE">k</a>*(当前层方案数)-(和上一层重合的)$</p><p>当前层可看作$j$个集合,相同集合元素互不相邻</p><p>$g[i][j]$表示$i$个元素放$j$个集合</p><p>考虑递推</p><p>当前值可以是之前一个集合</p><p>$g[i][j]&#x3D;g[i-1][j]*(j-1)$解释一下</p><p>不能和之前相同集合相邻</p><p>$g[i][j]&#x3D;g[i-1][j-1]*j$</p><p>也可以是一个新的集合,你之前知道$j-1$个集合,但你不知道当前新增是哪一个</p><p>去重,颜色集合相同则颜色数相同</p><p>$f[i][j]&#x3D;\sum\limits_{k&#x3D;1}^{k&lt;&#x3D;a[i-1]}<br>f[i-1][k]*g[a[i]][j]*C[a[i]][j]-f[i-1][j]*g[a[i]][j]$</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 5555#define maxn 3333333ll a[maxn],bj[maxn],prime[maxn],t[maxn];long long g[A][A],f[2][maxn],C[maxn];long long sum;ll n,m,K,ans=0,maxx=0,jc=0,mod;void debuger_g();void jia(ll x)&#123;//    printf(&quot;+x=%lld bj=%lld\n&quot;,x,bj[x]);    while(x&gt;1)&#123;        t[bj[x]]++;        x=x/bj[x];    &#125;&#125;void jian(ll x)&#123;//    printf(&quot;-x=%lld bj=%lld\n&quot;,x,bj[x]);    while(x&gt;1)&#123;        t[bj[x]]--;        x=x/bj[x];    &#125;&#125;void get_prime(ll o)&#123;    ll gby=o;    for(ll i=2;i&lt;=gby;i++)&#123;        if(!bj[i])&#123;            prime[++prime[0]]=i;            bj[i]=i;        &#125;        for(ll j=1;j&lt;=prime[0]&amp;&amp;prime[j]*i&lt;=gby;j++)&#123;            bj[i*prime[j]]=prime[j];            if((i%prime[j])==0) break ;        &#125;    &#125;&#125;ll get_()&#123;    ll ans=1;    for(ll i=1;i&lt;=prime[0];i++)&#123;        for(ll j=1;j&lt;=t[prime[i]];j++)            ans=1ll*ans*prime[i]%mod;//        printf(&quot;ans=%lld t[%lld]=%lld prime=%lld\n&quot;,ans,i,t[prime[i]],prime[i]);    &#125;    return ans;&#125;void get_C()&#123;    ll gby=min(m,5000ll);    for(ll i=1;i&lt;=gby;i++)&#123;        jia(m-i+1);        jian(i);C[i]=get_();//        printf(&quot;C[%lld]=%lld\n&quot;,i+1,C[i+1]);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;mod);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]),maxx=max(maxx,a[i]);    g[1][1]=1;g[2][2]=2;    for(ll i=3;i&lt;=5000;i++)        for(ll j=2;j&lt;=i&amp;&amp;j&lt;=m;j++)            g[i][j]=((j-1)*g[i-1][j]%mod+g[i-1][j-1]*j%mod)%mod;    get_prime(m);    get_C();    for(ll j=1;j&lt;=a[1];j++)&#123;//处理出来i==1的情况        f[1][j]=C[j]*g[a[1]][j]%mod;        sum=(sum+f[1][j])%mod;    &#125;    for(ll i=2;i&lt;=n;i++)&#123;        for(ll j=0;j&lt;=maxx;j++)            f[i&amp;1][j]=0;        for(ll j=1;j&lt;=a[i];j++)&#123;            f[i&amp;1][j]=(C[j]%mod*g[a[i]][j]%mod*sum%mod-(f[(i-1)&amp;1][j]*g[a[i]][j]%mod)%mod+mod)%mod;        &#125;        sum=0;        for(ll j=1;j&lt;=a[i];j++)            sum=(sum+f[i&amp;1][j])%mod;    &#125;    printf(&quot;%lld\n&quot;,sum);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试30「return·one·magic」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9530%E3%80%8Creturn%C2%B7one%C2%B7magic%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9530%E3%80%8Creturn%C2%B7one%C2%B7magic%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-23 16:44</p><h2 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先原式指数肯定会爆$long$ $long$</p><p>首先根据欧拉定理我们可以将原式换成$N^{\sum\limits_{i&#x3D;1}^{i&lt;&#x3D;N} [gcd(i,N)&#x3D;&#x3D;1] C_{G}^{i}<br>%phi(p)}%p$</p><p>根据欧拉函数是积性的得出$phi(54184622)&#x3D;phi(2)*phi(27092311)$</p><p>然后$phi(27092311)&#x3D;27092310$ $phi(2)&#x3D;1$所以$phi(54184622)&#x3D;27092310$</p><p>于是我们现在要求的就是$N^{\sum\limits_{i&#x3D;1}^{i&lt;&#x3D;N} [gcd(i,N)&#x3D;&#x3D;1] C_{G}^{i}<br>%27092310}%p$</p><p>$27092310&#x3D;2<em>3</em>5<em>7</em>129011$然后裸的$crt$求组合数板子求就完了</p><p>注意:你要预处理出阶乘和逆元,否则会超时</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 333333ll k,p,n,g;//phi(54184622)=27092310//27092310=2*3*5*7*129011ll w[7]=&#123;0,2,3,5,7,129011,54184622&#125;,jie[6][A],ni[6][A],dl[A],b[A];ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)&#123;        x=1;y=0;        return a;    &#125;    ll gcd=exgcd(b,a%b,x,y);    ll t=x;    x=y;    y=t-a/b*y;    return gcd;&#125;ll meng(ll x,ll k,ll cix)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%w[cix])        if(k&amp;1)            ans=ans*x%w[cix];    return ans;&#125;ll china()&#123;    ll x,y,a=0,m,n=1;    for(ll i=1;i&lt;=5;i++)        n*=w[i];    for(ll i=1;i&lt;=5;i++)&#123;        m=n/w[i];        exgcd(w[i],m,x,y);        a=(a+y*m*b[i])%n;    &#125;    if(a&gt;0) return a;    return a+n;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;ll jic(ll n,ll m,ll cix)&#123;    if(m&gt;n) return 0;    if(m==0) return 1;    return jie[cix][n]%w[cix]*ni[cix][n-m]%w[cix]*ni[cix][m]%w[cix];&#125;ll lucas(ll n,ll m,ll cix)&#123;    if(n==0)return 1;    return jic(n%w[cix],m%w[cix],cix)*lucas(n/w[cix],m/w[cix],cix)%w[cix];&#125;using namespace std;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;g);        for(ll i=1;i&lt;=min(g,n);i++)&#123;        if(gcd(i,n)==1)            dl[++dl[0]]=i;    &#125;    for(ll i=1;i&lt;=5;i++)&#123;        jie[i][0]=1;        ni[i][0]=1;        for(ll j=1;j&lt;w[i];j++)            jie[i][j]=jie[i][j-1]*j%w[i];        ni[i][w[i]-1]=meng(jie[i][w[i]-1],w[i]-2,i);        for(ll j=w[i]-2;j&gt;=1;j--)            ni[i][j]=ni[i][j+1]*(j+1)%w[i];        for(ll j=1;j&lt;=dl[0];j++)            (b[i]+=lucas(g,dl[j],i))%=w[i];    &#125;    ll j=china();    ll k=meng(n,j,6);    cout&lt;&lt;k&lt;&lt;endl;    //模w「i」 剩余b「i」    &#125;</code></pre><p>View Code</p><h2 id="one"><a href="#one" class="headerlink" title="one"></a>one</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>美妙的约瑟夫问题,</p><p>范围特别大考虑线性推</p><p><a href="https://blog.csdn.net/u011500062/article/details/72855826">然而我懒的说了</a></p><p>代码特别简单,只是上文稍做修改</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 1000000ll ans,t,n;int main()&#123;    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%d&quot;,&amp;n);        ans=0;        for(ll i=n-1;i&gt;=0;i--)            ans=(ans+i)%(n-i+1);        printf(&quot;%d\n&quot;,ans+1);    &#125;&#125;</code></pre><p>View Code</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>这是道语文题,这一定是一个语文题,一定是这样</p><p>其实它是让你求前趋后继</p><p>那么这个题难点就在于怎么在作者给出题干中看出是前趋后继</p><p>那么我们看题干</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190823173357767-1310318075.png"></p><p>$0-2^{31}$范围内</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190823173428084-887487074.png"></p><p>我真的没看出来这是求前趋后继,$pdf$上没给样例解释</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试29「爬山·学数数·七十和十七」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9529%E3%80%8C%E7%88%AC%E5%B1%B1%C2%B7%E5%AD%A6%E6%95%B0%E6%95%B0%C2%B7%E4%B8%83%E5%8D%81%E5%92%8C%E5%8D%81%E4%B8%83%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9529%E3%80%8C%E7%88%AC%E5%B1%B1%C2%B7%E5%AD%A6%E6%95%B0%E6%95%B0%C2%B7%E4%B8%83%E5%8D%81%E5%92%8C%E5%8D%81%E4%B8%83%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-22 16:25</p><p>爬山题解不想写了</p><h2 id="学数数"><a href="#学数数" class="headerlink" title="学数数"></a>学数数</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190822152730504-1191247118.png"></p><p>离散化然后找到以每一个值为最大值的连续子段有多少个,然后开个桶维护</p><p>那么怎么找以每一个值为最大值的连续子段个数</p><h3 id="方法1-我的极笨的方法"><a href="#方法1-我的极笨的方法" class="headerlink" title="方法1(我的极笨的方法)"></a>方法1(我的极笨的方法)</h3><p>考试时我的丑陋思路,</p><p>定义极左值为左面第一个大于当前值的值,极右值为右面第一个大于当前值的值</p><p>,找到最大值然后当前符合的子段个数就为$r-l+1+(r-now)*(now-l)$</p><p>解释一下$r-l+1$为以$now$为边界的子段,$(r-now)*(now-l)$为包含$now$的子段</p><p>那么问题又转化为了如何求边界</p><p>我们发现找极左值,极右值过程可以二分实现,</p><p>我们每次找到最大值,然后找到左右子段的最大值和$id$,这些子段的最大值边界就是当前$now$!!!!</p><p>维护最大值$id$可以线段树实现</p><p>给一下实现</p><p>简单好想个屁嘞</p><p>但是比较直观是真的</p><pre><code>void pre(ll l,ll r,ll now,ll nowmax)&#123;    if(l&gt;r) return ;    if(l==r) &#123;        sum[nowmax]++;        return ;    &#125;    sum[nowmax]+=r-l+1+(r-now)*(now-l);    maxn=0,ida=0;    if(l&lt;=now-1)    &#123;            seg_max(1,l,now-1);        pre(l,now-1,ida,maxn);    &#125;    maxn=0,ida=0;    if(now+1&lt;=r)    &#123;        seg_max(1,now+1,r);        pre(now+1,r,ida,maxn);    &#125;&#125;</code></pre><h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2222222ll n,q,mx,mn=0x7fffffffff,ida,maxn,idb;ll a[A],sum[A],b[A];char c[10];struct tree&#123;    ll l,r,val,id;&#125;tr[A];void pushup(ll p)&#123;    if(tr[p&lt;&lt;1].val&gt;tr[p&lt;&lt;1|1].val)&#123;        tr[p].val=tr[p&lt;&lt;1].val;        tr[p].id=tr[p&lt;&lt;1].id;    &#125;    else &#123;        tr[p].val=tr[p&lt;&lt;1|1].val;        tr[p].id=tr[p&lt;&lt;1|1].id;    &#125;&#125;void built(ll p,ll l,ll r)&#123;    tr[p].l=l,tr[p].r=r;    if(l==r)&#123;        tr[p].val=a[l];        tr[p].id=l;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(p&lt;&lt;1,l,mid);    built(p&lt;&lt;1|1,mid+1,r);    pushup(p);&#125;void seg_max(ll p,ll l,ll r)&#123;//    printf(&quot;p=%lld l=%lld r=%lld l=%lld r=%lld\n&quot;,p,l,r,tr[p].l,tr[p].r);    if(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)&#123;        if(tr[p].val&gt;maxn)&#123;            maxn=tr[p].val;            ida=tr[p].id;        &#125;        return ;    &#125;    ll mid=(tr[p].l+tr[p].r)&gt;&gt;1;    if(mid&gt;=l)        seg_max(p&lt;&lt;1,l,r);    if(mid&lt;r)        seg_max(p&lt;&lt;1|1,l,r);&#125;void pre(ll l,ll r,ll now,ll nowmax)&#123;    if(l&gt;r) return ;    if(l==r) &#123;        sum[nowmax]++;//        printf(&quot;l=%lld nowmax=%lld \n&quot;,l,nowmax);        return ;    &#125;//    printf(&quot;l=%lld r=%lld nowmax=%lld r-l=%lld\n&quot;,l,r,nowmax,r-l+1);    sum[nowmax]+=r-l+1+(r-now)*(now-l);    maxn=0,ida=0;    if(l&lt;=now-1)    &#123;            seg_max(1,l,now-1);        pre(l,now-1,ida,maxn);    &#125;    maxn=0,ida=0;    if(now+1&lt;=r)    &#123;        seg_max(1,now+1,r);        pre(now+1,r,ida,maxn);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);        b[i]=a[i];        if(a[i]&gt;mx)&#123;            ida=i;            mx=a[i];            &#125;        mn=min(mn,a[i]);    &#125;    sort(b+1,b+n+1);    ll m=unique(b+1,b+n+1)-b-1;//    for(ll i=1;i&lt;=m;i++)&#123;//        printf(&quot;b=%lld\n&quot;,b[i]);//    &#125;    for(ll i=1;i&lt;=n;i++)        a[i]=lower_bound(b+1,b+1+m,a[i])-b;    built(1,1,n);    pre(1,n,ida,a[ida]);    for(ll i=1;i&lt;=n;i++)        sum[i]+=sum[i-1];    for(ll i=1,que;i&lt;=q;i++)&#123;        scanf(&quot;%s&quot;,c+1);        scanf(&quot;%lld&quot;,&amp;que);        ll nxt=(lower_bound(b+1,b+m+1,que)-b),        pre=(upper_bound(b+1,b+m+1,que))-b-1;//        printf(&quot;pre=%lld nxt=%lld\n&quot;,pre,nxt);        if(c[1]==&#39;&lt;&#39;)&#123;            if(que&gt;mx)&#123;                printf(&quot;%lld\n&quot;,sum[n]);                continue ;            &#125;            if(que&lt;mn)&#123;                printf(&quot;0\n&quot;);                continue ;            &#125;            if(pre!=nxt)                printf(&quot;%lld\n&quot;,sum[pre]);            else printf(&quot;%lld\n&quot;,sum[pre-1]);        &#125;        else if(c[1]==&#39;=&#39;)&#123;            if(que&gt;mx||que&lt;mn)&#123;                printf(&quot;0\n&quot;);                continue ;            &#125;            if(pre==nxt)                printf(&quot;%lld\n&quot;,sum[pre]-sum[pre-1]);            else printf(&quot;0\n&quot;);        &#125;        else if(c[1]==&#39;&gt;&#39;)&#123;            if(que&gt;mx)&#123;                printf(&quot;0\n&quot;);                continue ;            &#125;            if(que&lt;mn)&#123;                printf(&quot;%lld\n&quot;,sum[n]);                continue ;            &#125;            if(pre==nxt)                printf(&quot;%lld\n&quot;,sum[n]-sum[pre]);            else printf(&quot;%lld\n&quot;,sum[n]-sum[pre]);        &#125;    &#125;&#125;</code></pre><p>View Code</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>单调栈,显然可以单调栈,看到这个就必须想单调栈啊!</p><p>维护一个单调下降的栈当发现当前值比队尾小接着插,发现当前值不小$pop$,当前值的$l$就是$pop$后单调栈的栈顶,已经$pop$掉的值的$r$就是当前值</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190822155528450-927753675.png"></p><p>代码咕了</p><h2 id="七十和十七"><a href="#七十和十七" class="headerlink" title="七十和十七"></a>七十和十七</h2><p>设$g[i]$为将** <em>相对大小为</em>** $i$的数插到队头要花多少步复原</p><p>注意是 <em><strong>相对大小</strong></em></p><p><em><strong>以下说的1,2…都是相对大小</strong></em></p><p>我们将$1$移到队头要$1$步复原,$g[1]&#x3D;1$</p><p>将$2$移到队头你相对大小为$1$的也要复原$g[2]&#x3D;g[1]+1$</p><p>将$3$移到队头你大小$1,2$也要复原$g[3]&#x3D;g[2]+g[1]+1$</p><p>…类推</p><p>$g[n]&#x3D;\sum\limits {i&#x3D;1}^{i&lt;&#x3D;n-1}(g[i])+1$</p><p>然后我们设$f$为移动总步数</p><p>$f[i]&#x3D;f<a href="%E4%B8%BA1%E7%9A%84%E6%83%85%E5%86%B5">i-1</a>+\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;i-1} f[i-1]+(i-1)!*g[j]$</p><p>,最后再同时除以$i!$,为了方便我们设$E[i]&#x3D;\frac{f[i]}{i!}$</p><p>原式变为$E[i]&#x3D;E[i-1]+\frac{2^{i-1}-1}{i}$</p><p>我们化简移项等操作$xjb$搞就$AC$了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试28「阴阳·虎·山洞」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9528%E3%80%8C%E9%98%B4%E9%98%B3%C2%B7%E8%99%8E%C2%B7%E5%B1%B1%E6%B4%9E%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9528%E3%80%8C%E9%98%B4%E9%98%B3%C2%B7%E8%99%8E%C2%B7%E5%B1%B1%E6%B4%9E%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-28 17:42</p><p>写这几个题解我觉得我就像在按照官方题解抄一样</p><h2 id="阴阳"><a href="#阴阳" class="headerlink" title="阴阳"></a>阴阳</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将题目中给的阴阳看作黑色和白色</p><p>首先我们观察到最后生成图中某种颜色必须是竖着单调递增或竖着单调递减</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190828164828789-1039641252.png"></p><p>类似这样</p><p>否则不满足这个条件</p><blockquote><p>但合法染色方案必须满足任意两个同颜色格子之间的格子也必须是该颜色。</p></blockquote><p>然后我们分四种情况统计，</p><p>1.黑色居于左侧而且分界点单调不降，</p><p>2.黑色居于左侧而且分界点单调不升，</p><p>3.白色居于左侧而且分界点单调不降，</p><p>4.白色居于左侧而且分界点单调不升。</p><p>我们发现这样会算重，</p><p>dp然后手动容斥，</p><p>1，2会算重左面每列全是黑色</p><p>类似于</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190828165243053-675554939.png"></p><p>类似的3，4会算重左面全是白色</p><p>那么上面全是黑色我们也会算重（2，3）</p><p>上面全是白色我们仍然会算重</p><p>手动容斥</p><p>题解应该都能看懂，实现稍难（不用说了我码力太弱）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111const ll mod=1e9+7;ll can[A][A][10],f[A][A][2],up[A][A],down[A][A];//can定义为i行从1--j染成B剩下染成W是否合法char ch[A][A];ll n,m,flag1,flag2,ans;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%s&quot;,ch[i]+1);    for(ll i=1;i&lt;=n;i++)&#123;        ll maxpos=0;        for(ll j=1;j&lt;=m;j++)&#123;            if(ch[i][j]==&#39;W&#39;) break;            if(ch[i][j]==&#39;B&#39;) maxpos=j;        &#125;        for(ll j=maxpos+1;j&lt;=m;j++)            if(ch[i][j]==&#39;B&#39;)&#123;                maxpos=m+1;    break;            &#125;        ll now=maxpos;        while(ch[i][now]!=&#39;W&#39;&amp;&amp;now&lt;=m)            can[i][now][1]=1,now++;    &#125;        for(ll i=1;i&lt;=n;i++)&#123;        ll maxpos=m+1;        for(ll j=m;j&gt;=1;j--)&#123;            if(ch[i][j]==&#39;W&#39;) break;            if(ch[i][j]==&#39;B&#39;) maxpos=j;        &#125;        for(ll j=maxpos-1;j&gt;=1;j--)            if(ch[i][j]==&#39;B&#39;)&#123;                maxpos=-1; break;            &#125;        ll now=maxpos;        while(ch[i][now]!=&#39;W&#39;&amp;&amp;now&gt;=0)            can[i][m-now+1][2]=1,now--;    &#125;    for(ll i=0;i&lt;=m;i++)        up[0][i]=1,down[0][i]=1;    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=0;j&lt;=m;j++)&#123;            if(!can[i][j][1]) continue;            f[i][j][0]=up[i-1][j];            f[i][j][1]=down[i-1][j];//            printf(&quot;up[%lld][%lld]=%lld down=%lld\n&quot;,i-1,j,up[i-1][j],down[i-1][j]);        &#125;        for(ll j=0;j&lt;=m;j++)            up[i][j]=(up[i][j-1]+f[i][j][0])%mod/*,printf(&quot;f=%lld up=%lld\n&quot;,f[i][j][0],up[i][j])*/;        for(ll j=m;j&gt;=0;j--)            down[i][j]=(down[i][j+1]+f[i][j][1])%mod;//        printf(&quot;up=%lld down=%lld\n&quot;,up[n][m],down[n][0]);    &#125;/*    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))&#123;        for(ll j=1;j&lt;=m;j++)&#123;            printf(&quot;%lld &quot;,can[i][j][1]);        &#125;    &#125;*/    memset(f,0,sizeof(f));    ans=(ans+up[n][m]+down[n][0]+mod)%mod;//    printf(&quot;ans=%lld\n&quot;,ans);    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=0;j&lt;=m;j++)&#123;            if(!can[i][j][2]) continue;            f[i][j][0]=up[i-1][j];            f[i][j][1]=down[i-1][j];        &#125;        for(ll j=0;j&lt;=m;j++)            up[i][j]=(up[i][j-1]+f[i][j][0])%mod;        for(ll j=m;j&gt;=0;j--)            down[i][j]=(down[i][j+1]+f[i][j][1])%mod;    &#125;//    printf(&quot;up=%lld down=%lld\n&quot;,up[n][m],down[n][0]);    ans=(ans+up[n][m]+down[n][0]+mod)%mod;//    printf(&quot;ans=%lld\n&quot;,ans);    memset(f,0,sizeof(f));    //减去左右重复    for(ll i=1;i&lt;m;i++)&#123;        ll flag=0;        for(ll j=1;j&lt;=n;j++)            if(!can[j][i][1])&#123;                flag=1;break;            &#125;        if(!flag) ans--;    &#125;    for(ll i=1;i&lt;m;i++)&#123;        ll flag=0;        for(ll j=1;j&lt;=n;j++)            if(!can[j][i][2])&#123;                flag=1;break;            &#125;        if(!flag) ans--;    &#125;    //减去上下    //若上面为B下面只能为W    for(ll i=1;i&lt;n;i++)&#123;        ll flag=0;        for(ll j=1;j&lt;=i;j++)            if(!can[j][m][1])&#123;                flag=1;break;            &#125;        for(ll j=i+1;j&lt;=n;j++)            if(!can[j][0][1])&#123;                flag=1;break;            &#125;        if(flag)continue;        ans--;    &#125;    for(ll i=n;i&gt;=2;i--)&#123;        ll flag=0;        for(ll j=1;j&lt;=i-1;j++)            if(!can[j][0][1])&#123;                flag=1;break;            &#125;        for(ll j=i;j&lt;=n;j++)            if(!can[j][m][1])&#123;                flag=1;break;            &#125;        if(flag)continue;        ans--;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        if(!can[i][0][1])    flag1=1;        if(!can[i][m][1])    flag2=1;    &#125;    if(!flag1) ans-=3;    if(!flag2) ans-=3;    printf(&quot;%lld\n&quot;,(ans+mod)%mod);&#125;</code></pre><p>View Code</p><h2 id="虎"><a href="#虎" class="headerlink" title="虎"></a>虎</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>我们发现一条性质我们子树内两个点要变成黑色我们同时经过树外的边不会使次数变优（除了直接与lca相连的边）</p><p>然后根据这条性质，我们发现我们一定存在一种最优方案使任意两条染色路径互不相交</p><p>然后我们进行贪心</p><p>首先题目中给的无要求的边我们进行缩边</p><p>我们统计到当前子树都已经全部染成黑色了，那么我们只用考虑与它相连就行</p><p>拿下面这个图举例（假设全部为白边）</p><p>你考虑3时你6的子树都处理完了，然后你遇到两个白色边（3，6）（3，7）你贪心直接染色就行，那么如果最后剩下一个没有染色怎么办，显然我们不用管，我们发现与3相连的边（1，3）这条边是必定被染色的，2本来要和3进行染色让（1，2）（1，3）进行染色，我们现在把这个边拉过来变成（2，8）进行染色就行了</p><p>那么依据上文说的，我们只需要让与3相连白边个数（除了父亲与它相连边）&#x2F;2就行了</p><p>推广到所有点统计白边个数&#x2F;2即可</p><p>然后这样做对于根来说会出错，特判一下就AC了（对于根来说没有办法再让自己父亲拉边过来）</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190828173617525-1449145708.png"></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;#define R register#define ll long longinline ll read()//-------&#123;    ll aa=0;char cc=getchar();    while(cc&lt;&#39;0&#39;||cc&gt;&#39;9&#39;) cc=getchar();    while(cc&lt;=&#39;9&#39;&amp;&amp;cc&gt;=&#39;0&#39;)        &#123;aa=(aa&lt;&lt;3)+(aa&lt;&lt;1)+(cc^48);cc=getchar();&#125;    return aa;&#125;const int N=1000005;struct tree&#123;    int v,last;&#125;tr[N&lt;&lt;1];int tot,first[N];inline void add(int x,int y)&#123;    tr[++tot]=(tree)&#123;y,first[x]&#125;;    first[x]=tot;return;&#125;int n,ans,mp[N],vi[N];int dfs(int x,int fa)&#123;    int sum=0;vi[x]=1;    for(R int i=first[x],v;i;i=tr[i].last)&#123;        v=tr[i].v;        if(v==fa)continue;        dfs(v,x);        sum^=1;        if(!sum)++ans;    &#125;    return sum;&#125;int main()&#123;    //freopen(&quot;tight.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;tight.out&quot;,&quot;w&quot;,stdout);    n=read();mp[1]=++mp[0];    for(R int i=2,x,y,z;i&lt;=n;++i)&#123;        x=read();y=read();z=read();        if(!z)&#123;            if(mp[i])mp[x]=mp[i];            else if(mp[x])mp[i]=mp[x];            else mp[i]=mp[x]=++mp[0];            continue;        &#125;        if(!mp[i])mp[i]=++mp[0];        if(!mp[x])mp[x]=++mp[0];        if(y)continue;        add(mp[i],mp[x]);        add(mp[x],mp[i]);    &#125;    for(R int i=1;i&lt;=mp[0];++i)        if(!vi[i])            if(dfs(i,i))++ans;    printf(&quot;%d&quot;,ans);    return 0;&#125;</code></pre><p>View Code</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;vector&gt;#define R registerusing namespace std;inline int read()&#123;    int f=1,x=0;char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125;    while(ch&lt;=&#39;9&#39;&amp;&amp;ch&gt;=&#39;0&#39;)&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();&#125;    return f*x;&#125;const int maxn=1000005;struct node&#123;    int v,nxt,da;&#125;e[2*maxn];int h[maxn],nu;void add(int x,int y,int fl)&#123;    e[++nu].v=y;    e[nu].da=fl;    e[nu].nxt=h[x];    h[x]=nu;&#125;int n,f[maxn],ans;int dfs(int x,int xf)&#123;    int cnt=0;    for(int i=h[x];i;i=e[i].nxt)    &#123;        int y=e[i].v,k=e[i].da;        if(y==xf)continue;        int nw=dfs(y,x);        //cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl;        if(k==1)&#123;cnt++;continue;&#125;        if(!nw)continue;        if(k==3)ans++;        else cnt++;    &#125;    ans+=cnt/2;    if(cnt%2==0)return 0;    return 1;&#125;int main()&#123;    //freopen(&quot;data&quot;,&quot;r&quot;,stdin);    n=read();    int qj1=1,num1=0;    for(int x=2;x&lt;=n;++x)    &#123;        int y=read(),s=read(),t=read(),fl;        if(t==0)fl=2;        if(s==0&amp;&amp;t==1)num1++,fl=1;        if(s==1&amp;&amp;t==1)fl=3;        add(x,y,fl);        add(y,x,fl);    &#125;    int nw=dfs(1,0);    ans+=nw;    printf(&quot;%d\n&quot;,ans);&#125;/*g++ 1.cpp -o 1./1*/</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试26「嚎叫响彻在贪婪的机房·主仆见证了 Hobo 的离别·征途堆积出友情的永恒」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9526%E3%80%8C%E5%9A%8E%E5%8F%AB%E5%93%8D%E5%BD%BB%E5%9C%A8%E8%B4%AA%E5%A9%AA%E7%9A%84%E6%9C%BA%E6%88%BF%C2%B7%E4%B8%BB%E4%BB%86%E8%A7%81%E8%AF%81%E4%BA%86%20Hobo%20%E7%9A%84%E7%A6%BB%E5%88%AB%C2%B7%E5%BE%81%E9%80%94%E5%A0%86%E7%A7%AF%E5%87%BA%E5%8F%8B%E6%83%85%E7%9A%84%E6%B0%B8%E6%81%92%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9526%E3%80%8C%E5%9A%8E%E5%8F%AB%E5%93%8D%E5%BD%BB%E5%9C%A8%E8%B4%AA%E5%A9%AA%E7%9A%84%E6%9C%BA%E6%88%BF%C2%B7%E4%B8%BB%E4%BB%86%E8%A7%81%E8%AF%81%E4%BA%86%20Hobo%20%E7%9A%84%E7%A6%BB%E5%88%AB%C2%B7%E5%BE%81%E9%80%94%E5%A0%86%E7%A7%AF%E5%87%BA%E5%8F%8B%E6%83%85%E7%9A%84%E6%B0%B8%E6%81%92%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-19 16:25</p><p>题目比较神仙，注意是题目神仙</p><p>贪婪暗示贪心，堆积暗示堆优化$%%%%%%%$</p><p>两个乱搞$+$一个堆优化$dp$</p><h2 id="嚎叫响彻在贪婪的机房"><a href="#嚎叫响彻在贪婪的机房" class="headerlink" title="嚎叫响彻在贪婪的机房"></a>嚎叫响彻在贪婪的机房</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于一个序列来说只要他们差的$gcd$不为$1$就可以构成等差数列</p><p>例如</p><p>$2$ $4$ $16$</p><p>$2$与$4$差$2$ $4$与$16$差$12$</p><p>$gcd(2,12)!&#x3D;1$故构成等差序列</p><p>那么我们维护公差,然后每次的差和当前公差比较,若$gcd&#x3D;&#x3D;1$则等差数列从这里断开,否则将公差置成$gcd$</p><p>举个例子</p><p>$2$ $8$ $14$ $16$ $18$ $20$</p><p>$2$ $8$ $14$构成公差为$6$等差数列,之后$16$ $18$ $20$构成公差为$2$等差序列</p><p>显然我们可以让他们合并为公差为$2$等差序列</p><p>注意判重,判差为$1$,</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return x*f;&#125;set&lt;ll&gt; st;set&lt;ll&gt; ::iterator it;ll n,m,d=0,ans=0;ll a[A];void  cl(ll x)&#123;    st.clear();    d=0;    ans++;    st.insert(a[x]);&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;int main()&#123;    n=read();    for(ll i=1;i&lt;=n;i++)&#123;        a[i]=read();    &#125;    cl(1);    for(ll i=2;i&lt;=n;i++)&#123;        if((it=st.find(a[i]))!=st.end()) &#123;//        printf(&quot;i=-%lld\n&quot;,i);            cl(i);            continue;        &#125;        if(abs(a[i]-a[i-1])==1||a[i]==a[i-1])&#123;            cl(i);            continue;        &#125;//        printf(&quot;d=%lld\n&quot;,d);        if(d==0)&#123;            st.insert(a[i]);            d=abs(a[i]-a[i-1]);        &#125;        else &#123;            ll g=gcd(d,abs(a[i]-a[i-1]));//            printf(&quot;g=%lld d=%lld abs=%lld\n&quot;,g,d,abs(a[i]-a[i-1]));            if(g==1||g==0)&#123;                cl(i);            &#125;            else &#123;                st.insert(a[i]);                d=g;            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="主仆见证了-Hobo-的离别"><a href="#主仆见证了-Hobo-的离别" class="headerlink" title="主仆见证了 Hobo 的离别"></a>主仆见证了 Hobo 的离别</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>建边,建立包含关系的树,例如$1,2$交集为$3$那么$1$包含$3$,$2$包含$3$</p><p>再例如$1,2$并集为$3$那么$3$包含$1$,$3$包含$2$</p><p>询问$x$,$y$所属关系就从$y$开始$dfs$若找到$x$即符合</p><p>暴力就是正解</p><p>让我们分析一下复杂度</p><p>题目中说</p><blockquote><p><strong>新元件的编号等于融合之前元件的总个数加一</strong> 。当然，参与融合的 K个元件融合之后依然存在，并且<strong>每个元件至多参与一次融合</strong> 。</p></blockquote><p>数据范围</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190819160915315-138333580.png"></p><p>极限情况下肯定就是分开连边</p><p>那么$250000$个分开连边,产生$125000$,然后下一层产生$62500$再下一层…..</p><p>显然是$log$的最终是$18$层</p><p>而且我们建出来树是下图这样的从一点往下搜</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190819161320072-1832388747.png"></p><p>所以极限复杂度$18*250000$可过</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return x*f;&#125;ll n,m,cnt,ok,tot=0;ll some[A],fa[A],nxt[A],ver[A],head[A];ll find(ll x)&#123;    if(fa[x]!=x)&#123;        fa[x]=find(fa[x]);    &#125;    return fa[x];&#125;void haha()&#123;    for(ll i=1;i&lt;=500000;i++)&#123;        fa[i]=i;    &#125;&#125;void merge(ll x,ll y)&#123;    x=find(x),y=find(y);    if(x!=y) fa[x]=y;&#125;void add(ll x,ll y)&#123;//    printf(&quot;x=%lld y=%lld\n&quot;,x,y);    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void dfs(ll x,ll pre,ll ineed)&#123;    if(x==ineed) ok=1;    if(ok) return ;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue;        dfs(y,x,ineed);    &#125;&#125;/*ll ithave[A],beihave[A];ll getithave(ll x)&#123;    if(ithave[x]!=x)&#123;        ithave[x]=getithave(ithave[x]);    &#125;    return ithave[x];&#125;void mergeit(ll x,ll y)&#123;    x=getithave(x);    y=getithave(y);    if(ithave[x]!=ithave[y])&#123;        ithave[x]=y;    &#125;&#125;ll getbeihave(ll x)&#123;    if(beihave[x]!=x)&#123;        beihave[x]=getbeihave(beihave[x]);    &#125;    return beihave[x];&#125;void mergebei(ll x,ll y)&#123;    x=getbeihave(x);    y=getbeihave(y);    if(beihave[x]!=beihave[y])&#123;        beihave[x]=y;    &#125;&#125;*/int main()&#123;    n=read(),m=read();    cnt=n;    for(ll i=1,opt,ques,k,QwQ;i&lt;=m;i++)&#123;        ques=read();        if(ques==0)&#123;            opt=read(),k=read();            cnt++;            if(opt==1)&#123;                for(ll j=1;j&lt;=k;j++)&#123;                    QwQ=read();                    //1属于2 1---&gt;2                    add(cnt,QwQ);                    if(k==1)                        add(QwQ,cnt);                &#125;            &#125;            else &#123;                for(ll j=1;j&lt;=k;j++)&#123;                    QwQ=read();                    add(QwQ,cnt);                    if(k==1)                        add(cnt,QwQ);                &#125;            &#125;        &#125;        else&#123;            ok=0;            ques=read(),QwQ=read();            dfs(QwQ,0,ques);            printf(&quot;%lld\n&quot;,ok);        &#125;    &#125;&#125;</code></pre><p>View Code</p><h2 id="征途堆积出友情的永恒"><a href="#征途堆积出友情的永恒" class="headerlink" title="征途堆积出友情的永恒"></a>征途堆积出友情的永恒</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先普通dp应该都会吧</p><p>$f[i]&#x3D;min(f[j]+max(sum[i]-sum[j],b[j]))$</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=max(i-k,0ll);j&lt;=i-1;j++)&#123;            ll fee=max(sum[i]-sum[j],a[j]);            f[i]=min(f[j]+fee,f[i]);        &#125;    &#125;</code></pre><p>一言不和上代码</p><p>怎么优化,</p><p>线段树或者堆</p><p>思考sum[i]变化很烦,线段树很难维护(然而Mr_zkt维护出来了$%%%$)我没打线段树</p><p>用堆维护我们需要寻找不变量显然$f[j]+b[j]$和$f[j]-sum[j]$是不变量</p><p>开两个小根堆,一个维护$min(f[j]+b[j])$一个维护$f[j]-sum[j]$</p><p>转移时$min(q1.top(),q2.top+sum[i])$</p><p>细节稍多</p><ul><li>$STL$的各种$empty$往上仍,</li><li>判断是否可以转移(&lt;&#x3D;k)限制</li><li>在$f[j]+b[j]$$&lt;$$f[j]-sum[j]+sum[i]$时第一个堆不合法,第一个堆扔到第二个堆</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll f[A],a[A],sum[A],b[A];ll n,k,minn;struct node&#123;    ll id,val;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.val&gt;b.val;    &#125;&#125;;priority_queue&lt;node&gt; q1,q2;//q1用来存f+b q2存 f-sll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+(c-&#39;0&#39;);        c=getchar();    &#125;    return f*x;&#125;void work()&#123;    memset(f,0x3f,sizeof(f));    f[0]=0;    node o;    o.id=0,o.val=b[0];    q1.push(o);    for(ll i=1;i&lt;=n;i++)&#123;        node x1,x2;        while(!q1.empty())&#123;            x1=q1.top();            if(x1.id&gt;=i-k) break;            q1.pop();        &#125;        while(!q2.empty())&#123;            x2=q2.top();            if(x2.id&gt;=i-k) break;            q2.pop();        &#125;        while(!q1.empty())&#123;            x1=q1.top();            if(x1.val&gt;=f[x1.id]-sum[x1.id]+sum[i]) break;//            printf(&quot;feifa\n&quot;);//            printf(&quot;x1.val=%lld id=%lld f-s=%lld\n&quot;,x1.val,x1.id,f[x1.id]-sum[x1.id]+sum[i]);            q1.pop();            node x3;            x3.id=x1.id,x3.val=f[x1.id]-sum[x1.id];            q2.push(x3);        &#125;        while(!q1.empty())&#123;            x1=q1.top();            if(x1.id&gt;=i-k) break;            q1.pop();        &#125;        while(!q2.empty())&#123;            x2=q2.top();            if(x2.id&gt;=i-k) break;            q2.pop();        &#125;//        printf(&quot;q1.top id=%lld val=%lld 2=%lld %lld\n&quot;,x1.id,x1.val,x2.id,x2.val);        //f[i]=min(x1.val,x2.val+sum[i]);        if(!q1.empty())f[i]=min(0x7ffffffffff,q1.top().val);        if(!q2.empty())f[i]=min(0x7ffffffffff,q2.top().val+sum[i]);//        printf(&quot;f[%lld]=%lld\n&quot;,i,f[i]);        x1.id=i,x1.val=f[i]+b[i];        q1.push(x1);    &#125;&#125;int main()&#123;    n=read(),k=read();    for(ll i=1;i&lt;=n;i++)&#123;        sum[i]=read();        sum[i]+=sum[i-1];    &#125;    for(ll i=0;i&lt;n;i++)&#123;        b[i]=read();    &#125;    work();    printf(&quot;%lld\n&quot;,f[n]);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试25「字符串·乌鸦喝水·所陀门王的宝藏（陀螺王）」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9525%E3%80%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%C2%B7%E4%B9%8C%E9%B8%A6%E5%96%9D%E6%B0%B4%C2%B7%E6%89%80%E9%99%80%E9%97%A8%E7%8E%8B%E7%9A%84%E5%AE%9D%E8%97%8F%EF%BC%88%E9%99%80%E8%9E%BA%E7%8E%8B%EF%BC%89%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9525%E3%80%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%C2%B7%E4%B9%8C%E9%B8%A6%E5%96%9D%E6%B0%B4%C2%B7%E6%89%80%E9%99%80%E9%97%A8%E7%8E%8B%E7%9A%84%E5%AE%9D%E8%97%8F%EF%BC%88%E9%99%80%E8%9E%BA%E7%8E%8B%EF%BC%89%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-18 21:42</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>没看出catalan怎么办</p><p>dp打表啊!</p><p>考虑大力dp拿到30分好成绩!顺便收获一张表</p><p>打表发现$C_{n+m}^{m}-C_{n+m}^{m-1}$</p><p>仔细观察然后发现其实就是之前的网格那个题</p><p>那么我们回顾一下网格那个题</p><p>先看最简单的n&#x3D;&#x3D;m情况</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190818213257572-570696453.png"></p><p>求左下角走到右上角方案数,不能经过中间那条线</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190818213839407-586295744.png"></p><p>考虑大力容斥,首先总方案数$C_{2*n}^{n}$很好求,那么我们现在任务就是求不合法的</p><p>我们考虑到如果经过中间那条线我们至少要经过红色那条线,考虑求从左下角超过那条蓝线(不合法)方案数,</p><p>如果有红线限制我们好像仍然难以求出,我们怎么消除红线影响</p><p>方法非常简单:考虑将正方形翻折,那么我们经过绿线走到右上角就转变为了沿绿线走再沿蓝线走方案,这样我们就摆脱了红线的控制</p><p>那么我们就转化为了从左下角走到翻折后多边形所在角在位置</p><p>得到$C_{(n+1)+(n-1)}^{n-1}$即$C_{2*n}^{n-1}$</p><p>相减即可</p><p>那么如果$n!&#x3D;m$类似$C_{n+m}^{m}-C_{n+m}^{m-1}$,自己画画即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我不想放了</p><h2 id="乌鸦喝水"><a href="#乌鸦喝水" class="headerlink" title="乌鸦喝水"></a>乌鸦喝水</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="55分算法"><a href="#55分算法" class="headerlink" title="$55分算法$"></a>$55分算法$</h4><p>先预处理出来能喝多少次</p><p>$n*m$ 复杂度,</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll cishu,maxn,n,m,all=0;ll a[A],he[A],xiajiang[A];int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;maxn);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;xiajiang[i]);        he[i]=(maxn-a[i])/xiajiang[i];    &#125;    for(ll i=1;i&lt;=m;i++)&#123;        all=1;        for(ll j=1;j&lt;=n;j++)&#123;            if(he[j]&gt;=cishu)&#123;                cishu++;                all=0;            &#125;        &#125;        if(all) break;    &#125;    printf(&quot;%lld\n&quot;,cishu);&#125;</code></pre><p>View Code</p><h4 id="95分算法"><a href="#95分算法" class="headerlink" title="$95分算法$"></a>$95分算法$</h4><p>我们重复枚举了很多无用的状态,当前已经喝不到我们不用再考虑,于是拿链表优化一下</p><h4 id="100分算法"><a href="#100分算法" class="headerlink" title="$100分算法$"></a>$100分算法$</h4><p>这种题肯定有性质,这么大的范围一定有性质.</p><p>性质: 水少的喝了$k$次那么水多的一定至少也喝了$k$次</p><p>我们考虑排序,然而排序后打乱了顺序怎么办,拿一个树状数组维护一下排序前的</p><p>我们可以快速算出在当前水壶喝了多少水</p><p>思考已知之前喝了$ans$次当前还剩$w$个水壶没喝完,这个水壶能喝$cnt$次</p><p>那么它能喝$\frac{cnt-ans}{w}$轮</p><p>考虑喝完这么多轮会有剩余,这时用树状数组找sum就完了</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111ll c[A],xiajiang[A],he[A],a[A];ll n,m,maxn,ans=0;struct toot&#123;    ll pos,cnt;    friend bool operator &lt; (const toot &amp;a,const toot &amp;b)&#123;        return ((a.cnt==b.cnt)?(a.pos&lt;b.pos):(a.cnt&lt;b.cnt));    &#125;&#125;que[A];void add(ll l,ll a)&#123;    for(ll i=l;i&lt;=n;i+=(i&amp;-i))        c[i]+=a;&#125;ll sum(ll l)&#123;    ll sum=0;    for(ll i=l;i&gt;=1;i-=(i&amp;-i))        sum+=c[i];    return sum;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;maxn);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;xiajiang[i]);        he[i]=(maxn-a[i])/xiajiang[i]+1;        que[i].cnt=he[i],que[i].pos=i;        add(i,1);    &#125;    sort(que+1,que+n+1);//    printf(&quot;que[1]=%lld\n&quot;,que[1].cnt);    for(ll i=1;i&lt;=n;i++)&#123;        add(que[i].pos,-1);        if(que[i].cnt&lt;=0) continue;        if(que[i].cnt-ans&lt;=0) continue;        ll cnt=(que[i].cnt-ans)/(n-i+1);        if(cnt&gt;=m)&#123;            ans+=m;            continue;        &#125;        if(sum(que[i].pos)&lt;((que[i].cnt-ans)%(n-i+1)))            cnt++;        ans+=cnt;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="所驼门王的宝藏-骆驼王"><a href="#所驼门王的宝藏-骆驼王" class="headerlink" title="所驼门王的宝藏(骆驼王)"></a>所驼门王的宝藏(骆驼王)</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>缩点跑一个类似最长链的东西</p><p>数组大小比较谜</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 2000010ll n,m,k,tot=0,cnt=0;ll id(ll x,ll y)&#123;    return (x-1)*m+y;&#125;inline ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c-&#39;0&#39;);        c=getchar();    &#125;    return f*x;&#125;ll head[A],nxt[A&lt;&lt;1],ver[A&lt;&lt;1],a[521000],b[521000],c[521000],sz[A],dfn[A],low[A],sta[A],belong[A],f[A];ll head_[A],nxt_[A&lt;&lt;1],ver_[A&lt;&lt;1];map&lt; pair&lt;ll,ll&gt;,ll &gt; mp;ll top=0,toot=0,scc=0,tot_=0;bool flag[A],vis[A],ins[A];vector&lt;ll&gt; hang[A],lie[A];void add(ll x,ll y)&#123;//    printf(&quot;x=%d y=%d\n&quot;,x,y);    ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;void add2(ll x,ll y)&#123;//    printf(&quot;x=%d y=%d\n&quot;,x,y);    ver_[++tot_]=y;    nxt_[tot_]=head_[x];    head_[x]=tot_;&#125;void tarjan(ll x)&#123;    dfn[x]=low[x]=++toot;    sta[++top]=x;    ins[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(!dfn[y])&#123;            tarjan(y);            low[x]=min(low[x],low[y]);        &#125;        else if(ins[y])             low[x]=min(low[x],dfn[y]);    &#125;    if(low[x]==dfn[x])&#123;        ll y=0;        scc++;        while(1)&#123;            y=sta[top--];            belong[y]=scc;            ins[y]=0;            sz[scc]++;            if(y==x) break;        &#125;    &#125;&#125;ll dp(ll x,ll pre)&#123;    if(f[x]) return f[x];    f[x]=0;    for(ll i=head_[x];i;i=nxt_[i])&#123;        ll y=ver_[i];        ll nx=dp(y,x);//        printf(&quot;x=%d y=%d nx=%d\n&quot;,x,y,nx);        f[x]=max(f[x],nx);    &#125;    f[x]+=sz[x];    return f[x];&#125;void rebuilt()&#123;    for(ll i=1;i&lt;=k;i++)&#123;        for(ll j=head[i];j;j=nxt[j])&#123;            ll y=ver[j];            if(belong[i]!=belong[y])&#123;                add2(belong[i],belong[y]);            &#125;        &#125;    &#125;&#125;int main()&#123;    k=read(),n=read(),m=read();    for(ll i=1;i&lt;=k;i++)&#123;        a[i]=read(),b[i]=read(),c[i]=read();        mp[make_pair(a[i],b[i])]=i;        hang[a[i]].push_back(i);        lie[b[i]].push_back(i);    &#125;    for(ll i=1;i&lt;=k;i++)&#123;        if(c[i]==1)&#123;            for(ll j=0;j&lt;hang[a[i]].size();j++)&#123;                if(i!=hang[a[i]][j])add(i,hang[a[i]][j]);            &#125;        &#125;        if(c[i]==2)&#123;            for(ll j=0;j&lt;lie[b[i]].size();j++)&#123;                if(i!=lie[b[i]][j])add(i,lie[b[i]][j]);            &#125;        &#125;        if(c[i]==3)&#123;        ll _1_=mp[make_pair(a[i]-1,b[i])],_2_=mp[make_pair(a[i]+1,b[i])],_3_=mp[make_pair(a[i],b[i]+1)],_4_=mp[make_pair(a[i],b[i]-1)]        ,_5_=mp[make_pair(a[i]+1,b[i]+1)],_6_=mp[make_pair(a[i]+1,b[i]-1)],_7_=mp[make_pair(a[i]-1,b[i]-1)],_8_=mp[make_pair(a[i]-1,b[i]+1)];        if(_1_)    add(i,_1_);        if(_2_)    add(i,_2_);        if(_3_)    add(i,_3_);        if(_4_)    add(i,_4_);        if(_5_)    add(i,_5_);        if(_6_)    add(i,_6_);        if(_7_)    add(i,_7_);        if(_8_)    add(i,_8_);        &#125;    &#125;    for(ll i=1;i&lt;=k;i++)&#123;        if(!dfn[i])    tarjan(i);    &#125;//    for(ll i=1;i&lt;=k;i++)&#123;//        printf(&quot;belong=%d\n&quot;,belong[id(a[i],b[i])]);//    &#125;    rebuilt();    for(ll i=1;i&lt;=scc;i++)&#123;        if(!f[i])        dp(i,0);    &#125;        for(ll i=1;i&lt;=scc;i++)&#123;        f[0]=max(f[0],f[i]);    &#125;    printf(&quot;%d\n&quot;,f[0]);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试24「star way to hevaen·lost my music」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9524%E3%80%8Cstar%20way%20to%20hevaen%C2%B7lost%20my%20music%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9524%E3%80%8Cstar%20way%20to%20hevaen%C2%B7lost%20my%20music%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-17 20:27</p><h2 id="star-way-to-heaven"><a href="#star-way-to-heaven" class="headerlink" title="star way to heaven"></a>star way to heaven</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>大致尝试了一下并查集,记忆化搜索,最小生成树</p><p>最小生成树是正解,跑最小生成树然后找到最大的值</p><p><a href="https://blog.csdn.net/qq_41755258/article/details/84894980">欧几里德距离最小生成树学习</a></p><p>prim楞跑</p><p>至于为什么跑最小生成树不是跑最大生成树,你跑最大生成树连的边可能会^%$&amp;$%!#</p><p>感性理解手膜吧,我理解但说不清楚,稍微手膜就出来了,你可以举出一万种反例</p><p>代码实现细节比较多,技巧也比较多</p><p>注意边界处理,我们可以以一个边界为0,另一个边界权值为m,比较上下边界时不用再比较横坐标</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010010double cal(ll x1,ll y1,ll x2,ll y2)&#123;    return sqrt((double)((x1-x2)*(x1-x2))+(double)((y1-y2)*(y1-y2)));&#125;ll n,m,k;double ans;ll x[A],y[A];double dis[A];bool vis[A];int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    for(ll i=1;i&lt;=k;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]);        dis[i]=y[i];    &#125;    dis[k+1]=m;    while(1)&#123;        ll mi=0;        for(ll j=1;j&lt;=k+1;j++)            if(!vis[j]&amp;&amp;(mi==0||dis[j]&lt;dis[mi]))                mi=j;//        printf(&quot;mi=%lld\n&quot;,mi);        ans=max(ans,dis[mi]);        vis[mi]=1;        if(mi==k+1)&#123;            printf(&quot;%.10lf\n&quot;,ans/2);            return 0;        &#125;        for(ll j=1;j&lt;=k;j++)            dis[j]=min(dis[j],cal(x[j],y[j],x[mi],y[mi]));        dis[k+1]=min(dis[k+1],(double)(m-y[mi]));    &#125;&#125;</code></pre><p>代码</p><h2 id="lost-my-music"><a href="#lost-my-music" class="headerlink" title="lost my music"></a>lost my music</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>题目中说的很明显是一个斜率单调栈维护一下</p><p>然而这是树上问题,你暴力退栈你会被卡成$n^2$于是我又学习了一下可持久化栈</p><p><a href="https://blog.csdn.net/qq_35392050/article/details/74852721">可持久化栈学习</a></p><p>我用的是二分方法,好理解又好打</p><p>大致就是$dfs$时传一个$top$指针,然后你每次找到符合祖先链且斜率最大的地方,每次向下搜时只需要将当前对应位置栈设为$x$然后再回溯</p><p>这样我们就可以不用退栈</p><p>直接口胡肯定不能理解</p><p>| |&lt;-–你当前栈顶指向</p><p>| |</p><p>| |&lt;-–符合的位置,你只需要将当前栈指针指向当前,,,,,最后再回溯即可</p><p>| |</p><p>| |</p><p>或者换种方式理解</p><p>维护凸包</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190817204124973-1321745546.png"></p><p>你若当前可以更新那么赋成当前值斜率更新更大</p><p>代码实现</p><pre><code>void dfs(ll x,ll pre,ll de,ll top)&#123;    deep[x]=de;    ll k=get(x,top)+1,t1=sta[k],t2=sta[k-1];    if(x==1) k=1;    ans[x]=-1.0*(cal(t2,x));    sta[k]=x;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre)  continue;        dfs(y,x,de+1,k);    &#125;    sta[k]=t1;&#125;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll n,tot;double ans[A];ll deep[A],head[A],nxt[A],ver[A],c[A],sta[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;double cal(ll x,ll y)&#123;    return (double)(c[x]-c[y])/(1.0*(double)(deep[x]-deep[y]));&#125;ll get(ll x,ll h)&#123;    ll l=2,r=h,mid;    double k1,k2;    while(l&lt;=r)&#123;        mid=(l+r)&gt;&gt;1;        k1=-1.0*(cal(sta[mid],sta[mid-1]));        k2=-1.0*(cal(x,sta[mid]));        if(k1&lt;k2)r=mid-1;        else l=mid+1;    &#125;    return l-1;&#125;void dfs(ll x,ll pre,ll de,ll top)&#123;    deep[x]=de;    ll k=get(x,top)+1,t1=sta[k],t2=sta[k-1];    if(x==1) k=1;    ans[x]=-1.0*(cal(t2,x));    sta[k]=x;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre)  continue;        dfs(y,x,de+1,k);    &#125;    sta[k]=t1;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;c[i]);//printf(&quot;***\n&quot;);    &#125;    for(ll i=2,a;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a);        add(a,i);    &#125;    dfs(1,0,1,0);    for(ll i=2;i&lt;=n;i++)&#123;        printf(&quot;%lf\n&quot;,ans[i]);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试23「mine·water·gcd」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9523%E3%80%8Cmine%C2%B7water%C2%B7gcd%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9523%E3%80%8Cmine%C2%B7water%C2%B7gcd%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-16 15:58</p><h2 id="mine"><a href="#mine" class="headerlink" title="mine"></a>mine</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一道比较水的dp</p><p>考试因为初始化挂掉了只有$80$分</p><p>代码有注释</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//无脑dp#define ll long long#define A 2222222const ll mod=1e9+7;//设f[x][5][2]为当前是第x个格子,当前填什么 0前面填1后面填ll f[A][5][2];//0表示0雷,1表示一个雷 2表示两个雷 3*ll n,ans=0;char ch[A];void debuger()&#123;    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=0;j&lt;=3;j++)&#123;            if(j==1)&#123;                printf(&quot;f[%lld][1][0]=%lld f[%lld][1][1]=%lld &quot;,i,f[i][1][0],i,f[i][1][1]);            &#125;            else printf(&quot;f[%lld][%lld]=%lld &quot;,i,j,f[i][j][0]);        &#125;&#125;int main()&#123;    scanf(&quot;%s&quot;,ch+1);    n=strlen(ch+1);    if(ch[1]==&#39;*&#39;)&#123;        f[0][1][1]=1;    &#125;    else if(ch[1]==&#39;?&#39;)&#123;        f[0][1][1]=1;        f[0][0][0]=1;    &#125;    else if(ch[1]==&#39;1&#39;)&#123;        f[0][0][0]=1;    &#125;    else if(ch[1]==&#39;0&#39;)&#123;        f[0][0][0]=1;    &#125;    for(ll x=1;x&lt;=n;x++)&#123;        if(ch[x]==&#39;?&#39;)&#123;            f[x][3][0]=(f[x-1][1][1]+f[x-1][2][0]+f[x-1][3][0])%mod;            f[x][0][0]=(f[x-1][1][0]+f[x-1][0][0])%mod;            f[x][2][0]=(f[x-1][3][0])%mod;            f[x][1][0]=(f[x-1][3][0])%mod;            f[x][1][1]=(f[x-1][1][0]+f[x-1][0][0])%mod;        &#125;        else if(ch[x]==&#39;*&#39;)&#123;            f[x][3][0]=(f[x-1][1][1]+f[x-1][2][0]+f[x-1][3][0])%mod;            //若当前格子是雷,前面格子可以是1且雷在后,两个雷标记,雷        &#125;        else if(ch[x]==&#39;0&#39;)&#123;            f[x][0][0]=(f[x-1][1][0]+f[x-1][0][0])%mod;            //若当前格子是0雷标记,前面格子可以是0雷标记或1雷但雷在前        &#125;        else if(ch[x]==&#39;2&#39;)&#123;            f[x][2][0]=(f[x-1][3][0])%mod;            //若当前格子是2雷标记,前面格子必须是雷        &#125;        else if(ch[x]==&#39;1&#39;)&#123;            f[x][1][0]=f[x-1][3][0];            //若雷在前,前面格子必须是雷            f[x][1][1]=(f[x-1][1][0]+f[x-1][0][0])%mod;            //若雷在后,前面格子可以是1雷标记但雷在前,或是无雷标记        &#125;    &#125;//    debuger();    ans=(ans+f[n][1][0]+f[n][0][0])%mod;    ans=(ans+f[n][3][0])%mod;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><h2 id="water"><a href="#water" class="headerlink" title="water"></a>water</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>一道比较水的贪心</p><p>或是一道比较难的图论</p><p>看你怎么做了</p><p>下面是贪心做法</p><p>不断地去找最低的那个小块进行灌水，这是肯定的。</p><p>由于需要一直找最小值，所以用到最小堆来进行优化。</p><p>初始化，边界是肯定不能积水的，因为肯定会流出来。所以在一开始所有的边界都设置为已访问标记。将边界上所有的点都加进堆里，并不断地调整堆。</p><p>在边界中取最低的那一个小块进行扩展，记录这个最小的节点高度为t<br>，扩展到的内部节点如果比t小，那么就灌水，也就是将扩展到的节点高度上升到t，不要忘了统计ans。并同时将上升后的点加进堆。如果扩展到的点比t高，也就相当于一个边界，将这个点直接加进堆。</p><p>注意如果为$-$那么它一定是要积水的而且至少积水到0</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 510ll h[A][A],a[A][A];bool vis[A][A];struct node&#123;    ll x,y,high;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.high&gt;b.high;    &#125;&#125;;priority_queue&lt;node&gt; q;ll n,m;const ll nowx[5]=&#123;0,1,-1,0,0&#125;;const ll nowy[5]=&#123;0,0,0,1,-1&#125;;bool pan(ll x,ll y)&#123;    if(x&lt;1||x&gt;n||y&lt;1||y&gt;m||vis[x][y]) return 0;    return 1;&#125;void dfs(ll x,ll y,ll v)&#123;    vis[x][y]=1;    if(a[x][y]&gt;v)&#123;        node o;        o.x=x,o.y=y,o.high=a[x][y];        q.push(o);        return ;    &#125;    h[x][y]+=v-a[x][y];    for(ll i=1;i&lt;=4;i++)&#123;        ll xnow=x+nowx[i],ynow=y+nowy[i];        if(pan(xnow,ynow))            dfs(xnow,ynow,v);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            scanf(&quot;%lld&quot;,&amp;a[i][j]);            if(a[i][j]&lt;0)&#123;                h[i][j]=0-a[i][j];                a[i][j]=0;            &#125;            if(i==1||j==1||i==n||j==m)&#123;                node b;                b.x=i,b.y=j,b.high=a[i][j];                q.push(b);                vis[i][j]=1;            &#125;        &#125;    while(!q.empty())&#123;        node o=q.top();        q.pop();        ll x=o.x,y=o.y,high=o.high;        for(ll i=1;i&lt;=4;i++)&#123;            ll xnow=x+nowx[i],ynow=y+nowy[i];            if(pan(xnow,ynow))                dfs(xnow,ynow,high);        &#125;    &#125;    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=m;j++)&#123;            printf(&quot;%lld &quot;,h[i][j]);        &#125;&#125;</code></pre><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>奇妙的莫比乌斯,等我强了再补</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 1001010ll vis[A],mu[A],prime[A];long long g[A],s[A],su[A];ll get_[A];long long  ans,cnt=0;void get__mu(ll n)&#123;    mu[1]=1;    for(ll i=2;i&lt;=500000;i++)&#123;        if(!vis[i])&#123;            prime[++cnt]=i,mu[i]=-1;        &#125;        for(ll j=1;j&lt;=cnt&amp;&amp;prime[j]*1ll*i&lt;=500000;j++)&#123;            vis[prime[j]*1ll*i]=1;            if(i%prime[j]==0) break;            else mu[i*1ll*prime[j]]=-mu[i];        &#125;    &#125;&#125;ll n,m;void work(ll x,ll d)&#123;//    printf(&quot;x=%lld\n&quot;,x);    for(ll i=1;i&lt;=sqrt(x);i++)        if(!(x%i))&#123;        s[i]+=d;//        printf(&quot;x=%lld i=%lld \n&quot;,x,i);        if(i*1ll*i!=x)s[x/i]+=d;        ans-=mu[i]*1ll*g[i];        if(i*1ll*i!=x)ans-=mu[x/i]*1ll*g[x/i];        g[i]=s[i]*1ll*(s[i]-1)/2;        if(i*1ll*i!=x)g[x/i]=s[x/i]*1ll*(s[x/i]-1)/2;        ans+=mu[i]*1ll*g[i];        if(i*1ll*i!=x)ans+=mu[x/i]*1ll*g[x/i];    &#125;//    for(ll i=2;i&lt;=x;i++)&#123;//        printf(&quot;s[%lld]=%lld\n&quot;,i,s[i]);//    &#125;        printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    get__mu(510000);//    printf(&quot;mu=%lld\n&quot;,prime[3]);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;su[i]);    for(ll i=1,a;i&lt;=m;i++)&#123;        scanf(&quot;%d&quot;,&amp;a);        ll x=su[a];        if(get_[a]==0)            work(x,1),get_[a]=1;        else work(x,-1),get_[a]=0;    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试22「位运算」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9522%E3%80%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9522%E3%80%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-16 07:09</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190816062502629-1128137933.png"></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190816062528814-560135835.png"></p><p>范围n—–$100000$ m $30$</p><p>输出方案</p><p>这是一个很好的$dp$题</p><p>首先我们应该看出来一条性质只要你最后有方案达到$n$个$1$，那么你可以达到任何&#96;一种$n$个$1$的情况</p><p>例如</p><p>你最后可以达到$3$个$1$</p><p>那么你可以达到$11100 $ $ 01110$ $01011$ $01101$等方案</p><p>证明：题目里说的操作和优美值都是一的个数相关，只要我们可以达到$n$个一，我们可以通过变换$1$的位置得到多种方案</p><p>于是题目里给的$C$我们并不关心，我们只关心$1$的个数，我们把1都放到最右面,另外这也给我们下面dp提供方便</p><p>我们先看各个运算意义</p><p>假设你$x$和$y$中有$s$个重复的$1$求各个运算之后一的个数，</p><p>$&amp;$后$1$的个数就是$s$，</p><p>对于$|$我们如果都加的话重复的多加一次</p><p>$|$后$1$的个数就是$x+y-s$</p><p>重复变为0</p><p>^后$1$的个数就是$x+y-s-s$</p><p>然后我们可以尝试列一个$dp$</p><p>设$f[x][j]$表示第$x$个操作有$j$个$1$的情况，我们当有这种情况就设为$1$，设最后$C$中一的个数为$x$,我们只需要看$f[n][x]$,若$f[n][x]$为$1$递归找解(后面会说到,其实递归找解是这个题最难的地方),若为$0$就是无解</p><p>根据上面得出结论我们可以列出</p><p>枚举这次操作后重复个数为w,设这次优美值为$G[i]$,枚举之前1的个数为$j$</p><p>若这次操作为$&amp;$则$f[x][w]&#x3D;max(f[x-1][j],f[x][w])$</p><p>若为$|$ 则$f[x][G[i]+j-w]&#x3D;max(f[x][G[i]+j-w],f[x-1][j])$</p><p>类似的若为^则$f[x][G[i]+j-w<em>2]&#x3D;max(f[x][G[i]+j-w</em>2],f[x-1][j])$</p><p>注意一下边界以及循环枚举</p><pre><code>            for(ll w=max(0ll,G[i]+j-m);w&lt;=min(j,G[i]);w++)</code></pre><p>看这句max,因为当它比m大时一定有重叠部分,且重叠部分至少为$G[i]+j-m$</p><p>然后就到了这个题难点记录方案</p><p>思考我们已知条件</p><p>我们从后往前搜,我们目前知道的是最终值,我们每一次都把前一位的值算出来,再搜前一位</p><p>那么我们已知运算符号已知运算前后1的个数,和运算后的值,我们现在要做的就是求出前一位值,且我们知道这一定能找到一组合法解</p><p>三个运算符号分开考虑,</p><p>假设符号为$|$,我们已知当前1个数(G[i]),和这次操作之后1的个数,这次操作之前1的个数</p><p>我们只需要让这次操作之前数,这次操作数二进制下1完美覆盖掉这次操作1的个数即可</p><p>因为我们符号$|$,我们只需要一个从前扫,一个从后扫,类似ST重复无所谓</p><p>例如操作前$3$个$1$,这次操作$3个1$操作后$11011$,我们一个从前扫得到$11010$另一个得到$01011$</p><p>假设符号为$&amp;$,&amp;只会让数值变小,我们可以断定操作前1的个数和这次操作1一定&gt;&#x3D;操作后</p><p>我们先保证这些操作后上有值的位一定有$1$,然后我们分开放剩下的$1$</p><p>例如操作前$4$个$1$,这次操作$3$个$1$,操作后$10001$,我们先得到$10001$<br>$10001$,再分开放1得到$11101$和$10011$</p><p>假设我们当前符号^,思考^运行他会使相同的位置变成0,不同变为1</p><p>那么我们重复的地方可以算出是(之前1的个数+这次1的个数-操作后1的个数)&#x2F;2</p><p>然后先给不重复地方赋值,再分别给重复地方赋1</p><p>例如操作前$4$个$1$,这次操作$2$个$1$,操作后$11101$,我们先得到重复长度1,然后得到$11100$和$00001$,最后给重复赋值$11110$,$00011$</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>void dfs(ll pos,ll now)&#123;    if(pos==1)    &#123;        printf(&quot;%lld &quot;,now);        return ;    &#125;    ll cnt_1=0;//    printf(&quot;pos=%lld\n&quot;,pos);    for(ll i=1;i&lt;=m;i++)        if(now&amp;(1&lt;&lt;(i-1)))            cnt_1++;    if(ch[pos][1]==&#39;A&#39;)&#123;        ll nowk=now,tot=cnt_1,pr=pre[pos][cnt_1],nxtk=now;        //知道目前的数，知道目前cnt，知道之前cnt，求之前数        //因为是&amp;所以在满足k条件下尽量差开，分开放最优        //例如10001        //先放11001再放10111        for(ll i=1;i&lt;=m;i++)&#123;            if(tot==G[pos]) break;            if(!(now&amp;(1&lt;&lt;(i-1))))                nowk|=(1&lt;&lt;(i-1)),tot++;        &#125;        tot=cnt_1;        for(ll i=1;i&lt;=m;i++)&#123;            if(tot==pr) break;            if(!(nowk&amp;(1&lt;&lt;(i-1))))                nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;//        printf(&quot;nxtk=%lld nowk=%lld\n&quot;,nxtk,nowk);        dfs(pos-1,nxtk);        printf(&quot;%lld &quot;,nowk);    &#125;    if(ch[pos][1]==&#39;O&#39;)    &#123;        ll nowk=0,tot=0,pr=pre[pos][cnt_1],nxtk=0;        //知道目前的数，知道目前cnt，知道之前cnt，求之前数        //那么向kmp一样或无所谓        for(ll i=1;i&lt;=m;i++)        &#123;            if(tot==G[pos])break;            if(now&amp;(1&lt;&lt;(i-1)))                nowk|=(1&lt;&lt;(i-1)),tot++;        &#125;        tot=0;        for(ll i=m;i&gt;=1;i--)        &#123;            if(tot==pr)break;            if(now&amp;(1&lt;&lt;(i-1)))                            nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;//        printf(&quot;nx=%lld no=%lld\n&quot;,nxtk,nowk);        dfs(pos-1,nxtk);        printf(&quot;%lld &quot;,nowk);    &#125;    if(ch[pos][1]==&#39;X&#39;)&#123;        ll nowk=0,tot=0,pr=pre[pos][cnt_1],nxtk=0,lst=0;        ll chong=(pr+G[pos]-cnt_1)/2;        //计算出重合部分，重合部分就是第一个长度+第二个长度-总1数/2        for(ll i=1;i&lt;=m;i++)        &#123;            if(tot==G[pos]-chong)break;            if(now&amp;(1&lt;&lt;(i-1)))nowk|=(1&lt;&lt;(i-1)),tot++,lst=i;        &#125;        tot=0;        for(ll i=m;i&gt;=lst+1;i--)        &#123;            if(tot==pr-chong)break;            if(now&amp;(1&lt;&lt;(i-1)))nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;        tot=0;        for(ll i=1;i&lt;=m;i++)        &#123;            if(tot==chong)break;            if(!(now&amp;(1&lt;&lt;(i-1))))nowk|=(1&lt;&lt;(i-1)),nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;//        printf(&quot;nxk=%lld nok=%lld\n&quot;,nxtk,nowk);        dfs(pos-1,nxtk);        printf(&quot;%lld &quot;,nowk);    &#125;&#125;</code></pre><p>求方案代码</p><p>总代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll f[A][32],pre[A][32],G[A],dl[A];ll x,n,m,c;char ch[A][6];bitset&lt;36&gt; b;void dfs(ll pos,ll now)&#123;    if(pos==1)    &#123;        printf(&quot;%lld &quot;,now);        return ;    &#125;    ll cnt_1=0;//    printf(&quot;pos=%lld\n&quot;,pos);    for(ll i=1;i&lt;=m;i++)        if(now&amp;(1&lt;&lt;(i-1)))            cnt_1++;    if(ch[pos][1]==&#39;A&#39;)&#123;        ll nowk=now,tot=cnt_1,pr=pre[pos][cnt_1],nxtk=now;        //知道目前的数，知道目前cnt，知道之前cnt，求之前数        //因为是&amp;所以在满足k条件下尽量差开，分开放最优        //例如10001        //先放11001再放10111        for(ll i=1;i&lt;=m;i++)&#123;            if(tot==G[pos]) break;            if(!(now&amp;(1&lt;&lt;(i-1))))                nowk|=(1&lt;&lt;(i-1)),tot++;        &#125;        tot=cnt_1;        for(ll i=1;i&lt;=m;i++)&#123;            if(tot==pr) break;            if(!(nowk&amp;(1&lt;&lt;(i-1))))                nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;//        printf(&quot;nxtk=%lld nowk=%lld\n&quot;,nxtk,nowk);        dfs(pos-1,nxtk);        printf(&quot;%lld &quot;,nowk);    &#125;    if(ch[pos][1]==&#39;O&#39;)    &#123;        ll nowk=0,tot=0,pr=pre[pos][cnt_1],nxtk=0;        //知道目前的数，知道目前cnt，知道之前cnt，求之前数        //那么向kmp一样或无所谓        for(ll i=1;i&lt;=m;i++)        &#123;            if(tot==G[pos])break;            if(now&amp;(1&lt;&lt;(i-1)))                nowk|=(1&lt;&lt;(i-1)),tot++;        &#125;        tot=0;        for(ll i=m;i&gt;=1;i--)        &#123;            if(tot==pr)break;            if(now&amp;(1&lt;&lt;(i-1)))                            nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;//        printf(&quot;nx=%lld no=%lld\n&quot;,nxtk,nowk);        dfs(pos-1,nxtk);        printf(&quot;%lld &quot;,nowk);    &#125;    if(ch[pos][1]==&#39;X&#39;)&#123;        ll nowk=0,tot=0,pr=pre[pos][cnt_1],nxtk=0,lst=0;        ll chong=(pr+G[pos]-cnt_1)/2;        //计算出重合部分，重合部分就是第一个长度+第二个长度-总1数/2        for(ll i=1;i&lt;=m;i++)        &#123;            if(tot==G[pos]-chong)break;            if(now&amp;(1&lt;&lt;(i-1)))nowk|=(1&lt;&lt;(i-1)),tot++,lst=i;        &#125;        tot=0;        for(ll i=m;i&gt;=lst+1;i--)        &#123;            if(tot==pr-chong)break;            if(now&amp;(1&lt;&lt;(i-1)))nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;        tot=0;        for(ll i=1;i&lt;=m;i++)        &#123;            if(tot==chong)break;            if(!(now&amp;(1&lt;&lt;(i-1))))nowk|=(1&lt;&lt;(i-1)),nxtk|=(1&lt;&lt;(i-1)),tot++;        &#125;//        printf(&quot;nxk=%lld nok=%lld\n&quot;,nxtk,nowk);        dfs(pos-1,nxtk);        printf(&quot;%lld &quot;,nowk);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;c);    for(ll i=2;i&lt;=n;i++)&#123;        scanf(&quot;%s&quot;,ch[i]+1);    &#125;    b|=c;    x=b.count();//    printf(&quot;x=%lld\n&quot;,x);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;G[i]);    &#125;    f[1][G[1]]=1;    for(ll i=2;i&lt;=n;i++)        for(ll j=0;j&lt;=m;j++)&#123;            if(!f[i-1][j]) continue;            for(ll w=max(0ll,G[i]+j-m);w&lt;=min(j,G[i]);w++)&#123;                if(ch[i][1]==&#39;A&#39;)&#123;                    if(f[i-1][j]==1)                        f[i][w]=1,pre[i][w]=j/*,printf(&quot;A pos=%lld pre[%lld][%lld]=%lld\n&quot;,i,i,w,pre[i][w])*/;                &#125;                if(ch[i][1]==&#39;O&#39;)&#123;                    if(f[i-1][j]==1)                        f[i][j+G[i]-w]=1,pre[i][j+G[i]-w]=j/*,printf(&quot;O pos=%lld pre[%lld][%lld]=%lld\n&quot;,i,i,j+G[i]-w,pre[i][j+G[i]-w])*/;                &#125;                if(ch[i][1]==&#39;X&#39;)&#123;                    if(f[i-1][j]==1)                        f[i][j+G[i]-2*w]=1,pre[i][j+G[i]-2*w]=j/*,printf(&quot;X pos=%lld pre[%lld][%lld]=%lld\n&quot;,i,i,j+G[i]-2*w,pre[i][j+G[i]-2*w])*/;                &#125;            &#125;        &#125;    dfs(n,c);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试21「折纸&amp;#183;不等式」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9521%E3%80%8C%E6%8A%98%E7%BA%B8&amp;#183;%E4%B8%8D%E7%AD%89%E5%BC%8F%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9521%E3%80%8C%E6%8A%98%E7%BA%B8&amp;#183;%E4%B8%8D%E7%AD%89%E5%BC%8F%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-16 20:23</p><h2 id="折纸"><a href="#折纸" class="headerlink" title="折纸"></a>折纸</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考试时无限接近正解，然而最终也只是接近而已了</p><p>考虑模拟会爆炸，拿手折纸条试一试，很简单</p><p>考你动手能力</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 3100000ll cj[A],questions[A];ll len,l,r,n,QAQ;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;len,&amp;QAQ);    l=0,r=len;    for(ll i=1,a;i&lt;=QAQ;i++)&#123;        scanf(&quot;%lld&quot;,&amp;questions[i]);    &#125;    for(ll i=1;i&lt;=QAQ;i++)&#123;        ll llen=questions[i]-l;        ll rlen=r-questions[i];//        printf(&quot;ques=%lld llen=%lld rlen=%lld\n&quot;,questions[i],l,r);        if(llen==0||rlen==0) continue;        if(llen&lt;rlen)&#123;                l=questions[i];                    for(ll j=i+1;j&lt;=QAQ;j++)&#123;                if(questions[j]&lt;questions[i])                    questions[j]=questions[i]+abs(questions[j]-questions[i]);            &#125;                    &#125;        if(llen&gt;=rlen)&#123;            r=questions[i];            for(ll j=i+1;j&lt;=QAQ;j++)&#123;                if(questions[j]&gt;questions[i])                questions[j]=questions[i]-abs(questions[j]-questions[i]);            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,r-l);&#125;</code></pre><h2 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h2><p><a href="https://www.cnblogs.com/znsbc-13/protected/p/11354859.html">不等式</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试20「周·任·飞」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9520%E3%80%8C%E5%91%A8%C2%B7%E4%BB%BB%C2%B7%E9%A3%9E%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9520%E3%80%8C%E5%91%A8%C2%B7%E4%BB%BB%C2%B7%E9%A3%9E%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-16 21:29</p><p>liu_runda出的题再次$%%%%%%%%%%%%%%%%%%$</p><h2 id="任"><a href="#任" class="headerlink" title="任"></a>任</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目中为什么反复强调简单路径,没有环</p><p>没有环的图中点数-边数&#x3D;联通块数</p><p>前缀和维护边的前缀和,和点的前缀和,</p><p>在维护边的前缀和不好维护转化为横着边前缀和,竖着边前缀和</p><p>注意边的边界问题</p><p>看边如何维护</p><p>就拿我的举例</p><p>你在当前为边且当前左面为边时置为1</p><p>那么当你统计答案时</p><pre><code>        ll bia=bianheng[x2][y2]-bianheng[x1-1][y2]-bianheng[x2][y1]+bianheng[x1-1][y1];</code></pre><p>思考我们统计答案时要把x2相连的边切断</p><p>类似的,我们维护竖着的边时也要类似操作</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 2101char s[A][A];ll vis[A][A],stax[4200000],stay[4200000],dian[A][A],bianheng[A][A],bianshu[A][A];ll cnt=0,n,m,q;const ll nowx[5]=&#123;0,0,0,1,-1&#125;;const ll nowy[5]=&#123;0,1,-1,0,0&#125;;void dfs(ll x,ll y,ll x1,ll y1,ll x2,ll y2)&#123;    vis[x][y]=cnt;//    printf(&quot;x=%lld y=%lld vis=%lld\n&quot;,x,y,vis[x][y]);    for(ll i=1;i&lt;=4;i++)&#123;        ll xnow=x+nowx[i],ynow=y+nowy[i];        if(xnow&gt;x2||xnow&lt;x1) continue;        if(ynow&gt;y2||ynow&lt;y1) continue;        if(s[xnow][ynow]-&#39;0&#39;==0) continue;        if(vis[xnow][ynow]) continue;        dfs(xnow,ynow,x1,y1,x2,y2);    &#125;&#125;void bfs(ll x1,ll y1,ll x2,ll y2)&#123;    cnt=0;    for(ll i=x1;i&lt;=x2;i++)        for(ll j=y1;j&lt;=y2;j++)&#123;            if(s[i][j]==&#39;1&#39;&amp;&amp;!vis[i][j])&#123;                ++cnt;                dfs(i,j,x1,y1,x2,y2);            &#125;        &#125;    for(ll i=x1;i&lt;=x2;i++)        for(ll j=y1;j&lt;=y2;j++)&#123;            vis[i][j]=0;        &#125;    printf(&quot;%d\n&quot;,cnt);&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%s&quot;,s[i]+1);    &#125;//    memset()    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(s[i][j]==&#39;1&#39;&amp;&amp;s[i][j-1]==&#39;1&#39;)&#123;                bianheng[i][j]++;            &#125;            if(s[i][j]==&#39;1&#39;&amp;&amp;s[i-1][j]==&#39;1&#39;)&#123;                bianshu[i][j]++;            &#125;            if(s[i][j]==&#39;1&#39;)&#123;                dian[i][j]++;            &#125;        &#125;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;        bianheng[i][j]=bianheng[i][j]+bianheng[i-1][j]+bianheng[i][j-1]-bianheng[i-1][j-1];        bianshu[i][j]=bianshu[i][j]+bianshu[i-1][j]+bianshu[i][j-1]-bianshu[i-1][j-1];        dian[i][j]=dian[i][j]+dian[i-1][j]+dian[i][j-1]-dian[i-1][j-1];    &#125;//    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))//        for(ll j=1;j&lt;=m;j++)&#123;//            printf(&quot;bian=%d &quot;,bianheng[i][j]);//        &#125;    for(ll i=1,x1,x2,y1,y2;i&lt;=q;i++)&#123;        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        ll bia=bianheng[x2][y2]-bianheng[x1-1][y2]-bianheng[x2][y1]+bianheng[x1-1][y1];//        printf(&quot;%d %d %d %d bia=%d\n&quot;,bianheng[x2][y2],bianheng[x1-1][y2],bianheng[x2][y1],bianheng[x1-1][y1-1],bia);        bia+=bianshu[x2][y2]-bianshu[x1][y2]-bianshu[x2][y1-1]+bianshu[x1][y1-1];//        printf(&quot;%d %d %d %d        bia=%d\n&quot;,bianshu[x2][y2],bianshu[x1][y2],bianshu[x2][y1-1],bianshu[x1-1][y1-1],bia);        ll dia=dian[x2][y2]-dian[x1-1][y2]-dian[x2][y1-1]+dian[x1-1][y1-1];        printf(&quot;%d\n&quot;,dia-bia);    &#125;&#125;</code></pre><h2 id="飞"><a href="#飞" class="headerlink" title="飞"></a>飞</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>其实就是求逆序对,然而逆序对是$n*log$的并不能过,思考优化</p><p>我们发现其实它给了多段等差数列,</p><p>先看所有等差数列都是完整的情况</p><p>我们在同一段等差数列上可以由$x[i-1]$推到$x[i]$思考我们找的是比当前大的个数,$x[i]&#x3D;x[i-1]+a$所有之前等差数列贡献都要减一</p><p>那么设之前贡献$tmp$得到当前贡献$tmp-cnt(等差数列个数)$</p><p>那么我们思考$&lt;a$(即等差数列首项)怎么维护,我们拿一个树状数组维护$&lt;a$的所有值</p><p>假设当前值为$x$那么逆序对数就是$i-sum(x)-1$</p><p>然后我们考虑第一段不是完整的</p><p>假设当前$x$转移到$x2$中$x,x2$都比$begin$小那么等差数列上所有小于$begin$贡献都要减一(头一段上没有处于$x$–$x2$数不能转移)</p><p>若当前已经比$begin$大了把它当成一个正常等差数列</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111111ll c[A];ll tus,n,a,mod,now,cnt=0,ans=0,last,tmp;void add(ll x,ll u)&#123;    for(ll i=x;i&lt;=a;i+=i&amp;-i)        c[i]+=u;&#125;ll sum(ll x)&#123;    ll ans=0;    for(ll i=x;i&gt;=1;i-=i&amp;-i)        ans+=c[i];    return ans;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;tus,&amp;a,&amp;mod);    ll now=tus;    if(tus&lt;=a)&#123;        add(tus+1,1);    &#125;    for(ll i=2;i&lt;=n;i++)&#123;        now=(a+now)%mod;        if(now&lt;a)&#123;            tmp=i-sum(now+1)-1;            cnt++;            add(now+1,1);        &#125;        else&#123;            tmp-=cnt;            if(now&lt;tus) tmp++;        &#125;        ans+=tmp;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试19「count·dinner·chess」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9519%E3%80%8Ccount%C2%B7dinner%C2%B7chess%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9519%E3%80%8Ccount%C2%B7dinner%C2%B7chess%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-16 20:05</p><p>反思:</p><p>我考得最炸的一次</p><p>怎么说呢?简单的两个题0分,稍难(我还不敢说难,肯定又有人喷我)42分</p><p>前10分钟看T1,不会,觉得不可做,完全不可做,把它跳了</p><p>最后10分钟看T1,发现一个有点用的性质,仍然认为不可实现</p><p>0分</p><p>所以T1是什么样的难题呢</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190816192504827-974589884.png"></p><p>即使暴力也有60分,但我楞没想出来暴力怎么打</p><p>然后我就挂掉了</p><p>t2又是什么样难题</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190816192626222-1349171496.png"></p><p>大多数人秒切一个小时切两道,</p><p>但这次考试给了我很大启迪,也正是这次考试我才开始使劲刚T1</p><p>其实大多数T1都是比较简单的,并没有想象中那么难,这次考试对我来说意义很大</p><p>(就在模拟测试21我也认为T1很难坚持刚其实T1还是很简单的)</p><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一共有多少种方案可以把这棵树分成大小相同的几块</p><p>题干简洁明了,</p><p>性质:我们如果能分成大小相同全为$size$大小的几块,那么只有一种方案分成大小全为$size$</p><p>有了这条性质我们就可以愉快的打了</p><p>枚举所有n的约数打了就$AC$了(还有不要暴力枚举约数,先根号n求一下约数)</p><p>实现,假设当前我们发现这个子树累计$size$达到了约数就剪掉这个枝条</p><p>若减不掉就累加到父亲上,如果父亲减不掉且$size$已经比当前枚举约数大了,那么当前方案不可行,否则方案$++$</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190816194044421-1576229305.png"></p><p>例如我们枚举约数3,我们在3减不掉,5减不掉,累加到2,2判断size大了所以不可行</p><pre><code>bool dfs(ll x,ll pre,ll num)&#123;    sz[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue;        if(!dfs(y,x,num)) return 0;        sz[x]+=sz[y];        if(sz[x]&gt;num) return 0;    &#125;//    printf(&quot;sz=%lld  \n&quot;,sz[x]);    if(sz[x]==num) sz[x]=0;    return 1;&#125;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 2999989ll sz[A],ver[A],nxt[A],head[A];ll ans=2,tot=1,n,m;vector&lt;ll&gt; woshishabi;void add(ll x,ll y)&#123;    ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;inline ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;)            f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;bool dfs(ll x,ll pre,ll num)&#123;    sz[x]=1;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue;        if(!dfs(y,x,num)) return 0;        sz[x]+=sz[y];        if(sz[x]&gt;num) return 0;    &#125;//    printf(&quot;sz=%lld  \n&quot;,sz[x]);    if(sz[x]==num) sz[x]=0;    return 1;&#125;int main()&#123;    n=read();    for(ll i=1,a,b;i&lt;n;i++)&#123;        a=read(),b=read();        add(a,b);add(b,a);    &#125;    for(ll i=2;i&lt;=sqrt(n);i++)&#123;        if(n%i==0)&#123;            if(i*i==n) woshishabi.push_back(i);            else                woshishabi.push_back(i),woshishabi.push_back(n/i);        &#125;    &#125;    for(ll i=0;i&lt;woshishabi.size();i++)&#123;        if(dfs(1,0,woshishabi[i]))&#123;            ans++;        &#125;//        printf(&quot;=%lld ans=%lld\n&quot;,woshishabi[i],ans);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h2 id="dinner"><a href="#dinner" class="headerlink" title="dinner"></a>dinner</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不错的题意转化</p><p>分成个数最少的环,每个环总权值最大的最小</p><p>最大的最小??</p><p>二分答案</p><p>一个很好的二分答案题,让我明白了我们枚举其实可以拿分块优化一下</p><p>暴力应该都会打吧</p><p>枚举圈的数量,这里讲一下$check$</p><p>我采取的是首先找到一个圈,找到最左可以到达的值,以及到达最左后到达右面节点,这已经$1$个圈了</p><p>每次枚举剩下的值,若当前符合直接返回,不符合最左指针$++$,右面指针跟着移动,进行操作知道最左达到$n+1$</p><p>这样一般过不了(然而我暴力$nian$标算了)我打法玄学</p><pre><code>    while(now&lt;=tim)&#123;        tl--;        now+=a[tl];    &#125;    now-=a[tl],tl++;    while(now&lt;=tim)&#123;        tr++;        now+=a[tr];    &#125;    now-=a[tr],tr--;    //一个完美的闭合回路    while(tl!=n+2)    &#123;        cnt=2;tot=0;//        printf(&quot;tl=%lld tr=%lld \n&quot;,tl,tr);        //除了当前满足的tl,tr之外的圈的另一半        for(LL j=tr+1;j&lt;=tl+n-1;j++)        &#123;            if(tot&gt;tim)tot=a[j],cnt++;            if(cnt&gt;m)&#123;cnt=m+10;break;&#125;        &#125;//        printf(&quot;cnt=%lld\n&quot;,cnt);        if(cnt&lt;=m)return 1;        now-=a[tl];tl++;        while(now&lt;=tim)&#123;            tr++;            now+=a[tr];        &#125;        now-=a[tr],tr--;    &#125;    return 0;&#125;</code></pre><p>主要讲剪枝</p><p>就一句话特别简单</p><pre><code>            if(j+t&lt;=tl+n-1&amp;&amp;sum[j+t]-sum[j-1]+tot&lt;=tim)&#123;tot+=(sum[j+t]-sum[j-1]);j+=t;continue;&#125;</code></pre><p>能t加就加t,一句小的剪枝让你从$T60$分到$100$分,从$3000$–&gt;$200$(虽然我暴力跑了$100$)</p><p>方法简单,</p><h1 id="一定要掌握这种思想"><a href="#一定要掌握这种思想" class="headerlink" title="一定要掌握这种思想"></a>一定要掌握这种思想</h1><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define A 1010101LL a[A],sum[A];LL n,m,ans,avg,mx=-1,t;LL check(LL tim)&#123;    LL now=0,tl=n+1,tr=n+1,tot,cnt=0;    now=a[n+1];//    printf(&quot;now=%lld\n&quot;,now);    while(now&lt;=tim)&#123;        tl--;        now+=a[tl];    &#125;    now-=a[tl],tl++;    while(now&lt;=tim)&#123;        tr++;        now+=a[tr];    &#125;    now-=a[tr],tr--;    //一个完美的闭合回路    while(tl!=n+2)    &#123;        cnt=2;tot=0;//        printf(&quot;tl=%lld tr=%lld \n&quot;,tl,tr);        //除了当前满足的tl,tr之外的圈的另一半        for(LL j=tr+1;j&lt;=tl+n-1;j++)        &#123;            if(j+t&lt;=tl+n-1&amp;&amp;sum[j+t]-sum[j-1]+tot&lt;=tim)&#123;tot+=(sum[j+t]-sum[j-1]);j+=t;continue;&#125;            tot+=a[j];            if(tot&gt;tim)tot=a[j],cnt++;            if(cnt&gt;m)&#123;cnt=m+10;break;&#125;        &#125;//        printf(&quot;cnt=%lld\n&quot;,cnt);        if(cnt&lt;=m)return 1;        now-=a[tl];tl++;        while(now&lt;=tim)&#123;            tr++;            now+=a[tr];        &#125;        now-=a[tr],tr--;    &#125;    return 0;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    t=sqrt(n);    for(LL i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);        a[i+n]=a[i];        mx=max(mx,a[i]);    &#125;for(LL i=1;i&lt;=2*n;i++)        sum[i]=sum[i-1]+a[i];    LL l=mx,r=sum[n];    while(l&lt;=r)&#123;        LL mid=(l+r)&gt;&gt;1;        if(check(mid)) r=mid-1,ans=mid;        else l=mid+1;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><h2 id="chess"><a href="#chess" class="headerlink" title="chess"></a>chess</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>知道了正解也难以实现打了$4$个小时,我最后还是颓了标程,然而刚看$10$秒就明白怎么做并用$10$分钟$AC$</p><p>首先我们要掌握一种科技最短路计数</p><p>然而敌军不能对方案造成影响,考虑缩边</p><p>那么题解中说缩边缩边,怎么缩啊</p><p>我尝试跑两遍$spfa$(伪缩边)然而只有$20$分</p><p>尝试$tarjan$(伪缩边)然而只有$0$分</p><p>尝试对拍小点全对,大点全错</p><p>好难实现,考虑每个点$dfs?$</p><p>能过?,能过最多每个点搜每个点一遍善用复杂度分析$2500^2$</p><p>那么$dfs$搜些什么,</p><p>既然敌军不能对方案造成影响,遇到敌军往下搜但不建边,遇到空格return并且建边</p><p>建单向边,这样我们就缩边了</p><p>很巧妙不是吗?</p><p>注意答案可能很大开0x7ffffffffffffffffffff</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 51000ll head[A],nxt[A],ver[A],way[A],dis[A],G[51][51],mzz[51][51];ll F[58][58];ll qix,qiy,zhongx,zhongy;bool flag[A];ll tot=0,n,m;ll id(ll x,ll y)&#123;    return (x-1)*m+y;&#125;void jb(ll x,ll y)&#123;//建边//    printf(&quot;jbjbjbjbx=%lld y=%lld\n&quot;,x,y);    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;const ll nowx[9]=&#123;0,2,2,1,-1,-2,-2,1,-1&#125;;const ll nowy[9]=&#123;0,1,-1,2,2,1,-1,-2,-2&#125;;void dfs(ll root,ll x,ll y)&#123;    G[x][y]=1;//    printf(&quot;x=%lld y=%lld\n&quot;,x,y);    for(ll i=1;i&lt;=8;i++)&#123;        ll x1=nowx[i]+x,y1=nowy[i]+y;//        printf(&quot;x=%lld y=%lld x1=%lld y1=%lld\n&quot;,x,y,x1,y1);        if(x1&lt;1||x1&gt;n||y1&lt;1||y1&gt;m||G[x1][y1]) continue;        if(F[x1][y1]==1)            dfs(root,x1,y1);        else             G[x1][y1]=1,jb(root,mzz[x1][y1]);    &#125;&#125;/*void spfa(ll w)&#123;    deque&lt;ll&gt;q;    memset(dis,0x3f,sizeof(dis));    memset(flag,0,sizeof(flag));    dis[w]=0;    q.push_back(w);    while(!q.empty())&#123;        ll x=q.front();        q.pop_front();        flag[x]=0;        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i];            if(dis[y]&gt;dis[x]+edge[i])&#123;                if(edge[i]==0)                    choose[y]=x;                dis[y]=dis[x]+edge[i];    //                printf(&quot;x=%lld y=%lld dx=%lld dy=%lld\n&quot;,x,y,dis[x],dis[y]);//                if(x==59||y==59)&#123;//                    printf(&quot;***********\n&quot;);//                &#125;                if(!flag[y])&#123;                    q.push_back(y);                    flag[y]=1;                &#125;            &#125;        &#125;    &#125;&#125;*/void spfa2(ll w)&#123;    deque&lt;ll&gt;q;    memset(dis,0x7f,sizeof(dis));    memset(flag,0,sizeof(flag));    dis[w]=0;    q.push_back(w);    while(!q.empty())&#123;        ll x=q.front();        q.pop_front();        flag[x]=0;//        printf(&quot;x=%lld\n&quot;,x);        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i];            if(dis[y]&gt;dis[x]+1)&#123;                way[y]=way[x];                dis[y]=dis[x]+1;                if(!flag[y])&#123;                    q.push_back(y);                    flag[y]=1;                &#125;            &#125;            else if(dis[y]==dis[x]+1)&#123;                way[y]+=way[x];            &#125;        &#125;            &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);        for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            mzz[i][j]=id(i,j);//            printf(&quot;mzz[%lld][%lld]=%lld\n&quot;,i,j,mzz[i][j]);        &#125;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            scanf(&quot;%lld&quot;,&amp;F[i][j]);                        if(F[i][j]==3)                qix=i,qiy=j;            else if(F[i][j]==4)                zhongx=i,zhongy=j;        &#125;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(F[i][j]==0||F[i][j]==3)&#123;                memset(G,0,sizeof(G));                dfs(mzz[i][j],i,j);            &#125;        &#125;        /*    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;                    if(F[i][j]==2) continue;            for(ll k=1;k&lt;=8;k++)&#123;                ll x1=i+nowx[k],y1=j+nowy[k];                ll idpre=id(i,j),idnow=id(x1,y1);                if(x1&lt;1||x1&gt;n||y1&lt;1||y1&gt;m) continue;                if(F[x1][y1]==2) continue;                if(!G[idpre][idnow])&#123;                    if(F[x1][y1]==1||F[x1][y1]==4)                        jb(idpre,idnow,0),G[idpre][idnow]=1;                    else                        jb(idpre,idnow,1),G[idpre][idnow]=1;                &#125;            &#125;            if(F[i][j]==3)                qix=i,qiy=j;            else if(F[i][j]==4)                zhongx=i,zhongy=j;    &#125;*/    way[mzz[qix][qiy]]=1;//    printf(&quot;%lld\n%lld\n&quot;,dis[id(zhongx,zhongy)],way[id(zhongx,zhongy)]);    spfa2(mzz[qix][qiy]);    if(dis[mzz[zhongx][zhongy]]&gt;1e8) printf(&quot;-1\n&quot;);    else    printf(&quot;%lld\n%lld\n&quot;,dis[mzz[zhongx][zhongy]]-1,way[mzz[zhongx][zhongy]]);&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试18「引子·可爱宝贝精灵·相互再归的鹅妈妈」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9518%E3%80%8C%E5%BC%95%E5%AD%90%C2%B7%E5%8F%AF%E7%88%B1%E5%AE%9D%E8%B4%9D%E7%B2%BE%E7%81%B5%C2%B7%E7%9B%B8%E4%BA%92%E5%86%8D%E5%BD%92%E7%9A%84%E9%B9%85%E5%A6%88%E5%A6%88%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9518%E3%80%8C%E5%BC%95%E5%AD%90%C2%B7%E5%8F%AF%E7%88%B1%E5%AE%9D%E8%B4%9D%E7%B2%BE%E7%81%B5%C2%B7%E7%9B%B8%E4%BA%92%E5%86%8D%E5%BD%92%E7%9A%84%E9%B9%85%E5%A6%88%E5%A6%88%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-12 16:04</p><p>待补</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>大模拟，注意细节</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;char a[1005][1005];bool vst[1005][1005];void solve(int na,int nb)&#123;    int i=na,j=nb,now=0;    while(1)&#123;        j++;if(a[na][j]==&#39;+&#39;)break;    &#125;    while(1)&#123;        i++;if(a[i][nb]==&#39;+&#39;)break;    &#125;    for(int k=na+1;k&lt;i;k++)&#123;        for(int l=nb+1;l&lt;j;l++)if(a[k][l]&gt;=&#39;0&#39;&amp;&amp;a[k][l]&lt;=&#39;9&#39;)now=now*10+a[k][l]-&#39;0&#39;;        if(now)break;    &#125;    for(int k=i;k&gt;=na;k--)&#123;        if(j&lt;=m&amp;&amp;a[k][j+1]==&#39;-&#39;)&#123;            int ni=k,nj=j+1;vst[ni][nj]=1;            while(1)&#123;                while(1)&#123;                    if((a[ni][nj+1]==&#39;-&#39;||a[ni][nj+1]==&#39;+&#39;)&amp;&amp;!vst[ni][nj+1])nj++;                    else nj--;vst[ni][nj]=1;                    if(a[ni][nj]==&#39;+&#39;)break;                &#125;                while(1)&#123;                    ni++;vst[ni][nj]=1;                    if(a[ni][nj]==&#39;+&#39;||a[ni][nj]==&#39;-&#39;)break;                &#125;                if(a[ni][nj]==&#39;-&#39;)break;            &#125;            while(a[ni][nj]!=&#39;+&#39;)nj--;solve(ni,nj);        &#125;        else if(nb&amp;&amp;a[k][nb-1]==&#39;-&#39;)&#123;            int ni=k,nj=nb-1;            vst[ni][nj]=1;            while(1)&#123;                while(1)&#123;                    if((a[ni][nj+1]==&#39;-&#39;||a[ni][nj+1]==&#39;+&#39;)&amp;&amp;!vst[ni][nj+1])nj++;                    else nj--;vst[ni][nj]=1;                    if(a[ni][nj]==&#39;+&#39;)break;                &#125;                while(1)&#123;                    ni++;vst[ni][nj]=1;                    if(a[ni][nj]==&#39;+&#39;||a[ni][nj]==&#39;-&#39;)break;                &#125;                if(a[ni][nj]==&#39;-&#39;)break;            &#125;            while(a[ni][nj]!=&#39;+&#39;)nj--;            solve(ni,nj);        &#125;    &#125;    printf(&quot;%d\n&quot;,now);&#125;int main()&#123;    bool fir=0;    int sta,stb;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)&#123;            char c=getchar();            while(c!=&#39;+&#39;&amp;&amp;c!=&#39;|&#39;&amp;&amp;c!=&#39;-&#39;&amp;&amp;c!=&#39;.&#39;&amp;&amp;(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;))c=getchar();            a[i][j]=c;            if(a[i][j]==&#39;+&#39;&amp;&amp;!fir)sta=i,stb=j,fir=1;        &#125;    solve(sta,stb);    return 0;&#125;</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111char ch[A][A];ll n,m,top=0;ll h[A][A],stax[A],stay[A],low[A],len[A],sta[A];ll chuanx,chuany;bool vis[A][A];struct node &#123;    ll hang,id;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.hang&lt;b.hang;    &#125;&#125;;priority_queue &lt;node&gt; high[A];const ll nowx[5]=&#123;0,1,-1,0,0&#125;;const ll nowy[5]=&#123;0,0,0,1,-1&#125;;//1右0左2下void pre(ll x,ll y,ll fx)&#123;        if(h[x][y])&#123;//        printf(&quot;x=%lld y=%lld h=%lld fx=%lld\n&quot;,x,y,h[x][y],fx);        chuanx=x,chuany=y;        return ;    &#125;    if(ch[x][y]==&#39;+&#39;)&#123;        if(fx==0||fx==1)&#123;            pre(x+1,y,2);        &#125;        if(fx==2)&#123;            if(ch[x][y+1]==&#39;-&#39;)                pre(x,y+1,1);            if(ch[x][y-1]==&#39;-&#39;)                pre(x,y-1,0);        &#125;    &#125;    else&#123;        if(fx==1&amp;&amp;y+1&lt;=m)            pre(x,y+1,1);        if(fx==0&amp;&amp;y-1&gt;=1)            pre(x,y-1,0);        if(fx==2&amp;&amp;x+1&lt;=n)            pre(x+1,y,2);    &#125;&#125;void dfs(ll num)&#123;    while(!high[num].empty())&#123;        ll x=high[num].top().id;//        printf(&quot;hang=%lld\n&quot;,high[num].top().hang);        high[num].pop();        dfs(x);    &#125;    low[++low[0]]=num;&#125;void del(ll x,ll y,ll num)&#123;    top=1;//    printf(&quot;num=%lld\n&quot;,num);    stax[top]=x,stay[top]=y;    while(top)&#123;        ll x=stax[top],y=stay[top];        h[x][y]=num;        top--;        for(ll i=1;i&lt;=4;i++)&#123;            ll x2=x+nowx[i],y2=y+nowy[i];            h[x2][y2]=num;//            printf(&quot;x2=%lld y2=%lld\n&quot;,x2,y2);            if((ch[x2][y2]==&#39;.&#39;||isdigit(ch[x2][y2]))&amp;&amp;!vis[x2][y2])&#123;                top++;                stax[top]=x2,stay[top]=y2;                vis[x2][y2]=1;            &#125;        &#125;    &#125;//    printf(&quot;*********************%lld\n&quot;,h[14][61]);&#125;void bfs()&#123;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(isdigit(ch[i][j]))&#123;//                printf(&quot;ch[%lld][%lld]=%d\n&quot;,i,j,ch[i][j]-&#39;0&#39;);                ll x=ch[i][j]-&#39;0&#39;;                for(ll w=j+1;w&lt;=m;w++)&#123;                    if(isdigit(ch[i][w]))                        x=x*10+ch[i][w]-&#39;0&#39;;                    else break;                &#125;//                printf(&quot;x1=%lld x2=%lld x3=%lld\n&quot;,x,x2,x3);                if(!vis[i][j])del(i,j,x);            &#125;        &#125;/*    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=m;j++)&#123;            printf(&quot;%lld&quot;,h[i][j]);        &#125;*/    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(ch[i][j]==&#39;|&#39;)&#123;                if(ch[i][j+1]==&#39;-&#39;)&#123;                    pre(i,j+1,1);                    node no;//                    printf(&quot;i=%lld j=%lld h=%lld chan=%lld %lld h=%lld\n&quot;,i,j,h[i][j],chuanx,chuany,h[chuanx][chuany]);                    no.hang=i,no.id=h[chuanx][chuany];                    high[h[i][j]].push(no);                &#125;                if(ch[i][j-1]==&#39;-&#39;)&#123;                    pre(i,j-1,0);                    node no;//                    printf(&quot;i=%lld j=%lld h=%lld chan=%lld %lld h=%lld\n&quot;,i,j,h[i][j],chuanx,chuany,h[chuanx][chuany]);                    no.hang=i,no.id=h[chuanx][chuany];                    high[h[i][j]].push(no);                &#125;            &#125;        &#125;    dfs(1);    for(ll i=1;i&lt;=low[0];i++)&#123;        printf(&quot;%lld\n&quot;,low[i]);    &#125;&#125;int main()&#123;//    freopen(&quot;wos.txt&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%s&quot;,ch[i]+1);    &#125;    bfs();&#125;</code></pre><h2 id="可爱宝贝精灵"><a href="#可爱宝贝精灵" class="headerlink" title="可爱宝贝精灵"></a>可爱宝贝精灵</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>一个不错的dfs题（还能练习剪枝）</p><p>一个不错的dp题</p><p>思考dp数组含义</p><p>首先我们知道我们到一个有小精灵地方就必须抓住它（显然）而不是来回逛几圈再次经过它再抓</p><p>然后我们只要从一个方向走就必须抓住至少一只小精灵，转向之后也至少抓住一只精灵，（否则你走这一段就是没用的）</p><p>$i，j$分别表示当前最左到$i$最右到$j$时的最大值</p><p>设$f[i][j]$肯定不行时间难以确认，多一维表示时间$f[t][i][j]$也难以确定，然而你在左面还是右面依然难以确定</p><p>那么再加一维$f[t][i][j][2]$中$[1]$表示在右面,$[0]$表示在左面</p><p>转移很好转移，不像昨天那个<a href="https://www.cnblogs.com/znsbc-13/p/11336022.html">傻逼t2式子</a></p><p>类似离散化一下</p><p>假如当前l，你可以走到r或者l-1</p><p>假如当前r，你可以走到l或者r+1</p><p>用式子表示就是</p><p>从$r$走到$l+1$再走到$l$</p><p>从$l$走到$r-1$再走到$r$</p><p>$f[i][l][r][0]&#x3D;max(f[max(i-dis(l,l+1),0)][l+1][r][0],f[max(i-dis(l,r),0)][l+1][r][1])+Val;$<br>$f[i][l][r][1]&#x3D;max(f[max(i-dis(r-1,r),0)][l][r-1][1],f[max(i-dis(l,r),0)][l][r-1][0])+Val;$</p><p>注意一下初始化！</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define py printf(&quot;tys is sb\n&quot;)#define A 2010ll f[A][118][118][2];struct pocky&#123;    ll pla,val,tim;    friend bool operator &lt; (const pocky &amp;a, const pocky &amp;b)&#123;        return a.pla&lt;b.pla;    &#125;&#125;texas[A];ll dis(ll l,ll r)&#123;    return abs(texas[r].pla-texas[l].pla);&#125;ll n,k,m,mx,mid,ans;void debuger(ll x)&#123;    for(ll i=1;i&lt;=m;i++,puts(&quot;&quot;))        for(ll j=i+1;j&lt;=m;j++)&#123;            printf(&quot;f[%lld][%lld][%lld]=%lld %lld\n &quot;,x,i,j,f[x][i][j][1],f[x][i][j][0]);        &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;m);    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;texas[i].pla,&amp;texas[i].val,&amp;texas[i].tim);        mx=max(mx,texas[i].tim);    &#125;    memset(f,-0x3f,sizeof(f));    m++;    texas[m].pla=k,    texas[m].val=0,    texas[m].tim=mx;    sort(texas+1,texas+m+1);    for(ll i=1;i&lt;=m;i++)&#123;        if(texas[i].pla==k&amp;&amp;texas[i].val==0)&#123;            mid=i;            break;        &#125;    &#125;    f[0][mid][mid][0]=0;    f[0][mid][mid][1]=0;//    printf(&quot;mid=%lld \n&quot;,texas[mid].pla);    for(ll i=mid-1;i&gt;=1;i--)&#123;        ll tim=texas[mid].pla-texas[i].pla;//        printf(&quot;tim=%lld i=%lld mid=%lld \n&quot;,tim,i,mid);        f[tim][i][mid][0]=f[dis(mid,i+1)][i+1][mid][0]+((tim&lt;texas[i].tim)?texas[i].val:0);        ans=max(ans,f[tim][i][mid][0]);    &#125;    for(ll i=mid+1;i&lt;=m;i++)&#123;        ll tim=texas[i].pla-texas[mid].pla;        f[tim][mid][i][1]=f[dis(mid,i-1)][mid][i-1][1]+((tim&lt;texas[i].tim)?texas[i].val:0);        ans=max(ans,f[tim][mid][i][1]);    &#125;//    printf(&quot;ans=%lld\n&quot;,ans);    for(ll i=1;i&lt;=mx;i++)        for(ll l=1;l&lt;=mid-1;l++)            for(ll r=mid+1;r&lt;=m;r++)&#123;                f[i][l][r][0]=max(f[max(i-dis(l,l+1),0ll)][l+1][r][0],f[max(i-dis(l,r),0ll)][l+1][r][1])+((i&lt;texas[l].tim)?texas[l].val:0);                f[i][l][r][1]=max(f[max(i-dis(r-1,r),0ll)][l][r-1][1],f[max(i-dis(l,r),0ll)][l][r-1][0])+((i&lt;texas[r].tim)?texas[r].val:0);                ans=max(ans,max(f[i][l][r][0],f[i][l][r][1]));//                printf(&quot;    f[%lld][%lld][%lld][0]=%lld [%lld][%lld][%lld][1]=%lld\n&quot;,i,l,r,f[i][l][r][0],i,l,r,f[i][l][r][1]);            &#125;    printf(&quot;%lld\n&quot;,ans);&#125;  </code></pre><p>相互在归的鹅妈妈</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试17「入阵曲&amp;#183;将军令&amp;#183;星空」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9517%E3%80%8C%E5%85%A5%E9%98%B5%E6%9B%B2&amp;#183;%E5%B0%86%E5%86%9B%E4%BB%A4&amp;#183;%E6%98%9F%E7%A9%BA%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9517%E3%80%8C%E5%85%A5%E9%98%B5%E6%9B%B2&amp;#183;%E5%B0%86%E5%86%9B%E4%BB%A4&amp;#183;%E6%98%9F%E7%A9%BA%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-11 18:37</p><h2 id="入阵曲"><a href="#入阵曲" class="headerlink" title="入阵曲"></a>入阵曲</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>应用了一种美妙移项思想，</p><p>我们先考虑在一维上的做法</p><p>维护前缀和$(sum[r]-sum[l-1])%k&#x3D;&#x3D;0$可以转化为</p><p>$sum[r]% k&#x3D;&#x3D;sum[l-1]%k$开个桶维护一下即可</p><p>然后拓展到二维上</p><p>把两行之间所有行拍扁看作一维上的区间，</p><p>我们枚举两行和行之间所有列开个桶维护</p><p>$n^2 m$复杂度</p><pre><code>    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=i;j++)&#123;            flag[0]=1;            for(ll q=1;q&lt;=m;q++)&#123;                t[q]=(sum[i][q]-sum[j-1][q]+k)%k;                cnt+=flag[t[q]];                flag[t[q]]++;            &#125;            for(ll q=1;q&lt;=m;q++)                flag[t[q]]=0;        &#125;</code></pre><p>至于桶里flag[0]&#x3D;1初始化含义</p><p>当你其他%&#x3D;&#x3D;0的矩阵放进去时本身就符合条件，在桶里找配对之前就构成合法矩阵，这样做统计了所有%&#x3D;0的情况</p><p>当然这样也行</p><pre><code>    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=i;j++)&#123;            for(ll q=1;q&lt;=m;q++)&#123;                t[q]=(sum[i][q]-sum[j-1][q]+k)%k;                cnt+=flag[t[q]];                flag[t[q]]++;            &#125;            cnt+=flag[0];            for(ll q=1;q&lt;=m;q++)                flag[t[q]]=0;        &#125;</code></pre><h2 id="将军令"><a href="#将军令" class="headerlink" title="将军令"></a>将军令</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$45%$算法</p><p>计算k&#x3D;&#x3D;1</p><p>和小胖收皇宫类似，</p><p>思考dp数组含义</p><p>$f[x][0]$表示被父亲管辖 $f[x][1]$表示被自己管辖 $f[x][2]$表示被自己儿子管辖</p><p>f数组转移</p><p>若x被父亲管辖，那么儿子必须被自己管辖或者被儿子的儿子管辖</p><p>$f[x][0]&#x3D;\sum\limits_{y}^{y\in son}min(f[y][1],f[y][2])$</p><p>若x被自己管辖，那么x转移随意</p><p>$f[x][1]&#x3D;\sum\limits_{y}^{y\in son} min(f[y][1],f[y][2],f[y][0])$</p><p>若x被儿子管辖，那么儿子可以被自己管辖或者被儿子的儿子管辖</p><p>但如果所有儿子的儿子代价都比选自己代价小，我们需要强制选出一个$f[y][1]-f[y][2]$差值最小的更新</p><p>代码稍微体会一下</p><pre><code>void dp(ll x)&#123;    if(!son[x]) &#123;        f[x][1]=1;        f[x][2]=0x7ffffff;        f[x][0]=0;        return ;    &#125;    vis[x]=1;    ll sum=0,sum2=0,sum3=0,pan=0,mix=0x7ffffff;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        dp(y);        sum+=min(f[y][0],min(f[y][1],f[y][2]));        sum2+=min(f[y][2],f[y][1]);        sum3+=min(f[y][1],f[y][2]);        if(f[y][1]&lt;=f[y][2]) pan=1;        else             mix=min(mix,f[y][1]-f[y][2]);    &#125;    f[x][1]=sum+1;    f[x][0]=sum2;    if(pan==1) f[x][2]=sum3;    else f[x][2]=sum3+mix;&#125;</code></pre><p>$75%$算法</p><p>计算k&#x3D;&#x3D;2</p><p>还是思考dp数组含义</p><p>如果还是像上一个那样定义要写死</p><p>换一种0表示被自己守，1表示被儿子守（至少选了一个儿子），2被孙子守（至少选了一个孙子），3子孙全被覆盖自己没有，4孙子全被覆盖（儿子可以被覆盖可以不被覆盖）自己没有</p><p>还是思考转移</p><p>被自己守x转移还是随意$f[x][0]&#x3D;\sum\limits_{y}^{y\in son}<br>min(f[y][0],f[y][1],f[y][2],f[y][3],f[y][4])$</p><p>被儿子守x转移比较复杂</p><p>儿子需要自保，因为儿子可以管辖自己兄弟，所以随意选，所以可以选到$f[y][3]$</p><p>$f[x][1]&#x3D;\sum\limits_{y}^{y\in son} min(f[y][0],f[y][1],f[y][2],f[y][3])$</p><p>也和k&#x3D;&#x3D;1类似，显然我们还是要选出来一个最小差值</p><p>被自己孙子守，那么自己儿子需要自保，$f[y][1],f[y][2],f[y][0]$都满足条件</p><p>子孙全被覆盖自己没有，那么就是儿子孙子全被覆盖，儿子本身也要被覆盖，</p><p>$f[y][0]$ $f[y][1]$ $f[y][2]$ （显然$f[y][3]$不行）</p><p>孙子全被覆盖，那么就是孙子全被覆盖，那么可以是$f[y][3]$，$f[y][1]$，$f[y][0]$，$f[y][2]$</p><p>代码稍微体会一下（这个代码有误，我并不能调出来）</p><pre><code>void dp2(ll x)&#123;//1表示被自己守，2表示被儿子，3被孙子，4子孙全有自己无，5孙子全有自己无    if(!son[x])&#123;        f2[x][4]=0x7fffffff;        f2[x][5]=0x7fffffff;        f2[x][1]=1;        f2[x][2]=0;        f2[x][3]=0;        return ;    &#125;    vis[x]=1;    ll sum1=0,sum2=0,sum3=0,sum4=0,sum5=0,pan=0,mix1=0x7fffffff,pan2=0,mix2=0x7ffffff;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        dp2(y);        sum1+=min(min(f2[y][1],f2[y][2]),min(f2[y][3],min(f2[y][4],f2[y][5])));        sum2+=min(min(f2[y][1],f2[y][2]),min(f2[y][3],f2[y][4]));        if(f2[y][1]&lt;=f2[y][2]&amp;&amp;f2[y][1]&lt;=f2[y][3]&amp;&amp;f2[y][1]&lt;=f2[y][4])            pan=1;        else            mix1=min(mix1,f2[y][1]-min(f2[y][2],min(f2[y][3],f2[y][4])));        sum3+=min(f[y][1],min(f[y][2],f[y][3]));        if(f2[y][2]&lt;=f2[y][1]&amp;&amp;f2[y][2]&lt;=f2[y][3])            pan2=1;        else            mix2=min(mix2,f2[y][2]-min(f2[y][1],f2[y][3]));        sum4+=min(min(f2[y][1],f2[y][2]),f2[y][3]);        sum5+=min(min(f2[y][1],f2[y][2]),min(f2[y][3],f2[y][4]));    &#125;    f2[x][1]=1+sum1;    if(pan==1)        f2[x][2]=sum2;    else f2[x][2]=sum2+mix1;    if(pan2==1)        f2[x][3]=sum3;    else f2[x][3]=sum3+mix2;    f2[x][4]=sum4;    f2[x][5]=sum5;&#125;</code></pre><p>思考怎么优化</p><p>dp数组含义再次转变</p><p>$f[x][w]$表示$f$中&lt;&#x3D;w最小的数</p><p>例如$f[x][4]$表示$min(f[x][1],f[x][2],f[x][3],f[x][4],f[x][0])$</p><p>转移类似</p><p>$f[x][0]&#x3D;\sum\limits_{y}^{y\in son} f[y][4] $$ +1$</p><p>$f[x][3]&#x3D;\sum\limits_{y}^{y\in son} f[y][2] $</p><p>$f[x][2]&#x3D;\sum\limits_{y}^{y\in son} f[y][3] $$+差值$</p><p>$f[x][4]&#x3D;\sum\limits_{y}^{y\in son} f[y][3] $</p><p>$f[x][1]&#x3D;\sum\limits_{y}^{y\in son} f[x][4] $$+差值$</p><p>最后1 2 3 4 互相取min具体看代码</p><p>再次感受一下</p><pre><code>void dp2(ll x)&#123;    if(!son[x])&#123;        f2[x][0]=1;        f2[x][1]=f2[x][2]=1;f2[x][3]=f2[x][4]=0;        f2[x][1]=0x7fffffff;        return ;    &#125;    vis[x]=1;    f2[x][0]=1;    f2[x][1]=f2[x][2]=f2[x][3]=f2[x][4]=0;    ll pan=0,mix1=0x7fffffff,pan2=0,mix2=0x7ffffff;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        dp2(y);        f2[x][0]+=f2[y][4];        f2[x][3]+=f2[y][2];        f2[x][4]+=f2[y][3];        mix1=min(f2[y][0]-f2[y][3],mix1);        mix2=min(f2[y][1]-f2[y][2],mix2);    &#125;    f2[x][1]=f2[x][4]+mix1;    f2[x][2]=min(f2[x][3]+mix2,min(f2[x][0],f2[x][1]));    f2[x][3]=min(f2[x][3],f2[x][2]);    f2[x][4]=min(f2[x][3],f2[x][4]);//    printf(&quot;mix1=%lld 2=%lld x=%lld f[][1]=%lld [2]=%lld [3]=%lld [4]=%lld [0]=%lld\n&quot;,mix1,mix2,x,f2[x][1],f2[x][2],f2[x][3],f2[x][4],f2[x][0]);&#125;</code></pre><p>$100%$算法</p><p>dp我是打不出来</p><p>应该会有别的大神打出来dp100分</p><p>那么正解是什么神奇的算法呢？</p><p>简单贪心！</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190811204309849-1126693233.png"></p><p>啊啊啊啊啊又是贪心，我又没有看出来它是贪心，awsl，我太菜了</p><p>步骤分比正解难的多得多</p><p>贪心10分钟改完AC，每次找到最深得节点找它的k级父亲</p><p>实现不要想复杂，暴力改，暴力跳即可</p><p>你会发现你比dp还要快！！！！！！！！！！！！！！！！！！！</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll n,k,t,tot=0,sum1=0,sum2=0,sumji=0,sumou=0,skriller=0;ll head[A],nxt[A],ver[A],deep[A],son[A],f[A][3],fa[A];ll f2[A][10];struct node&#123;    ll deep,x;    friend bool operator &lt; (node a,node b)&#123;        return a.deep&lt;b.deep;    &#125;&#125;point[A];priority_queue&lt;node&gt; q;bool vis[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x];    head[x]=tot;    ver[tot]=y;&#125;ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;void dfs(ll x,ll de)&#123;    vis[x]=1;    point[x].deep=de;    point[x].x=x;    q.push(point[x]);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        dfs(y,de+1);        son[x]++;        fa[y]=x;    &#125;&#125;void dp(ll x)&#123;    if(!son[x]) &#123;        f[x][1]=1;        f[x][2]=0x7ffffff;        f[x][0]=0;        return ;    &#125;    vis[x]=1;    ll sum=0,sum2=0,sum3=0,pan=0,mix=0x7ffffff;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        dp(y);        sum+=min(f[y][0],min(f[y][1],f[y][2]));        sum2+=min(f[y][2],f[y][1]);        sum3+=min(f[y][1],f[y][2]);        if(f[y][1]&lt;=f[y][2]) pan=1;        else             mix=min(mix,f[y][1]-f[y][2]);    &#125;    f[x][1]=sum+1;    f[x][0]=sum2;    if(pan==1) f[x][2]=sum3;    else f[x][2]=sum3+mix;&#125;ll find(ll x)&#123;    ll w=1;    while(w&lt;=k)&#123;        w++;        x=fa[x];    &#125;    return x;&#125;void dp2(ll x)&#123;    if(!son[x])&#123;        f2[x][0]=1;        f2[x][1]=f2[x][2]=1;f2[x][3]=f2[x][4]=0;        f2[x][1]=0x7fffffff;        return ;    &#125;    vis[x]=1;    f2[x][0]=1;    f2[x][1]=f2[x][2]=f2[x][3]=f2[x][4]=0;    ll pan=0,mix1=0x7fffffff,pan2=0,mix2=0x7ffffff;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(vis[y]) continue;        dp2(y);        f2[x][0]+=f2[y][4];        f2[x][3]+=f2[y][2];        f2[x][4]+=f2[y][3];        mix1=min(f2[y][0]-f2[y][3],mix1);        mix2=min(f2[y][1]-f2[y][2],mix2);    &#125;    f2[x][1]=f2[x][4]+mix1;    f2[x][2]=min(f2[x][3]+mix2,min(f2[x][0],f2[x][1]));    f2[x][3]=min(f2[x][3],f2[x][2]);    f2[x][4]=min(f2[x][3],f2[x][4]);//    printf(&quot;mix1=%lld 2=%lld x=%lld f[][1]=%lld [2]=%lld [3]=%lld [4]=%lld [0]=%lld\n&quot;,mix1,mix2,x,f2[x][1],f2[x][2],f2[x][3],f2[x][4],f2[x][0]);&#125;void dfs2(ll x,ll fa,ll de)&#123;    vis[x]=1;    if(de==k) return ;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        dfs2(y,x,de+1);    &#125;&#125;int main()&#123;    n=read(),k=read(),t=read();//    printf(&quot;%lld\n&quot;,k);    if(k==0)&#123;        for(ll i=1,a,b;i&lt;=n-1;i++)&#123;            a=read(),b=read();        &#125;        printf(&quot;%lld\n&quot;,n);        return 0;    &#125;/*    if(k==1)&#123;        for(ll i=1,a,b;i&lt;=n-1;i++)&#123;            a=read(),b=read();            add(a,b);            add(b,a);        &#125;        dfs(1,1);        memset(vis,0,sizeof(vis));        dp(1);        printf(&quot;%lld\n&quot;,min(f[1][1],f[1][0]));        return 0;    &#125;*/    if(k==2)&#123;        memset(f2,0x3f,sizeof(f2));        for(ll i=1,a,b;i&lt;=n-1;i++)&#123;            a=read(),b=read();            add(a,b);            add(b,a);        &#125;        dfs(1,1);        memset(vis,0,sizeof(vis));        dp2(1);        printf(&quot;%lld\n&quot;,f2[1][2]);        return 0;    &#125;    else&#123;        for(ll i=1,a,b;i&lt;=n-1;i++)&#123;            a=read(),b=read();            add(a,b);            add(b,a);        &#125;        dfs(1,1);        memset(vis,0,sizeof(vis));        while(!q.empty())&#123;            ll x=q.top().x;            q.pop();            if(vis[x]) continue;            ll f=find(x);//            printf(&quot;x=%lld f=%lld\n&quot;,x,f);            dfs2(f,0,0);            skriller++;        &#125;        printf(&quot;%lld\n&quot;,skriller);    &#125;&#125;</code></pre><h2 id="星空"><a href="#星空" class="headerlink" title="星空"></a>星空</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先如果翻转我们楞翻转一次复杂度最高n那么考虑优化</p><p>我们将取反转化为异或</p><p>思考$1 xor 1&#x3D;0$</p><p>$0 xor 1&#x3D;1$</p><p>那么取反我们就转化为了$xor 1$</p><p>定义差分数组为$b[i]&#x3D;a[i] xor a[i+1]$</p><p>整段区间$xor1$差分（第一次看到异或的差分），我们转化为$l xor1$ $r+1xor1$</p><p>我们不可能白白翻转一段全是$1$的</p><p>我们翻转至少有$1$个零</p><p>翻转两端都有$0$那么就可以看作消去</p><p>两端只有一端有$0$那么可以看作移动</p><p>那么问题就转化为了如何最少移动消去使所有$0$变为$1$</p><p>处理出任意两个点之间消去代价（可以完全背包，把每个操作换成$+ $，$-$ 两个代价）</p><pre><code>    for(ll i=1;i&lt;=m;i++)        for(ll j=a[i];j&lt;=n;j++)            d[j]=min(d[j-a[i]]+1,d[j]);    for(ll i=1;i&lt;=m;i++)        for(ll j=n-a[i];j;j--)            d[j]=min(d[j+a[i]]+1,d[j]);</code></pre><p>考虑k很小，然后状压解决把所有点消去代价</p><pre><code>    memset(f,0x7f,sizeof(f));    f[0]=0;    for(ll i=0;i&lt;ci[cnt];i++)&#123;        for(ll j=0;j&lt;cnt;j++)&#123;            if(!(ci[j]&amp;i))&#123;                                for(ll k=j+1;k&lt;cnt;k++)&#123;                    if((!(ci[k]&amp;i)))&#123;                        if(f[i]&gt;100000000) continue;                        else &#123;//                            printf(&quot; i=%lld j=%lld k=%lld cij=%lld cik=%lld f=%lld\n&quot;,i,j,k,ci[j],ci[k],f[i]);                            f[i|ci[j]|ci[k]]=min(f[i|ci[j]|ci[k]],f[i]+d[abs(pos[j]-pos[k])]);//                            printf(&quot;f=%lld d=%lld\n&quot;,f[i],d[abs(pos[j]-pos[k])]);                        &#125;                    &#125;                &#125;                break;            &#125;        &#125;    &#125;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111111ll b[A],d[A],Xor[A],pos[A],ci[A],f[A],a[A];ll cnt,m,n,k;inline void init()&#123;    memset(d,0x3f,sizeof(d));    d[0]=0;    for(ll i=1;i&lt;=m;i++)        for(ll j=a[i];j&lt;=n;j++)            d[j]=min(d[j-a[i]]+1,d[j]);    for(ll i=1;i&lt;=m;i++)        for(ll j=n-a[i];j;j--)            d[j]=min(d[j+a[i]]+1,d[j]);    for(ll i=1;i&lt;=n;i++)&#123;        if(Xor[i])            pos[cnt++]=i;    &#125;/*    for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;%lld\n&quot;,d[i]);    &#125;    printf(&quot;cnt=%lld\n&quot;,cnt);*/&#125;inline void dp()&#123;    memset(f,0x7f,sizeof(f));    f[0]=0;    for(ll i=0;i&lt;ci[cnt];i++)&#123;        for(ll j=0;j&lt;cnt;j++)&#123;            if(!(ci[j]&amp;i))&#123;                                for(ll k=j+1;k&lt;cnt;k++)&#123;                    if((!(ci[k]&amp;i)))&#123;                        if(f[i]&gt;100000000) continue;                        else &#123;//                            printf(&quot; i=%lld j=%lld k=%lld cij=%lld cik=%lld f=%lld\n&quot;,i,j,k,ci[j],ci[k],f[i]);                            f[i|ci[j]|ci[k]]=min(f[i|ci[j]|ci[k]],f[i]+d[abs(pos[j]-pos[k])]);//                            printf(&quot;f=%lld d=%lld\n&quot;,f[i],d[abs(pos[j]-pos[k])]);                        &#125;                    &#125;                &#125;                break;            &#125;        &#125;    &#125;&#125;int main()&#123;    ci[0]=1;    for(ll i=1;i&lt;=30;i++)        ci[i]=ci[i-1]&lt;&lt;1/*,printf(&quot;ci[%lld]=%lld\n&quot;,i,ci[i])*/;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;m);    n++;    for(ll i=1,ak;i&lt;=k;i++)&#123;        scanf(&quot;%lld&quot;,&amp;ak);        b[ak]^=1;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        Xor[i]=b[i-1]^b[i];    &#125;    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);    &#125;    init();    dp();    printf(&quot;%lld\n&quot;,f[ci[cnt]-1]);&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试16「Drink·blue·weed」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9516%E3%80%8CDrink%C2%B7blue%C2%B7weed%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9516%E3%80%8CDrink%C2%B7blue%C2%B7weed%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-10 18:36</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190810174923471-9984262.png"></p><h2 id="话说这次考试"><a href="#话说这次考试" class="headerlink" title="话说这次考试"></a>话说这次考试</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190810191115336-1547365302.png"></p><h2 id="Drink"><a href="#Drink" class="headerlink" title="Drink"></a>Drink</h2><p>非常棒的一道卡常练习题，适合练习卡常</p><p>真的很棒</p><p>前置卡常知识</p><h3 id="1-char要比int快"><a href="#1-char要比int快" class="headerlink" title="1.char要比int快"></a>1.char要比int快</h3><p>char是最快的</p><p>输出putchar，输入getchar</p><p>在这个题快了7000豪</p><h3 id="2-read"><a href="#2-read" class="headerlink" title="2.read"></a>2.read</h3><p>快读非常棒，让你变得更快，fread更棒，fread会爆炸，考试时不要用fread</p><h3 id="3-循环展开"><a href="#3-循环展开" class="headerlink" title="3.循环展开"></a>3.循环展开</h3><p>循环展开非常棒，虽然看上去没什么用，然而循环展开会让你的程序快很多，循环展开往往是使你从T90到A的关键</p><h3 id="4-inline"><a href="#4-inline" class="headerlink" title="4.inline"></a>4.inline</h3><p>inline没什么用</p><p>大多数时候都没有什么用，一般时间不会发生什么变化，然而在mex这个题inline突然变得有用</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201908/1708132-20190810175712000-2010854007.png"></p><p>突然变快.jpeg</p><h3 id="5-register"><a href="#5-register" class="headerlink" title="5.register"></a>5.register</h3><p>大多数时候都没有什么用，然而有时会突然变快，有时还会变慢</p><p>暂时没有例子，（或者说只有变慢的例子）</p><h3 id="6-STL"><a href="#6-STL" class="headerlink" title="6.STL"></a>6.STL</h3><p>priority_queue手打，</p><p>stack手打</p><p>map手打（不是让你打红黑树，是hash表）</p><p>stack真的慢，stack打起来也好打，手打</p><h3 id="7-mod"><a href="#7-mod" class="headerlink" title="7.mod"></a>7.mod</h3><p>define或者const</p><p>定义成变量会很慢，</p><h3 id="8-2变1-变"><a href="#8-2变1-变" class="headerlink" title="8.*2变&lt;&lt;1 &#x2F;2 变&gt;&gt;1 &#x3D;&#x3D;变 ! ^"></a>8.*2变&lt;&lt;1 &#x2F;2 变&gt;&gt;1 &#x3D;&#x3D;变 ! ^</h3><h2 id="上面的卡常应用到这个题呢"><a href="#上面的卡常应用到这个题呢" class="headerlink" title="上面的卡常应用到这个题呢"></a>上面的卡常应用到这个题呢</h2><h3 id="char-循环展开"><a href="#char-循环展开" class="headerlink" title="char+循环展开"></a>char+循环展开</h3><p>代码</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 2100char a[A][A];ll n,m,k;const int L=1&lt;&lt;20|1;char buffer[L],*S,*T;#define getchar() ((S==T&amp;&amp;(T=(S=buffer)+fread(buffer,1,L,stdin),S==T))?EOF:*S++)const int maxn=100000+5;inline int read()&#123;    register int ret;    register char r;    while(r=getchar(),r&lt;&#39;0&#39;||r&gt;&#39;9&#39;);ret=r-48;    while(r=getchar(),r&gt;=&#39;0&#39;&amp;&amp;r&lt;=&#39;9&#39;)ret=ret*10+r-48;    return ret;&#125;int main()&#123;    n=read(),m=read(),k=read();    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            register int ret;            char r=getchar();            while(!isdigit(r)) r=getchar();            a[i][j]=r;        &#125;    for(ll j=1,x,y,c,xl,yl;j&lt;=k;j++)&#123;        x=read(),y=read(),c=read();        xl=x+c-1,yl=y+c-1;        while(c&gt;1)&#123;                for(ll i=0;i&lt;=c-2;i++)&#123;                ll a1=a[xl-i][y],a2=a[x][y+i],a3=a[x+i][y+c-1],a4=a[x+c-1][yl-i];                a[x][y+i]=a1,a[x+i][yl]=a2,a[xl][yl-i]=a3,a[xl-i][y]=a4;            &#125;            x++,y++,yl--,xl--,c-=2;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=m;j++)&#123;            putchar(a[i][j]);putchar(&#39; &#39;);        &#125;&#125;</code></pre><h2 id="blue"><a href="#blue" class="headerlink" title="blue"></a>blue</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>这个题它不卡set它卡splay！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p><p>贪心，都说这个题很水，但我还是觉得不明白，看题解也是似懂非懂的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define A 5010101#define Inf 10000000ll#define ll long long#define py printf(&quot;*****\n&quot;)#define mem(a) memset(a,0,sizeof(a))ll landu[A],head[A],nx[A],ver[A],edg[A],dep[A],a[A],bl[A],blx[A],ch[A][2],cnt[A],size[A],key[A],fa[A];ll n,m,tot=1,S,T,t,D,L,sz,rt;set&lt;ll&gt; s;inline ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c)) &#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;inline void clear(ll x)&#123;    ch[x][0]=ch[x][1]=key[x]=cnt[x]=fa[x]=size[x]=0;&#125;inline bool get(ll x)&#123;    return ch[fa[x]][1]==x;&#125;inline void pushup(ll x)&#123;    if(x)    &#123;        size[x]=cnt[x];        if(ch[x][1]) size[x]+=size[ch[x][1]];        if(ch[x][0]) size[x]+=size[ch[x][0]];    &#125;&#125;inline void rotate(ll x)&#123;    ll old=fa[x],oldfa=fa[old],which=get(x);    ch[old][which]=ch[x][which^1]; fa[ch[old][which]]=old;    ch[x][which^1]=old; fa[old]=x;    fa[x]=oldfa;    if(oldfa) ch[oldfa][ch[oldfa][1]==old]=x;    pushup(old);pushup(x); return ;&#125;inline void splay(ll x)&#123;    for(ll f;f=fa[x];rotate(x))        if(fa[f])            rotate(get(f)==get(x)?f:x);    rt=x;&#125; inline ll pre()&#123;    if(cnt[rt]&gt;1)         return rt;    ll now=ch[rt][0];    while(ch[now][1]) now=ch[now][1];    return now;&#125;inline ll nxt()&#123;        if(cnt[rt]&gt;1)        return rt;    ll now=ch[rt][1];        while(ch[now][0]) now=ch[now][0];    return now;&#125;inline void insert(ll x)&#123;    if(rt==0)    &#123;        sz++;rt=sz;        cnt[sz]=size[sz]=1;        key[sz]=x;        fa[sz]=ch[sz][0]=ch[sz][1]=0;        return ;    &#125;    ll f=0,now=rt;    while(233)    &#123;            if(key[now]==x)        &#123;            cnt[now]++;            pushup(now);            pushup(f);            splay(now);            return ;        &#125;        f=now,now=ch[now][key[now]&lt;x];        if(now==0)        &#123;            sz++;            cnt[sz]=size[sz]=1;            key[sz]=x;fa[sz]=f;            ch[sz][1]=ch[sz][0]=0;            ch[f][key[f]&lt;x]=sz;            pushup(f);splay(sz);return ;        &#125;    &#125;&#125;inline ll rnk(ll x)&#123;    ll ans=1,now=rt;    while(1)    &#123;        if(x&lt;key[now])            now=ch[now][0];        else        &#123;            ans+=size[ch[now][0]];            if(x==key[now])            &#123;                splay(now);return ans;            &#125;            ans+=cnt[now];            now=ch[now][1];        &#125;    &#125;&#125;inline void del(ll x)&#123;    rnk(x);    if(cnt[rt]&gt;1)    &#123;cnt[rt]--;pushup(rt);return ;&#125;     if(!ch[rt][0]&amp;&amp;!ch[rt][1])    &#123;clear(rt);rt=0;return ;&#125;    if(!ch[rt][0]||!ch[rt][1])    &#123;        ll old=rt;        rt=ch[rt][1]|ch[rt][0];        clear(old);        fa[rt]=0;        return ;    &#125;    ll older=rt; ll leftbigest=pre();    splay(leftbigest);    ch[rt][1]=ch[older][1];    fa[ch[older][1]]=rt;    clear(older);    pushup(rt);&#125;void re()&#123;    memset(ch,0,sizeof(ch));    memset(size,0,sizeof(size));    memset(key,0,sizeof(key));    memset(fa,0,sizeof(fa));&#125;int main()&#123;set&lt;ll&gt;::iterator it;    scanf(&quot;%lld&quot;,&amp;t);    while(t--)&#123;        n=read(),m=read(),D=read(),L=read();        s.clear();        s.insert(-0x7ffffff);        for(ll i=1;i&lt;=n;i++)&#123;            a[i]=read();//            insert(a[i]);            s.insert(a[i]);        &#125;        ll ok=1,cnt=0;        while(ok)&#123;            ll now=0;            while(now&lt;L)&#123;                if(now+D&gt;=L) break;//                insert(now+D);//                ll x=pre();//                del(now+D);                ll x=*--s.upper_bound(now+D);//                printf(&quot;x=%lld  cnt=%lld\n&quot;,x,cnt);                if(x&lt;now)&#123;                    ok=0;                    break;                &#125;//                now=key[x];                now=x;                s.erase(x);//                del(key[x]);            &#125;            if(ok==0) break;            cnt++;            if(cnt==m) break;        &#125;        if(cnt!=m)            printf(&quot;%lld\n&quot;,cnt);        else            printf(&quot;Excited\n&quot;);    &#125;&#125;</code></pre><h2 id="weed"><a href="#weed" class="headerlink" title="weed"></a>weed</h2><p>比较神的一道题，学长讲的时候我没弄明白，这次考试30分就是报应</p><p>以每个信息为下标记录三个信息，减少之后的层数，减少之后总的权值和，对之前区间减少的量</p><p>首先在建树和修改时我们将叶子节点维护好，上传时利用这三个信息进行计算就行了</p><p>优先删去右儿子节点（出现时间靠后），在右儿子不够时删除左儿子</p><p>假设我们现在已经算完左右儿子</p><p>那么如果右边儿子减少少于增加</p><p>直接无脑加即可</p><pre><code>    if(tr[rs].cut==0)&#123;        tr[x].v=tr[ls].v+tr[rs].v;        tr[x].c=tr[ls].c+tr[rs].c;        tr[x].cut=tr[ls].cut+tr[rs].cut;        return ;    &#125;</code></pre><p>如果右面儿子减少大于增加，并且右面儿子减少&gt;&#x3D;左面儿子层数和</p><p>那么当前cut会有剩余，那么v直接赋c直接赋成右面儿子剩余v，c的值，</p><pre><code>    if(tr[ls].c&lt;=tr[rs].cut)&#123;        tr[x].cut=tr[rs].cut-tr[ls].c+tr[ls].cut;        tr[x].v=tr[rs].v;        tr[x].c=tr[rs].c;        return ;    &#125;</code></pre><p>如果右面儿子减少小于左面增加，这是一种比较麻烦的情况，我们维护一个cal函数，专门计算左面儿子v的值</p><pre><code>    if(tr[ls].c&gt;tr[rs].cut)&#123;        tr[x].cut=tr[ls].cut;        tr[x].v=tr[rs].v+ask(ls,tr[rs].cut);        tr[x].c=tr[rs].c+tr[ls].c-tr[rs].cut;        return ;    &#125;</code></pre><p>cal函数具体实现很简单</p><p>当右儿子恰好够减，直接返回左儿子剩余</p><p>右儿子省的多，从右儿子的右儿子搜</p><p>右儿子不够，从左儿子搜</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 7200000#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1#define py printf(&quot;****\n&quot;)struct tree&#123;    ll l,r,v,c,cut;&#125;tr[A];ll ceng[A],cu[A];ll m,q;ll ask(ll x,ll c)&#123;//    if(c==tr[x].c) return 0;    if(tr[rs].c==c)        return tr[x].v-tr[rs].v;    else if(tr[rs].c&gt;c)        return tr[x].v-tr[rs].v+ask(rs,c);    else  return ask(ls,c-tr[rs].c+tr[rs].cut);&#125;void pushup(ll x)&#123;    if(tr[ls].c&lt;=tr[rs].cut)&#123;        tr[x].cut=tr[rs].cut-tr[ls].c+tr[ls].cut;        tr[x].v=tr[rs].v;        tr[x].c=tr[rs].c;        return ;    &#125;    if(tr[rs].cut==0)&#123;        tr[x].v=tr[ls].v+tr[rs].v;        tr[x].c=tr[ls].c+tr[rs].c;        tr[x].cut=tr[ls].cut+tr[rs].cut;        return ;    &#125;    if(tr[ls].c&gt;tr[rs].cut)&#123;        tr[x].cut=tr[ls].cut;        tr[x].v=tr[rs].v+ask(ls,tr[rs].cut);        tr[x].c=tr[rs].c+tr[ls].c-tr[rs].cut;        return ;    &#125;&#125;void built(ll p,ll l,ll r)&#123;//    printf(&quot;p=%lld l=%lld r=%lld\n&quot;,p,l,r);    tr[p].l=l,tr[p].r=r;    if(l==r)&#123;        if(cu[l]) &#123;            tr[p].cut=ceng[l];            tr[p].v=0,tr[p].c=0;            return ;        &#125;        if(!cu[l])&#123;            tr[p].v=ceng[l];            tr[p].c=1;            tr[p].cut=0;            return ;        &#125;    &#125;        ll mid=(l+r)&gt;&gt;1;    built(p&lt;&lt;1,l,mid);    built(p&lt;&lt;1|1,mid+1,r);    pushup(p);&#125;void change(ll x,ll q)&#123;    if(tr[x].l==tr[x].r)&#123;        if(!cu[q])&#123;            tr[x].v=ceng[q];            tr[x].c=1;            tr[x].cut=0;            return ;        &#125;        else&#123;            tr[x].cut=ceng[q];            tr[x].v=0,tr[x].c=0;            return ;        &#125;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=q)        change(ls,q);    else         change(rs,q);    pushup(x);&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;q);    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;cu[i],&amp;ceng[i]);    &#125;    built(1,1,m);//    printf(&quot;tr.c .v=%lld  %lld\n&quot;,tr[2].c,tr[2].v);//    printf(&quot;.c=%lld v=%lld\n&quot;,tr[3].c,tr[3].v);//    printf(&quot;.c=%lld\n&quot;,tr[1].v);    for(ll i=1,a,b,c;i&lt;=q;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);        cu[a]=b;        ceng[a]=c;        change(1,a);//        printf(&quot;p14 v=%lld c=%lld\n&quot;,tr[14].c,tr[14].v);        printf(&quot;%lld\n&quot;,tr[1].v);    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试15「建造城市city（插板法）·轰炸·石头剪刀布」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9515%E3%80%8C%E5%BB%BA%E9%80%A0%E5%9F%8E%E5%B8%82city%EF%BC%88%E6%8F%92%E6%9D%BF%E6%B3%95%EF%BC%89%C2%B7%E8%BD%B0%E7%82%B8%C2%B7%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9515%E3%80%8C%E5%BB%BA%E9%80%A0%E5%9F%8E%E5%B8%82city%EF%BC%88%E6%8F%92%E6%9D%BF%E6%B3%95%EF%BC%89%C2%B7%E8%BD%B0%E7%82%B8%C2%B7%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-09 15:25</p><h2 id="建造城市"><a href="#建造城市" class="headerlink" title="建造城市"></a>建造城市</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先思考一个简单问题</p><p>10个$toot$ 放进5间房屋，每个房屋至少有1个$toot$，方案数</p><p>思考：插板法，$10$个$toot$有$9$个缝隙，$5$间房屋转化为$4$个挡板，放在toot缝隙之间得到$C_{9}^{4}$</p><p>10个$toot$ 放进$5$间房屋，每个房屋里可以没有$toot$，方案数</p><p>思考：插板法使用条件必须是每组至少有1个，那么我们事先在每个房屋中放一个$toot$变成$15$个$toot$放进$5$个房屋，可以插板法，与上一题类似$C_{14}^{4}$</p><p>那么应用到这个题上呢？</p><p>这个题$toot$加了一个上界，非常棒对不对，我们可以考虑容斥</p><p>怎么算$\sum\limits_{i&#x3D;0}^{i&lt;&#x3D;n} {-1}^i *C_{n}^{i}<em>C_{m-i</em>k-1}^{n-1}$</p><p>前面是枚举的多的城市，后面枚举的是多的，怎么理解呢？</p><p>首先我们让$i$个城市提前选出$i*k$ 个<br>$toot$，假设我们当前是$i&#x3D;&#x3D;0$，那么我们选出的包含0个不符合情况的，1个不符合情况的，2个不符合情况的，3个不符合情况的——n个</p><p>我们只需要简单容斥一下就完了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>     #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 10101010#define mod 998244353ll ni[A],jie[A];ll n,m,k;ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;ll C(ll n,ll m)&#123;    return jie[n]*ni[n-m]%mod*ni[m]%mod;&#125;int main()&#123;    jie[0]=1;    for(ll i=1;i&lt;=10000000;i++)        jie[i]=jie[i-1]*i%mod;    ni[10000000]=meng(jie[10000000],mod-2);    for(ll i=9999999;i&gt;=1;i--)        ni[i]=ni[i+1]*(i+1)%mod;    ni[0]=1;/*    while(1)&#123;        ll a,b;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        cout&lt;&lt;C(a,b)&lt;&lt;endl;    &#125;*/    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    ll ans=0,tmp=1;    for(ll i=0;i&lt;=n;i++)&#123;        if(n-1&gt;m-i*k-1) break;        ans=(ans+tmp*C(n,i)*C(m-i*k-1,n-1)%mod)%mod;        tmp=-tmp;    &#125;    cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl;&#125;</code></pre><h2 id="轰炸"><a href="#轰炸" class="headerlink" title="轰炸"></a>轰炸</h2><p>语文不好被坑了</p><h3 id="一句话题解"><a href="#一句话题解" class="headerlink" title="一句话题解"></a>一句话题解</h3><p>tarjan缩点+最长链</p><p>代码不放了</p><h2 id="石头剪刀布"><a href="#石头剪刀布" class="headerlink" title="石头剪刀布"></a>石头剪刀布</h2><p>很奇妙的思路，但觉的现在还是似懂非懂的。</p><p>首先这个题是先计算所有概率，最后再统计贡献</p><p>和以往做的期望题不太一样</p><p>这个题没有顺序很恶心，思考换一种方法避免无序带来影响</p><p>我们发现如果只开三维，最后根本无法统计答案，统计起来会像一坨</p><p>尝试开四维？</p><p>$f[i][j][k][4]$</p><p>$f[i][j][k][1]$表示已经有$i$个人出石头，$j$个人出剪刀，$k$个人出布，下一轮出石头</p><p>$f[i][j][k][2]$表示已经有$i$个人出石头，$j$个人出剪刀，$k$个人出布，下一轮出剪刀</p><p>$f[i][j][k][3]$表示已经有$i$个人出石头，$j$个人出剪刀，$k$个人出布，下一轮出布</p><p>这样答案转移起来就很好转移了</p><p>$ans&#x3D;\sum\limits _{i&#x3D;1}^{i&lt;&#x3D;n}<br>max(f[i][j][k][1]+f[i][j][k][2]*3,f[i][j][k][2]+f[i][j][k][3]*3,f[i][j][k][3]+f[i][j][k][1]*3)$</p><p>思考状态转移</p><p>直接转移肯定难以转移，开辅助数组$g[i][j][k]$表示出$i$个石头，$j$个剪刀，$k$个布的概率</p><p>显然我们可以得到</p><p>$f[i][j][k][u]&#x3D;f[i-1][j][k][u]*x[o][1]+f[i][j-1][k][u]*x[o][2]+f[i][j][k-1][u]*x[o][3]+(x[o][1]+x[o][2]+x[o][3])*g[i][j][k]$</p><p>思考这是什么意思</p><p>拿1举例，你当前状态已经这样，你又往里面放了一个人，他出了石头，那么当前概率就等于之前的概率*转移过来的概率</p><p>下面是迪哥解释</p><p>&#x2F;&#x2F;当u&gt;0时就不太一样了，计算的是接下来出1的概率<br>&#x2F;&#x2F;它由上一轮对方出1的概率乘对方真的出了1的概率累加而来，此时i+j+k！&#x3D;s<br>&#x2F;&#x2F;因为你把这玩意当成一个背包不断往里面放对手来更新其概率<br>&#x2F;&#x2F;意思大概就是“目前的状态已经是那样了而且下一轮你遇到了s”，然后s对你的概率产生的贡献<br>&#x2F;&#x2F;所以就是你走到原状态的概率，乘上s出1的概率，就是s对目前状态的概率贡献<br>&#x2F;&#x2F;所以i+j+k&#x3D;&#x3D;s时不能枚举到3,因为相当于你的原状态里面已经有s个人了，可是你现在刚刚开始考虑第s个人啊</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>你最后统计答案时不能枚举到n因为n没有下一个人了</p><p>吴迪带注释代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//首先题意可能还有人理解错了。题目的意思是你要根据对手分别出了几个石头几个剪刀来决策//而并不是一场战斗结束后你就能知道对方具体是谁从而直接推断剩下的人#define d(x,k) for(int x=k;x&gt;=0;--x)//压行，字少int n;double x[51][4],f[51][51][51][4],ans,c[51][51];//f数组的含义：当最后一维为1～3时表示第i+j+k+1个人在前面的人出了i个1,j个2，k个3的情况下出1～3的概率//当最后一维为0时表示前i+j+k个人出了i个1,j个2，k个3的概率，即那个题解里的g数组int main()&#123;     scanf(&quot;%d&quot;,&amp;n); f[0][0][0][0]=1;//初始化    for(int i=1;i&lt;=n;++i) scanf(&quot;%lf%lf%lf&quot;,&amp;x[i][1],&amp;x[i][3],&amp;x[i][2]),        x[i][1]/=300,x[i][2]/=300,x[i][3]/=300;    //读入概率，注意顺序是132。把石头剪刀步分别抽象为123,故1胜2,2胜3,3胜1    for(int i=0;i&lt;=50;++i) c[i][0]=1;    for(int i=1;i&lt;=50;++i) for(int j=1;j&lt;=i;++j) c[i][j]+=c[i-1][j-1]+c[i-1][j];    //杨辉三角。注意：要用到50！级别的而没有取模，所以要开long long或double    for(int s=1;s&lt;=n;++s) d(i,s) d(j,s-i) d(k,s-i-j) d(u,(i+j+k==s?0:3))&#123;//有点像个背包        //你可以把s单独再开一维的数组来表示目前考虑到第几个人，更好理解但貌似会炸内存        //u为1～3时，分别枚举第几个人，前面的人出过几个1,2,3，这个人要出u        //注意u的枚举是当i+j+k！=s时才更新对方下一次出123的概率，否则只更新到达某状态的概率        //u为0时，计算到达这个状态的总概率（即题解中的g数组）        if(i)f[i][j][k][u]+=f[i-1][j][k][u]*x[s][1];//这个人s出了1,累加概率        //当u=0时,f[i][j][k][0]由f[i-1][j][k][0]转移而来（u=0并不考虑下一个人会出什么）        //在原状态出一个1即为新状态，后者的概率为x[s][1]。计算g数组就不必考虑其他f值的影响        //因为根据含义就有f[i][j][k][0]=f[i][j][k][1]+f[i][j][k][2]+f[i][j][k][3]        //当u&gt;0时就不太一样了，计算的是接下来出1的概率        //它由上一轮对方出1的概率乘对方真的出了1的概率累加而来，此时i+j+k！=s        //因为你把这玩意当成一个背包不断往里面放对手来更新其概率        //意思大概就是“目前的状态已经是那样了而且下一轮你遇到了s”，然后s对你的概率产生的贡献        //所以就是你走到原状态的概率，乘上s出1的概率，就是s对目前状态的概率贡献        //所以i+j+k==s时不能枚举到3,因为相当于你的原状态里面已经有s个人了，可是你现在刚刚开始考虑第s个人啊        if(j)f[i][j][k][u]+=f[i][j-1][k][u]*x[s][2];//出2，同上        if(k)f[i][j][k][u]+=f[i][j][k-1][u]*x[s][3];//出3，同        if(u)f[i][j][k][u]+=f[i][j][k][0]*x[s][u];        //这个就是弥补了上面的缺陷。本层转移。不管目前的状态是什么，反正第s个人就是出u了        //与上面的并不重复。一个是在说s对以前的状态的贡献，这个是在说s对当前状态的贡献    &#125;    d(i,n-1) d(j,n-1-i) d(k,n-i-j-1)//i+j+k不要枚举到n，因为已经进行过n轮后下一次再出什么已经不重要不记分了        ans+=max(max(f[i][j][k][1]+3*f[i][j][k][2],f[i][j][k][2]+3*f[i][j][k][3]),f[i][j][k][3]+3*f[i][j][k][1])/c[n][i+j+k]/(n-i-j-k);    //在每一种状态下（即确定对手已经出了i个1,j个2,k个3）时你都有唯一确定的最优决策来进行下一轮    //每一次决策时都会累加分数，3种决策分别对应出1,2,3.f[i][j][k][1]即为与1打平，3*f[i][j][k][2]即为战胜2    //你所说的最优决策就是根据已有信息（每个对手出了什么），通过猜测对手下一步会出什么来权衡3中决策    //至于为什么用到了组合数：因为你所算的概率只是到达这一步的概率，但是你是从n个人里随便选出了c[n][i+j+k]个人    //然而其实在同一场游戏中对于同样的i+j+k你只会选1次,在计算的时候你把概率累加在一起了，现在要求一个平均值    //再除一个(n-i-j-k)的原因也差不多，因为你是要从剩下的(n-i-j-k)个人里选出一个去挑战    //这一步的概率是1/(n-i-j-k)，然而你在上面5层循环的时候并没有考虑，所以在这里统一除去    printf(&quot;%.12lf\n&quot;,ans);//给的std里是用%.12f输出double的，真是惊奇&#125;//把注释全删掉你就会发现这个代码只有21行811B</code></pre><p>View Code</p><p>我这个菜鸡的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define A 52#define ll long longdouble f[A][A][A][5],x[A][5];double ans=0;ll C[A][A],n;int main()&#123;    f[0][0][0][0]=1;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=0;i&lt;=n;i++)        C[i][0]=1;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=i;j++)            C[i][j]=C[i-1][j]+C[i-1][j-1];    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lf%lf%lf&quot;,&amp;x[i][1],&amp;x[i][3],&amp;x[i][2]),        x[i][1]/=300,x[i][3]/=300,x[i][2]/=300;    for(ll o=1;o&lt;=n;o++)&#123;        for(ll i=o;i&gt;=0;i--)&#123;            for(ll j=o-i;j&gt;=0;j--)&#123;                for(ll k=o-i-j;k&gt;=0;k--)&#123;                    for(ll u=(((i+j+k)==o)?0:3);u&gt;=0;u--)&#123;                        if(i)                            f[i][j][k][u]+=f[i-1][j][k][u]*x[o][1];                        if(j)                            f[i][j][k][u]+=f[i][j-1][k][u]*x[o][2];                        if(k)                            f[i][j][k][u]+=f[i][j][k-1][u]*x[o][3];                        if(u)                            f[i][j][k][u]+=f[i][j][k][0]*x[o][u];                    &#125;                &#125;            &#125;        &#125;    &#125;    for(ll i=n-1;i&gt;=0;i--)        for(ll j=n-1-i;j&gt;=0;j--)            for(ll k=n-1-i-j;k&gt;=0;k--)&#123;                ans+=max(max(f[i][j][k][1]+f[i][j][k][2]*3,f[i][j][k][2]+f[i][j][k][3]*3),f[i][j][k][3]+f[i][j][k][1]*3)/C[n][i+j+k]/(n-i-k-j);            &#125;    printf(&quot;%.12lf\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试14「旋转子段·走格子·柱状图」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9514%E3%80%8C%E6%97%8B%E8%BD%AC%E5%AD%90%E6%AE%B5%C2%B7%E8%B5%B0%E6%A0%BC%E5%AD%90%C2%B7%E6%9F%B1%E7%8A%B6%E5%9B%BE%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9514%E3%80%8C%E6%97%8B%E8%BD%AC%E5%AD%90%E6%AE%B5%C2%B7%E8%B5%B0%E6%A0%BC%E5%AD%90%C2%B7%E6%9F%B1%E7%8A%B6%E5%9B%BE%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-08 10:18</p><h2 id="旋转子段"><a href="#旋转子段" class="headerlink" title="旋转子段"></a>旋转子段</h2><p>连60分都没想，考试一直肝t3，t2，没想到t1最简单</p><p>我一直以为t1很难，看了题解发现也就那样</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>性质1</p><p>一个包含a[i]旋转区间值域范围最多为min(a[i],i)—-max(a[i],i)</p><p>感性理解</p><p>举个例子,例如3 7 1 4 5 6 2</p><p>这个子段包含a[2]的最大为值域范围2—-7</p><p>具体证明我不会</p><p>性质2</p><p>翻转后满足固定点对的点满足</p><p>a[i]+i&#x3D;&#x3D;a[j]+j</p><p>证明</p><p>因为翻转之前a[i]&#x3D;&#x3D;j&amp;&amp;a[j]&#x3D;&#x3D;i才满足翻转之后都构成点对</p><p>移项得到a[i]+i&#x3D;&#x3D;a[j]+j</p><p>有了这两条性质我们可以得到一个$n^2$算法</p><pre><code>for(ll i=1;i&lt;=n;i++)&#123;        tot=0;        for(ll j=min(i,a[i]);j&lt;=max(i,a[i]);j++)            if(a[j]+j==a[i]+i)                tot++;&#125;</code></pre><p>得到tot最大值输出即可</p><h3 id="70分代码"><a href="#70分代码" class="headerlink" title="70分代码"></a>70分代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll f[A],a[A],sum[A];ll n,ans=-1,tot=0;vector&lt;ll&gt;too[501010];int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);        sum[i]=sum[i-1];        if(a[i]==i) sum[i]++;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        tot=0;        for(ll j=min(i,a[i]);j&lt;=max(i,a[i]);j++)&#123;            if(a[j]+j==a[i]+i)&#123;                tot++;            &#125;        &#125;//        printf(&quot;n=%lld max=%lld min=%lld i=%lld tot=%lld\n&quot;,n,max(i,a[i]),min(i,a[i]),i,tot);        ans=max(tot+sum[n]-sum[max(i,a[i])]+sum[min(i,a[i])-1],ans);    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>100分</p><p><strong>莫队维护一下询问,需要卡常,卡常到自闭,fh卡常大师</strong></p><p><strong>分块0.53最优</strong></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll intconst int A=1010101,L=1&lt;&lt;20|1;#define getchar() ((S==T&amp;&amp;(T=(S=buf)+fread(buf,1,L,stdin),S==T))?EOF:*S++)ll f[A],a[A],sum[A],tong[A],belong[A];ll n,ans=-1,l=1,r=0,ou=0,block;char buf[L],*S,*T;struct moo&#123;    ll zhong,r,l,a;    friend bool operator &lt; (moo a,moo b)&#123;        return ((belong[a.l]^belong[b.l]))?a.l&lt;b.l:((belong[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r);    &#125;&#125;mo[A];inline ll read()&#123;    ll x=0;char c=getchar();    while(!isdigit(c))c=getchar();    while(isdigit(c))x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar();    return x;&#125;int main()&#123;    n=read();    block=pow(n,0.53);    for(register ll i=1;i&lt;=n;i++)&#123;        a[i]=read();        sum[i]=sum[i-1];        if(!(a[i]^i)) sum[i]++;        belong[i]=(i-1)/block+1;    &#125;    for(register ll i=1;i&lt;=n;i++)&#123;        mo[i].zhong=i;        mo[i].r=max(i,a[i]);        mo[i].l=min(i,a[i]);        mo[i].a=a[i];    &#125;    sort(mo+1,mo+n+1);    for(register ll i=1;i&lt;=n;i++)&#123;        while(l&gt;mo[i].l) tong[l-1+a[l-1]]++,l--;        while(l&lt;mo[i].l) tong[l+a[l]]--,l++;        while(r&gt;mo[i].r) tong[r+a[r]]--,r--;        while(r&lt;mo[i].r) tong[r+1+a[r+1]]++,r++;        ans=max(tong[mo[i].zhong+mo[i].a]+sum[n]-sum[mo[i].r]+sum[mo[i].l-1],ans);    &#125;    printf(&quot;%d&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="走格子"><a href="#走格子" class="headerlink" title="走格子"></a>走格子</h2><p>显然贪心有门走门不对一个稍简单的数据就可以卡掉你</p><pre><code>7 8##########.F#..##...C..###..#..###.....##..#...#########</code></pre><p>那怎么办,只能走八个方向爆搜吗?</p><p>显然可以最短路!</p><p>从每个墙开始搜直接得到每个点到墙最短距离,然后每两相邻点之间建边,点墙之间建边</p><p>例如 (墙)</p><p>|</p><p>50</p><p>|</p><p>(墙)—–21——Q————-500000000——-(墙)</p><p>|</p><p>|</p><p>600</p><p>|</p><p>(墙)</p><p>我们只需要将Q与四个墙方向边权都设置为21即可.(例如可以在2打传送门 然后在4打传送门从2传送到4,那么所有最小代价都为21)</p><p>很简单对不对,直接跑最短路就行了</p><p>保证最短路会松弛掉一些不可行解</p><p>例如</p><p>(墙)</p><p>|</p><p>50</p><p>(墙)|</p><p>(墙)——21–Q——-500000–(墙)</p><p>|</p><p>50</p><p>|</p><p>(终点)</p><p>向上走一步再打传送门会松弛掉21这条边</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 5010101#define py printf(&quot;toot\n&quot;)#define fr first#define se second#define mp(x,y) make_pair(x,y)ll zh[610][610],top[610][610],low[610][610],zuo[610][610],you[610][610],bs[610][610],head[A],nxt[A],ver[A],edg[A],dis[A];const ll nowx[5]=&#123;0,0,0,1,-1&#125;;const ll nowy[5]=&#123;0,1,-1,0,0&#125;;bool vis[A];ll n,m,zhongx,zhongy,qix,qiy,ttt=0,tot=0;deque&lt;pair&lt;ll,ll&gt; &gt;q,toot;char s[610][610];ll id(ll i,ll j)&#123;    return (i-1)*m+j;&#125;void add(ll x,ll y,ll z)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y,edg[tot]=z;return ;&#125;void ins(ll x,ll y,ll d)&#123;    if(!bs[x][y]&amp;&amp;s[x][y]==&#39;.&#39;)&#123;        bs[x][y]=d;        q.push_back(mp(x,y));    &#125;&#125;void bfs()&#123;    while(!q.empty())&#123;        ll kx=q.front().fr,ky=q.front().se;        q.pop_front();//        py;        for(ll i=1;i&lt;=4;i++)&#123;            ins(kx+nowx[i],ky+nowy[i],bs[kx][ky]+1);        &#125;    &#125;&#125;void init()&#123;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(s[i][j]==&#39;#&#39;) continue;            if(s[i][j-1]==&#39;#&#39;) zuo[i][j]=id(i,j);            else zuo[i][j]=zuo[i][j-1];            if(s[i-1][j]==&#39;#&#39;) top[i][j]=id(i,j);            else top[i][j]=top[i-1][j];        &#125;    for(ll i=n;i&gt;=1;i--)        for(ll j=m;j&gt;=1;j--)&#123;            if(s[i][j]==&#39;#&#39;) continue;            if(s[i][j+1]==&#39;#&#39;) you[i][j]=id(i,j);            else you[i][j]=you[i][j+1];            if(s[i+1][j]==&#39;#&#39;) low[i][j]=id(i,j);            else low[i][j]=low[i+1][j];        &#125;&#125;void addb()&#123;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(s[i][j]==&#39;#&#39;) continue;            ll d=id(i,j);            if(s[i+1][j]==&#39;.&#39;) add(d,id(i+1,j),1),add(id(i+1,j),d,1);            if(s[i][j+1]==&#39;.&#39;) add(d,id(i,j+1),1),add(id(i,j+1),d,1);            if(zuo[i][j]!=d)add(d,zuo[i][j],bs[i][j]);            if(you[i][j]!=d)add(d,you[i][j],bs[i][j]);            if(top[i][j]!=d)add(d,top[i][j],bs[i][j]);            if(low[i][j]!=d)add(d,low[i][j],bs[i][j]);        &#125;&#125;void spfa(ll o)&#123;    vis[o]=1;    memset(dis,0x7f,sizeof(dis));    dis[o]=0;    deque&lt;ll&gt; toot;    toot.push_back(o);    while(!toot.empty())&#123;                ll x=toot.front();        toot.pop_front();        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i];            if(dis[y]&gt;dis[x]+edg[i])&#123;                dis[y]=dis[x]+edg[i];                if(!vis[y])&#123;                    vis[y]=1;                    toot.push_back(y);                &#125;            &#125;        &#125;        vis[x]=0;    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%s&quot;,s[i]+1);        for(ll j=1;j&lt;=m;j++)&#123;            if(s[i][j]==&#39;#&#39;)&#123;                q.push_back(mp(i,j));            &#125;            else             if(s[i][j]==&#39;C&#39;)&#123;                s[i][j]=&#39;.&#39;;                qix=i;                qiy=j;            &#125;            if(s[i][j]==&#39;F&#39;)&#123;                s[i][j]=&#39;.&#39;;                zhongx=i;                zhongy=j;            &#125;        &#125;    &#125;    bfs(),init(),addb(),spfa(id(qix,qiy));    if(dis[id(zhongx,zhongy)]&gt;=1202134)        printf(&quot;no\n&quot;);    else         printf(&quot;%lld\n&quot;,dis[id(zhongx,zhongy)]);&#125;</code></pre><p>View Code</p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>模拟退火板子题,非常板子</p><p>模拟退火最吼了</p><p>即使是板子我也要说说</p><p>首先关于</p><pre><code>    nth_element(s+1,s+mid,s+n+1);</code></pre><p>为什么要求出中位数,</p><p>前置知识</p><p>坐标轴上有很多点,点与点之间有一个距离,你将所有点移到同一个点最小花费</p><p>显然是移到中位数的点</p><p>那么应用到这个题呢?</p><p>你可以将题目要求转化,首先全部移到同一水平线上,然后再加出值</p><p>比它高的降低,比它矮的升高,换成坐标轴我们就用到了中位数</p><p>然后</p><pre><code>if(tmpans&lt;nowans||exp(-D/T)*RAND_MAX&gt;rand())</code></pre><p>为什么是</p><pre><code>exp(-D/T)*RAND_MAX&gt;rand()</code></pre><p>不是</p><pre><code>exp(D/T)*RAND_MAX&gt;rand()</code></pre><p>问的好啊!</p><p>首先我们如果当前解优那么你会通过tmpans&lt;nowans跳过</p><p>然后如果当前解不优D一定是负的,如果D为负的那么D越小-D越大.D小代表当前解非常差,让它变成其他解概率更大</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101const double eps=1e-5;const double delta=0.98;const double fj=1;ll n,ans=0x7ffffffffffffff;ll s[A],h[A];ll check(ll pos)&#123;    for(ll j=1;j&lt;=n;j++)        s[j]=h[j]+abs(pos-j);    ll mid=n+1&gt;&gt;1;    nth_element(s+1,s+mid,s+n+1);    ll val=s[mid];ll tot=0;    if(val&lt;max(pos,n-pos+1))        val=max(pos,n-pos+1);    for(ll i=1;i&lt;=n;i++)        tot+=abs(s[i]-val);    return tot;&#125;int main()&#123;    srand(time(0));    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;h[i]);    &#125;    double T=1000;    ll now=(n+1)&gt;&gt;1;    ll nowans=check(now);    while(T&gt;eps)&#123;        ll tmp=now+(2ll*rand()-RAND_MAX)*T*0.000001;        tmp=(tmp%n+n-1)%n+1;        ll tmpans=check(tmp),D=tmpans-nowans;        if(tmpans&lt;nowans||exp(-D/T)*RAND_MAX&gt;rand())            nowans=tmpans,now=tmp;        if(tmpans&lt;ans) ans=tmpans;        T*=delta;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试13「矩阵游戏&amp;#183;跳房子&amp;#183;优美序列」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9513%E3%80%8C%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F&amp;#183;%E8%B7%B3%E6%88%BF%E5%AD%90&amp;#183;%E4%BC%98%E7%BE%8E%E5%BA%8F%E5%88%97%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9513%E3%80%8C%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F&amp;#183;%E8%B7%B3%E6%88%BF%E5%AD%90&amp;#183;%E4%BC%98%E7%BE%8E%E5%BA%8F%E5%88%97%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-05 14:54</p><h2 id="矩阵游戏"><a href="#矩阵游戏" class="headerlink" title="矩阵游戏"></a>矩阵游戏</h2><p>考试时思路一度和正解一样，考试到最后还是打了80分思路，结果80分打炸了只得了40分暴力分</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>算出来第一列的总值，每次通过加每两列之间的差值得出下一列的总值</p><p>算第一列我们只需要让当前点*行增倍的数量就行了</p><pre><code>    for(ll i=1;i&lt;=n;i++)&#123;        nowlie=(nowlie+elephant(i,1)*hang[i])%mod;        sum=(sum+hang[i]);    &#125;</code></pre><p>算其他列</p><pre><code>        nowlie=(nowlie+sum)%mod;</code></pre><p>可能这一列会加倍只需乘上就行了</p><pre><code>        ans=(ans+nowlie*lie[i])%mod;</code></pre><p>思路简单代码好打，然而考试我还是打炸了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101const ll mod=1e9+7;ll n,m,nowlie=0,sum=0,ans=0,k;ll lie[A],hang[A];char c[5];ll elephant(ll i,ll j)&#123;    return ((i-1)*m%mod+j)%mod;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    for(ll i=1;i&lt;=1000000;i++)&#123;        hang[i]=1;        lie[i]=1;    &#125;    for(ll i=1,a,x;i&lt;=k;i++)&#123;        scanf(&quot;%s&quot;,c+1);        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;x);        if(c[1]==&#39;S&#39;)&#123;            lie[a]=lie[a]*x%mod;        &#125;        if(c[1]==&#39;R&#39;)&#123;            hang[a]=hang[a]*x%mod;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        nowlie=(nowlie+elephant(i,1)*hang[i])%mod;        sum=(sum+hang[i]);    &#125;    for(ll i=1;i&lt;=m;i++)&#123;        ans=(ans+nowlie*lie[i])%mod;        nowlie=(nowlie+sum)%mod;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h2 id="跳房子"><a href="#跳房子" class="headerlink" title="跳房子"></a>跳房子</h2><p>莫名和考试时思路相似 其实一点也不相似</p><h3 id="85-算法"><a href="#85-算法" class="headerlink" title="$85%$算法"></a>$85%$算法</h3><p>暴力找循环节，剩下数据经过特殊构造你AC不了的，，，，，，，，，</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longchar s[10];#define A 11111111ll vis[5100][5100],a[5100][5100];inline int read()&#123;    register int ret=0,f=1;    register char r;    r=getchar();    while(!isdigit(r))&#123;        if(r==&#39;-&#39;) f=-1;        r=getchar();    &#125;    while(isdigit(r))&#123;        ret=ret*10+r-&#39;0&#39;;        r=getchar();    &#125;    return f*ret;&#125;ll p,nowx=1,nowy=1,top=0,n,m;ll stax[A],stay[A];void work(ll x)&#123;    ll tot=0;    while(x)&#123;        ll nx=nowx,ny=nowy,d2=nx+1,d3=nx-1;        (nx+1==n+1)?d2=1:d2=nx+1;        (nx-1==0)?d3=n:d3=nx-1;        if(ny==m) ny=0;        ll z1=a[nx][ny+1],z2=a[d2][ny+1],z3=a[d3][ny+1];        if(z1&gt;z2&amp;&amp;z1&gt;z3) nowx=nx,nowy=ny+1;        else if(z2&gt;z1&amp;&amp;z2&gt;z3) nowx=d2,nowy=ny+1;        else if(z3&gt;z1&amp;&amp;z3&gt;z2) nowx=d3,nowy=ny+1;        x--;        top++;stax[top]=nowx,stay[top]=nowy;        if(!vis[nowx][nowy])            vis[nowx][nowy]=top;        else&#123;            tot=top-vis[nowx][nowy];            x=x%tot;        &#125;    &#125;    while(top)&#123;        ll x=stax[top],y=stay[top];        vis[x][y]=0;        top--;    &#125;    printf(&quot;%lld %lld\n&quot;,nowx,nowy);&#125;int main()&#123;    n=read(),m=read();    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            a[i][j]=read();    p=read();    for(ll i=1,aa,bb,cc;i&lt;=p;i++)&#123;        scanf(&quot;%s&quot;,s+1);        if(s[1]==&#39;m&#39;)&#123;            cc=read();            work(cc);        &#125;        if(s[1]==&#39;c&#39;)&#123;            aa=read(),bb=read(),cc=read();            a[aa][bb]=cc;        &#125;    &#125;&#125;</code></pre><h3 id="100-算法"><a href="#100-算法" class="headerlink" title="$100%$算法"></a>$100%$算法</h3><p>和找循环节类似但又有很大区别，</p><p>思考循环节问题出现在那？</p><p>可能会遍历整张图才找到一个循环节，即使你预处理了找到循环节，那么出现change正好改掉循环节，再move找循环节，再change<br>再move你就被卡死了，复杂度本身就有问题</p><p>那么没办法做了吗</p><p>建立置换，走到一个点，如果步数大就直接置换，步数小就暴力走</p><p>我们用一个线段树来维护这个置换如果从1–m建树，那么t[1]就表示走m步置换成哪里</p><p>每次走m步</p><p>走的次数就是v&#x2F;m</p><p>根据置换的运算$t^k$就是走了k次每次走t步</p><p>通过快速幂算出置换得出结果</p><p>那么我们经过%可以快速算出来剩下的，剩下的步数暴力走即可</p><p>顺便学了置换的运算</p><p>c.g[i]&#x3D;a.g[t.g[i]];</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101ll n,m,k,nowx=1,nowy=1;ll f[2100][2100];char znsbc[10];struct node&#123;    ll g[2100];    node()&#123;        for(ll i=1;i&lt;=n;i++)            g[i]=i;    &#125;    node operator *(const node &amp;a)&#123;        node t=*this,c;        for(ll i=1;i&lt;=n;i++)            c.g[i]=a.g[t.g[i]];        return c;    &#125;&#125;nxt[2100];struct tree&#123;    ll l,r,f;    node t;&#125;tr[10100];inline void up(ll p)&#123;    tr[p].t=tr[p&lt;&lt;1].t*tr[p&lt;&lt;1|1].t;    return ;&#125;inline void built(ll p,ll l,ll r)&#123;    tr[p].l=l,tr[p].r=r;    if(l==r)&#123;        tr[p].t=nxt[l];        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(p&lt;&lt;1,l,mid);    built(p&lt;&lt;1|1,mid+1,r);    up(p);&#125;inline void add(ll p,ll o)&#123;//    printf(&quot;l=%lld r=%lld\n&quot;,l,r);    if(tr[p].l==tr[p].r)&#123;        tr[p].t=nxt[o];        return ;    &#125;    ll mid=(tr[p].l+tr[p].r)&gt;&gt;1;    if(mid&gt;=o)        add(p&lt;&lt;1,o);    else        add(p&lt;&lt;1|1,o);    up(p);&#125;inline node meng(node x,ll k)&#123;    node ans;    for(;k;k&gt;&gt;=1,x=x*x)        if(k&amp;1)                ans=ans*x;    return ans;&#125;inline ll get(ll k,ll flag)&#123;    if(k==(flag?m+1:n+1))        return 1;    if(!k)        return flag?m:n;    return k;&#125;inline void change(ll xx,ll yy)&#123;    ll maxn=0;    xx=get(xx,0);    yy=get(yy,1);    for(ll i=-1;i&lt;=1;i++)&#123;        ll x=get(xx+i,0),y=get(yy+1,1);        if(maxn&lt;f[x][y]) maxn=f[x][y],nxt[yy].g[xx]=x;    &#125;    return ;&#125;inline void move(ll x)&#123;    while(x)        x--,nowx=nxt[nowy].g[nowx],nowy=get(nowy+1,1)/*,printf(&quot;x=%lld\n&quot;,x)*/;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            scanf(&quot;%lld&quot;,&amp;f[i][j]);    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            change(i,j);    built(1,1,m);    scanf(&quot;%lld&quot;,&amp;k);    for(ll i=1,a,b,c,v,o;i&lt;=k;i++)&#123;        scanf(&quot;%s&quot;,znsbc+1);        if(znsbc[1]==&#39;m&#39;)&#123;            scanf(&quot;%lld&quot;,&amp;v);            ll len=min(v,m-nowy+1);            move(len);            v-=len;            if(v)&#123;                nowx=meng(tr[1].t,v/m).g[nowx];                v%=m;                if(v)&#123;                    move(v);                &#125;            &#125;            printf(&quot;%lld %lld\n&quot;,nowx,nowy);        &#125;        else&#123;            scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);            f[a][b]=c;            for(ll j=-1;j&lt;=1;j++)                change(a+j,b-1)/*,printf(&quot;*****\n&quot;);*/;            o=get(b-1,1);            add(1,o);        &#125;    &#125;&#125;</code></pre><h3 id="随机数据生成"><a href="#随机数据生成" class="headerlink" title="随机数据生成"></a>随机数据生成</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll random(ll n)&#123;    return rand()%n;&#125;bool a[3210520];int main()&#123;    freopen(&quot;mkd.txt&quot;,&quot;w&quot;,stdout);     srand((unsigned)time(0));    ll n=random(5)+5,m=random(5)+5;    printf(&quot;%lld %lld\n&quot;,n,m);    for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))        for(ll j=1;j&lt;=m;j++)&#123;            ll x=random(550);            while(a[x]) x=random(550);            printf(&quot;%lld &quot;,x);        &#125;    ll k=random(50)+50;    printf(&quot;%lld\n&quot;,k);    for(ll i=1;i&lt;=k;i++)    &#123;        ll op=random(2);        if(op) &#123;            printf(&quot;move &quot;);            printf(&quot;%lld\n&quot;,random(50000)+50000);        &#125;        else&#123;            printf(&quot;change &quot;);            ll l=random(n)+1;            ll r=random(m)+1;            printf(&quot;%lld %lld %lld\n&quot;,l,r,random(50)+50);         &#125;    &#125;    fclose(stdout);&#125;</code></pre><p>View Code</p><h2 id="t3做法尤其玄学"><a href="#t3做法尤其玄学" class="headerlink" title="t3做法尤其玄学"></a>t3做法尤其玄学</h2><p>做法1，把序列问题转化为图论？？？？？？？？线段树优化建边+tarjan缩点+线段树维护图中内容我不会</p><p>做法2，扫描线，一条性质，若a&lt;&#x3D;b&lt;&#x3D;c&lt;&#x3D;d并且a–c是好区间，b–d是好区间，那么a–d是好区间</p><p>假设我们扫描到i i+1，那么如果i i+1在好区间里，那么val[i] val[i+1]都在好区间里,</p><p>设好的二元组为相邻两个数,那么区间若为好区间好二元组数量为r-l</p><p>用一棵线段树维护二元组数量设为v,若v+l&#x3D;r则是好区间,假设我们当前扫描到了a[i],那么处于a[i]-1 a[i]+1的位置都要加1</p><p>线段树维护一下,细节比较多</p><p>做法3,性质若r-l&#x3D;maxval-minval那么就是一个好区间</p><p>那么若maxval到minval之间全部出现那么是一个好区间,那么位置最左最右值出现即可,,</p><p>线段树维护一下||st表维护一下</p><p>但做法3本身复杂度不对,随机数据下表现优秀,但会被特殊数据卡</p><p>分块优化一下</p><pre><code>#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define min(a,b) ((a&lt;b)?(a):(b))#define max(a,b) ((a&gt;b)?(a):(b))using namespace std;int mn[20][MAXN],mx[20][MAXN],mh[MAXN],a[MAXN],n,mnpos[20][MAXN],mxpos[20][MAXN],ans1[2005][2005],ans2[2005][2005],t;int bl[MAXN];vector&lt;int&gt;ld;void pre()&#123;    for(int i=1;i&lt;=n;i++)        for(int j=17;j&gt;=0;j--)            if(i&gt;=(1&lt;&lt;j))             &#123;                mh[i]=j;                break;            &#125;    for(int i=1;i&lt;=17;++i)        for(int j=1;j&lt;=n;++j)        &#123;            mn[i][j]=min(mn[i-1][j],mn[i-1][j+(1&lt;&lt;(i-1))]);            mx[i][j]=max(mx[i-1][j],mx[i-1][j+(1&lt;&lt;(i-1))]);            mnpos[i][j]=min(mnpos[i-1][j],mnpos[i-1][j+(1&lt;&lt;(i-1))]);            mxpos[i][j]=max(mxpos[i-1][j],mxpos[i-1][j+(1&lt;&lt;(i-1))]);        &#125;    return ;&#125;/*const int L=1&lt;&lt;20|1;char buffer[L],*S,*T;#define getchar() ((S==T&amp;&amp;(T=(S=buffer)+fread(buffer,1,L,stdin),S==T))?EOF:*S++)*/inline int Rd()&#123;    int x=0;char c=getchar();    while(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;)c=getchar();    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;x=x*10+c-48;c=getchar();&#125;    return x;&#125;inline int gmax(int l,int r)&#123;    return max(mx[mh[r-l+1]][l],mx[mh[r-l+1]][r-(1&lt;&lt;mh[r-l+1])+1]);&#125;inline int gmin(int l,int r)&#123;    return min(mn[mh[r-l+1]][l],mn[mh[r-l+1]][r-(1&lt;&lt;mh[r-l+1])+1]);&#125;inline int qmax(int l,int r)&#123;    return max(mxpos[mh[r-l+1]][l],mxpos[mh[r-l+1]][r-(1&lt;&lt;mh[r-l+1])+1]);&#125;inline int qmin(int l,int r)&#123;    return min(mnpos[mh[r-l+1]][l],mnpos[mh[r-l+1]][r-(1&lt;&lt;mh[r-l+1])+1]);&#125;int main()&#123;//    freopen(&quot;sequence21.in&quot;,&quot;r&quot;,stdin);    n=Rd();    t=pow(n,0.7);    for(int i=1;i&lt;=n;i++)     &#123;        a[i]=Rd();        mn[0][i]=mx[0][i]=a[i];        mnpos[0][a[i]]=mxpos[0][a[i]]=i;    &#125;    int p=0,tot=0;    while(p&lt;n)    &#123;        ld.push_back(p+1);        for(int i=1;i&lt;=t;i++)bl[p+i]=tot;        p+=t;        tot++;    &#125;    pre();    memset(ans1,0x3f,sizeof(ans1));    memset(ans2,-0x3f,sizeof(ans2));    for(int i=0;i&lt;ld.size();i++)        for(int j=i;j&lt;ld.size();j++)        &#123;            int l,r;            l=ld[i];            r=ld[j];            int nowmin=gmin(l,r),nowmax=gmax(l,r);            int pl=qmin(nowmin,nowmax),pr=qmax(nowmin,nowmax);            while(l&gt;pl||r&lt;pr)            &#123;                if(l&gt;pl)                &#123;                    nowmin=min(nowmin,gmin(pl,l));                    nowmax=max(nowmax,gmax(pl,l));                    l=pl;                &#125;                if(r&lt;pr)                &#123;                    nowmin=min(nowmin,gmin(r,pr));                    nowmax=max(nowmax,gmax(r,pr));                    r=pr;                &#125;                pl=qmin(nowmin,nowmax);pr=qmax(nowmin,nowmax);            &#125;            ans1[i][j]=l;ans2[i][j]=r;    //        cout&lt;&lt;ans1[i][j]&lt;&lt;&#39; &#39;&lt;&lt;ans2[i][j]&lt;&lt;endl;        &#125;    int Q;    Q=Rd();    while(Q--)    &#123;        register int l,r,ll,rr;        l=Rd();r=Rd();        ll=bl[l]+1;rr=bl[r]-1;        int nowmin=gmin(l,r),nowmax=gmax(l,r);        int pl=qmin(nowmin,nowmax),pr=qmax(nowmin,nowmax);        while(l&gt;pl||r&lt;pr)        &#123;            ll=bl[l]+1;rr=bl[r]-1;            if(l&gt;pl)            &#123;                nowmin=min(nowmin,gmin(pl,l));                nowmax=max(nowmax,gmax(pl,l));                l=pl;                l=min(l,ans1[ll][rr]);            &#125;            if(r&lt;pr)            &#123;                nowmin=min(nowmin,gmin(r,pr));                nowmax=max(nowmax,gmax(r,pr));                r=pr;                r=max(r,ans2[ll][rr]);            &#125;            pl=qmin(nowmin,nowmax);pr=qmax(nowmin,nowmax);        &#125;        printf(&quot;%d %d\n&quot;,l,r);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试11「string&amp;#183;matrix&amp;#183;big」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9511%E3%80%8Cstring&amp;#183;matrix&amp;#183;big%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9511%E3%80%8Cstring&amp;#183;matrix&amp;#183;big%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-08-02 08:03</p><p>打的big出了点小问题，maxx初值我设的0然后少了10分</p><p>第二题暴力打炸</p><p>第一题剪了一些没用的枝依然40分</p><p>总分70</p><p>这是一次失败的考试</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>想到和序列那个题很像，但我没做序列，考场回忆学长讲课，打不出来。最后我口胡了一个CDQ分治，大概能减很多枝比如之前5 6 修改，之后4 6修改，那么其实你5<br>6不用改。</p><p>秉承这个思路，我随意打了一个分治，然后依然40分。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们可以维护每一段区间字母个数，维护一个桶，每次询问先把桶求出来，按照顺序排序时我们可以顺序枚举26个字母，进行区间修改，然后按照逆序反过来枚举就好了。这样把修改操作转化为若干个区间修改。但单单这么做我们会T，维护起来也不好维护，各种懒标记很恶心，我们还需要别的特殊姿势，</p><p>if(tr[p].a) tr[p&lt;&lt;1].a&#x3D;tr[p].a,tr[p&lt;&lt;1|1].a&#x3D;tr[p].a;</p><p>这样做我们修改和询问就不用递归到儿子节点了，而且这样我们还节省了维护懒标记时间</p><p>那么我们思考如何维护</p><p>修改时</p><pre><code>    if(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r||tr[p].a==x)&#123;        tr[p].a=x;        return ;    &#125;</code></pre><p>若区间不完全覆盖</p><p>if(tr[p].a) tr[p&lt;&lt;1].a&#x3D;tr[p].a,tr[p&lt;&lt;1|1].a&#x3D;tr[p].a,tr[p].a&#x3D;0;</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101struct tree&#123;    ll x,f,a,l,r;&#125;tr[A];char s[A];ll w[A];ll n,m;map&lt;ll,char&gt;mp;void built(ll p,ll l,ll r)&#123;    tr[p].l=l,tr[p].r=r;    if(l==r)&#123;//        printf(&quot;l=%lld s=%lld\n&quot;,l,s[l]-&#39;a&#39;+1ll);        tr[p].a=s[l]-&#39;a&#39;+1;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(p&lt;&lt;1,l,mid);    built(p&lt;&lt;1|1,mid+1,r);    if(tr[p&lt;&lt;1].a==tr[p&lt;&lt;1|1].a)        tr[p].a=tr[p&lt;&lt;1].a;&#125;void getsum(ll p,ll l,ll r)&#123;//    printf(&quot;l=%lld r=%lld l=%lld r=%lld tr[p].a=%lld\n&quot;,tr[p].l,tr[p].r,l,r,tr[p].a);    if(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r&amp;&amp;tr[p].a)&#123;        w[tr[p].a]+=(tr[p].r-tr[p].l+1);        return ;    &#125;    ll mid=(tr[p].l+tr[p].r)&gt;&gt;1;    if(tr[p].a) tr[p&lt;&lt;1].a=tr[p].a,tr[p&lt;&lt;1|1].a=tr[p].a;    if(mid&gt;=l)getsum(p&lt;&lt;1,l,r);    if(mid&lt;r)getsum(p&lt;&lt;1|1,l,r);&#125;void change(ll p,ll l,ll r,ll x)&#123;//    printf(&quot;l=%lld r=%lld ***\n&quot;,l,r);    if(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r||tr[p].a==x)&#123;        tr[p].a=x;        return ;    &#125;    ll mid=(tr[p].l+tr[p].r)&gt;&gt;1;//    printf(&quot;tr[%lld]=%lld\n&quot;,p,tr[p].a);        if(tr[p].a) tr[p&lt;&lt;1].a=tr[p].a,tr[p&lt;&lt;1|1].a=tr[p].a,tr[p].a=0;    if(mid&gt;=l) change(p&lt;&lt;1,l,r,x);    if(mid&lt;r) change(p&lt;&lt;1|1,l,r,x);&#125;void out(ll p)&#123;//    printf(&quot;p=%lld tr[p].a=%lld mp=%c\n&quot;,p,tr[p].a,mp[tr[p].a]);    if(tr[p].a)&#123;        for(ll i=1;i&lt;=tr[p].r-tr[p].l+1;i++)            printf(&quot;%c&quot;,(char)mp[tr[p].a]);        return ;    &#125;    out(p&lt;&lt;1);    out(p&lt;&lt;1|1);&#125;void pre()&#123;    for(ll i=1;i&lt;=26;i++)        mp[i]=&#39;a&#39;+i-1;    return ;&#125;int main()&#123;    pre();    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    scanf(&quot;%s&quot;,s+1);    built(1,1,n);    for(ll i=1,a,b,c,t;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);            getsum(1,a,b);        ll l=a;        if(c)&#123;            for(ll t=1;t&lt;=26;t++)                if(w[t])                    change(1,l,l+w[t]-1,t),l=l+w[t],w[t]=0;        &#125;        else &#123;            for(ll t=26;t&gt;=1;t--)                if(w[t])                    change(1,l,l+w[t]-1,t),l=l+w[t],w[t]=0;        &#125;    &#125;    out(1);    puts(&quot;&quot;);&#125;</code></pre><h2 id="big"><a href="#big" class="headerlink" title="big"></a>big</h2><h3 id="题解咕咕咕"><a href="#题解咕咕咕" class="headerlink" title="题解咕咕咕"></a>题解咕咕咕</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 6000000using namespace std;ll tire[A][2],t[A],sum[A],dl[A],a[A];ll tot=1,n,m,maxx=0,ans=0;bool pan;ll change(ll x)&#123;    return (2*x/(1&lt;&lt;n)+2*x)%(1&lt;&lt;n);&#125;bool cmp(ll x,ll y)&#123;    return x&gt;y;&#125;inline void insert(ll x)&#123;    ll p=1;    for(ll i=1;i&lt;=n;i++)    &#123;        ll zan=(x&gt;&gt;(n-i))&amp;1;//        printf(&quot;zan=%lld tot=%lld\n&quot;,zan,tot);        if(!tire[p][zan]) tire[p][zan]=++tot;        p=tire[p][zan];    &#125;&#125;inline ll dfs(ll x,ll zhi,ll deep)&#123;    if(deep&lt;0)&#123;        dl[++dl[0]]=zhi;    &#125;//    printf(&quot;trie[0][1]=[%lld][%lld] deep=%lld zhi=%lld 1&lt;&lt;=%lld\n&quot;,tire[x][0],tire[x][1],deep,zhi,1ll&lt;&lt;deep);    if(tire[x][0]&amp;&amp;!tire[x][1])        dfs(tire[x][0],zhi^(1ll&lt;&lt;deep),deep-1);    if(!tire[x][0]&amp;&amp;tire[x][1])        dfs(tire[x][1],zhi^(1ll&lt;&lt;deep),deep-1);    if(tire[x][0]&amp;&amp;tire[x][1])&#123;        dfs(tire[x][0],zhi,deep-1);dfs(tire[x][1],zhi,deep-1);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=m;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    for(ll i=m;i&gt;=1;i--)        sum[i]=sum[i+1]^a[i];    for(ll i=0,now=0;i&lt;=m;i++)&#123;//        printf(&quot;now=%lld  add=%lld\n&quot;,now,now^sum[i+1]);        now=now^change(a[i]);        insert(now^sum[i+1]);    &#125;//    printf(&quot;1 %lld 0%lld\n&quot;,tire[1][1],tire[1][0]);    dfs(1,0,n-1);    sort(dl+1,dl+dl[0]+1,cmp);    for(ll i=1;i&lt;=dl[0];i++)    if(dl[i]==dl[1]) ans++;    printf(&quot;%lld\n%lld\n&quot;,dl[1],ans);&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试10「大佬·辣鸡·模板」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9510%E3%80%8C%E5%A4%A7%E4%BD%AC%C2%B7%E8%BE%A3%E9%B8%A1%C2%B7%E6%A8%A1%E6%9D%BF%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9510%E3%80%8C%E5%A4%A7%E4%BD%AC%C2%B7%E8%BE%A3%E9%B8%A1%C2%B7%E6%A8%A1%E6%9D%BF%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-29 15:42</p><h2 id="大佬"><a href="#大佬" class="headerlink" title="大佬"></a>大佬</h2><p>显然假期望</p><p>我奇思妙想出了一个式子$f[i]&#x3D;f[i-1]+\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;m} C_{k \times j}^{k}\times<br>w[j]$</p><p>然后一想不对得容斥</p><p>于是我得到$f[i]&#x3D;f[i-1]+\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;m} C_{j\times(k-1)}^{k-1} \times w[j]$</p><p>但还是不对</p><p>现在思考第一个式子为什么不对</p><p>我们枚举矩阵选数</p><p>1 2 3</p><p>1 2 3</p><p>1 2 3</p><p>这样我们C的话概率会很鬼$\frac {4}{12}$$\times$$\frac {3}{11}$$\times$$\frac {2}{10}$</p><p>显然应该是$\frac 1 3$$\times $$\frac 1 3$$\times$$\frac 1 3$</p><p>我算小了</p><p>真的是小了吗？</p><p>思考第二个式子为什么不对，显然我们如果这样做应该再乘$C_{k}^{1}$但这么乘起来会重复</p><p>1111111会被多贡献很多回</p><p>还是要容斥</p><p>然后考试时我思维就停止了</p><p>我们或许可以换种思路考虑</p><p>同样是一个区间，我们这样算区间贡献</p><p>$\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;m} j^k-(j-1)^k$</p><p>理解一下</p><p>$j^k$表示$&lt;&#x3D;j$随便选，然后再容斥掉$(j-1)^k$（所有都比j小，选不到j）</p><p>得到贡献</p><p>然后再用f转移即可</p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 700000using namespace std;const ll mod=1e9+7;ll n,m,k,sumday,w[A],ni,ans=0;inline ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    if(k&gt;n) &#123;        puts(&quot;0&quot;);        return 0;    &#125;    ni=1;    for(ll i=1;i&lt;=m;i++)        scanf(&quot;%lld&quot;,&amp;w[i]);    for(ll i=1;i&lt;=m;i++)        ((ans=(ans%mod+(meng(i,k)%mod-meng(i-1,k)%mod+mod)*w[i]%mod)%mod))%=mod;    ans=ans*(n-k+1)%mod;    ni=meng(meng(m,k),mod-2)%mod;    cout&lt;&lt;ans%mod*ni%mod&lt;&lt;endl;&#125;</code></pre><h2 id="辣鸡"><a href="#辣鸡" class="headerlink" title="辣鸡"></a>辣鸡</h2><p>考试历程：</p><p>想到$n^2$过不了应该是$n^log$的，或许是$n^{log^2}$</p><p>反正$n^2$能过我吃掉键盘</p><p>然后我就思考，我tm应该用什么呢，CDQ？树状数组？线段树？权值线段树？还是像上次光那个题一样的傻逼大模拟？</p><p>偶对了，一定是像光那个题一样的傻逼题。</p><p>但我的光现在还没有过啊。。</p><p>这个题暴力分好少啊</p><p>然后我还是打了个普通$n^2$然后发现它炸了。</p><p>我发现难以调出来还是改成了xy相关</p><p>考完后</p><p>这个题还真$n^2$能过</p><p>完了我没有立flag</p><p>后来得知是优化过的$n^2$</p><p>打起来像插头dp</p><p>首先矩阵内的贡献我们可以用(x2-x1)*(y2-y1)*2算出来</p><p>然后矩阵之间分很多种情况</p><p>然而每一种都比较简单,比插头简单的多</p><p>方格表示过于,,,容易出现各种错误,格点表示</p><p>具体还是看代码</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1100000struct node&#123;    ll x1,x2,y1,y2;    friend bool operator &lt;(const node a,const node b)&#123;        return ((a.x1==b.x1)?a.y1&lt;b.y1:a.x1&lt;b.x1);    &#125;&#125;nd[A];ll ans=0,n;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;nd[i].x1,&amp;nd[i].y1,&amp;nd[i].x2,&amp;nd[i].y2);        ans+=(nd[i].x2-nd[i].x1)*(nd[i].y2-nd[i].y1)*2;    &#125;    sort(nd+1,nd+n+1);    for(ll i=1;i&lt;n;i++)&#123;        for(ll j=i+1;j&lt;=n;j++)&#123;            if(nd[j].x1&gt;nd[i].x2+1) break;            if(nd[i].y2+1&lt;nd[j].y1||nd[i].y1-1&gt;nd[j].y2) continue;//            printf(&quot;ix1=%lld iy1=%lld jx1=%lld jy1=%lld\n&quot;,nd[i].x1,nd[i].y1,nd[j].x1,nd[j].y1);            if(nd[j].x1&gt;nd[i].x2)&#123;                if(nd[i].y2&lt;nd[j].y1||nd[i].y1&gt;nd[j].y2) ans++;                else if(nd[i].y1==nd[j].y1)&#123;                    if(nd[i].y2==nd[j].y2)                        ans+=(nd[i].y2-nd[i].y1)*2;                    else if(nd[i].y2&lt;nd[j].y2)                         ans+=(nd[i].y2-nd[i].y1)*2+1;                    else if(nd[i].y2&gt;nd[j].y2)                        ans+=(nd[j].y2-nd[i].y1)*2+1;                &#125;                else if(nd[i].y2==nd[j].y2)&#123;                    if(nd[i].y1==nd[j].y1)                        ans+=(nd[i].y2-nd[j].y1)*2;                    else if(nd[i].y1&lt;nd[j].y1)                        ans+=(nd[i].y2-nd[j].y1)*2+1;                    else if(nd[i].y1&gt;nd[j].y1)                        ans+=(nd[i].y2-nd[i].y1)*2+1;                &#125;                else if(nd[i].y2&gt;nd[j].y2&amp;&amp;nd[i].y1&lt;nd[j].y1)                    ans+=(nd[j].y2-nd[j].y1)*2+2;                else if(nd[i].y2&lt;nd[j].y2&amp;&amp;nd[i].y1&lt;nd[j].y1)                    ans+=(nd[i].y2-nd[j].y1)*2+2;                else if(nd[i].y2&gt;nd[j].y2&amp;&amp;nd[i].y1&gt;nd[j].y1)                    ans+=(nd[j].y2-nd[i].y1)*2+2;                else if(nd[i].y2&lt;nd[j].y2&amp;&amp;nd[i].y1&gt;nd[j].y1)                    ans+=(nd[i].y2-nd[i].y1)*2+2;//                printf(&quot;second%lld\n&quot;,ans);            &#125;            else&#123;                if(nd[i].x1==nd[j].x1)&#123;                    if(nd[i].x2==nd[j].x2)                        ans+=(nd[i].x2-nd[i].x1)*2;                    else if(nd[i].x2&lt;nd[j].x2)                         ans+=(nd[i].x2-nd[i].x1)*2+1;                    else if(nd[i].x2&gt;nd[j].x2)                        ans+=(nd[j].x2-nd[i].x1)*2+1;                                    &#125;                else if(nd[i].x2==nd[j].x2)&#123;                    if(nd[i].x1==nd[j].x1)                        ans+=(nd[i].x2-nd[j].x1)*2;                    else if(nd[i].x1&lt;nd[j].x1)                        ans+=(nd[i].x2-nd[j].x1)*2+1;                    else if(nd[i].x1&gt;nd[j].x1)                        ans+=(nd[i].x2-nd[i].x1)*2+1;                &#125;                else if(nd[i].x2&gt;nd[j].x2)                    ans+=(nd[j].x2-nd[j].x1)*2+2;                else if(nd[i].x1&lt;nd[j].x1&amp;&amp;nd[i].x2&lt;nd[j].x2)                    ans+=(nd[i].x2-nd[j].x1)*2+2;//                printf(&quot;frist%lld\n&quot;,ans);            &#125;//            printf(&quot;i=%lld j=%lld ans=%lld\n&quot;,i,j,ans);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>我一开始确实以为是模板</p><p>然后就开始打了,树差,线段树,权值线段树,合并往上仍</p><blockquote><p>不就是和雨天的尾巴差不多的一道题目吗 AC预订</p></blockquote><p>然后越想越不对,觉得难以维护桶</p><p>看数据范围不维护桶勉强可以70分</p><blockquote><p>那就先得70分吧</p></blockquote><p>然后我就打炸了,看着最后时间将至赶紧删了打暴力</p><blockquote><p>暴力树上差分还有30分,树上差分打对就行</p></blockquote><p>然后树上差分我觉得也不行,也是相当难维护,set,vector,map,multiset往上仍,但无济于事</p><blockquote><p>最小的点是10 10 10,打个纯暴力还有10分呢</p></blockquote><p>我成功奶死了自己</p><p>0分!</p><p>tqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltqltql</p><p>说一下这个怎么做</p><p>前置知识：</p><p>启发式合并</p><p>线段树</p><p>注意很多细节，我会在启发式合并中具体讲</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试9「随·单·题」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%959%E3%80%8C%E9%9A%8F%C2%B7%E5%8D%95%C2%B7%E9%A2%98%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%959%E3%80%8C%E9%9A%8F%C2%B7%E5%8D%95%C2%B7%E9%A2%98%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-28 11:32</p><p>liu_runda出的题，先$%%%%%%%%%%%$为敬</p><h2 id="随"><a href="#随" class="headerlink" title="随"></a>随</h2><p>考试时没有Qj 然后甚至没做,甚至没交</p><p>我不知道我怎么想的</p><p>这个题挺难改</p><p>你需要用到</p><p>循环矩阵快速幂,矩阵快速幂优化,打表找规律的基础</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先我们可以列出来一个普通的dp式子</p><p>设f为第i次操作,操作后x变为j的概率得到$f[i][j*a[q]%mod]&#x3D;f[i-1][j]$</p><p>思考mod范围很大,那么肯定与mod无关或者矩阵快速幂,</p><p>那么我们尝试矩阵快速幂</p><p>但用了矩阵快速幂还是超时,$n^3*log$复杂度还是吃不消</p><p>观察孙金宁的嘱托</p><p>看,原根?原根可以取遍mod-1</p><p>还是很多加法</p><p>发现这是一个循环矩阵</p><p>然后我们就可以循环矩阵优化一下了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1100000const ll mod=1e9+7;ll c[A],a[A],b[A],al[A],base[A],res[A],qpow[A],ans[A],n,m,g,k,p,sum=0;//al表示now存在不存在//qpow表示j的几次方为多少inline ll meng(ll base,ll k,ll mode)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,base=base*base%mode)        if(k&amp;1)            ans=ans*base%mode;    return ans;&#125;void mult_base()&#123;    for(ll i=0;i&lt;p;++i)        for(ll j=0;j&lt;p;++j)            (res[j]+=base[i]*base[(j-i+p)%p])%=mod;    for(ll i=0;i&lt;p;++i)        base[i]=res[i],res[i]=0;&#125;void mult_ans()&#123;    for(ll i=0;i&lt;p;++i)        for(ll j=0;j&lt;p;++j)            (res[j]+=ans[i]*base[(j-i+p)%p])%=mod;    for(ll i=0;i&lt;p;++i)        ans[i]=res[i],res[i]=0;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p);    ans[0]=1;    const ll ni=meng(n,mod-2,mod);//    cout&lt;&lt;p&lt;&lt;endl;    for(ll i=0;i&lt;=1000;i++)        al[i]=-1;    for(ll i=1;i&lt;p;i++)&#123;        ll now=1,j;        for(j=0;j&lt;p;j++)&#123;            if(al[now]==-1)            &#123;                al[now]=j;                qpow[j]=now;                now=now*i%p;//                printf(&quot;now=%lld i=%lld al[now]=%lld j=%lld\n&quot;,now,i,al[now],j);            &#125;            else break;        &#125;        if(j==p-1) &#123;            g=i;break;        &#125;        else            for(ll q=0;q&lt;=p;q++)                al[q]=-1;        for(ll q=0;q&lt;=p;q++)&#123;//            printf(&quot;al=%lld\n&quot;,al[q]);        &#125;            &#125;    p--;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);//        printf(&quot;a=%lld al=%lld\n&quot;,a[i],al[a[i]]);        a[i]=al[a[i]];    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        (base[a[i]]+=ni)%=mod;//        printf(&quot;%lld %=%lld\n&quot;,ni,ni%mod);    &#125;//    for(ll i=0;i&lt;=p;i++)&#123;//        cout&lt;&lt;a[i]&lt;&lt;&quot;   &quot;&lt;&lt;base[a[i]]&lt;&lt;endl;//    &#125;    for(;m;m&gt;&gt;=1,mult_base())        if(m&amp;1)            mult_ans();    for(ll i=0;i&lt;p;i++)        sum=(sum+ans[i]*qpow[i])%mod;    cout&lt;&lt;sum&lt;&lt;endl;    return 0;&#125;</code></pre><p>View Code</p><h2 id="单"><a href="#单" class="headerlink" title="单"></a>单</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$10%$算法</p><p>暴力过$t&#x3D;&#x3D;0$</p><p>$40%$算法</p><p>gauss+暴力过前几个点</p><p>$100%$算法</p><p>先算$t&#x3D;&#x3D;0$</p><p>看$n^2$问题出现在那</p><p>重复计算多次距离，我们可以想个方法把自己的已经算过的存起来</p><p>现在假设我们有这样一棵树（1，2，3……代表点权，(为了方便)也代表编号）</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190728112246933-369928108.png"></p><p>看2 和4 的关系</p><p>子树内所有的点权值贡献$-1$,子树外所有点权贡献$+1$</p><p>事实上我们可以把我们计算过的存起来。用一个前缀和思想，把子树的和算出来,我们得到1的b就可以通过$b+ -$得到$2$的$b$</p><p>那么我们只需要一次dfs处理出所有子树权值和就可以得出来所有b</p><p>式子$b[y]&#x3D;b[x]-sum[y]+sum[1]-sum[y]$</p><p>这一点思想莫名像莫队,自从学了莫队我就觉得什么都是莫队</p><p><a href="https://www.cnblogs.com/znsbc-13/p/11247211.html">寿司</a>这个题我就用了类似莫队思想,求出来一个$ans$然后通过$ans+-$,得到另一个$ans$</p><p>(我也颓了题解)</p><p>再看t&#x3D;&#x3D;1的情况</p><p>看上去只能高斯消元,对吗?</p><p>实际上我们可以换种思路考虑</p><p>将$b[y]&#x3D;b[x]-sum[y]+sum[1]-sum[y]$移项</p><p>得到$sum[1]-2\times sum[y]&#x3D; b[y]-b[x]$</p><p>设dt数组表示两个sum之差dt[y]&#x3D;b[y]-b[x]</p><p>我们可以用一次dfs求出dt那么,我们差的就只剩下sum[1] sum[y]了</p><p>仍然没法做对吗?</p><p>sum[1]其实可以求</p><p>假设1为根</p><p>$b[1]&#x3D;\sum\limits_{i&#x3D;2}^{n} sum[i]$</p><p>感性理解+手膜</p><p>还是这个图</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190728114602670-2005455093.png"></p><p>每次都是路径长度$\times$权值,计算$2$的时候算了一遍$4 8 9$,计算4时又算了一遍$8<br>9$,路径每一个点上会被计算它到根节点之间节点个数(其实就是边数),所以最终得到的就是b[1]</p><p>同样,我们处理出来dt,再通过一次dfs求sum,然后最后dfs一次就好了</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define mem(x) memset(x,0,sizeof(x))#define ll long long#define A 1100000ll head[A],nxt[A],ver[A],a[A],b[A],sum[A],f[A],dt[A];ll tot=0,n,t,xx,yy,task;void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void re()&#123;    tot=0;    mem(head);    mem(nxt);    mem(ver);    mem(sum);    mem(dt);    mem(b);    mem(f);    mem(a);&#125;void dfs1(ll x,ll fa)&#123;    sum[x]=a[x];    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        f[y]=x;        dfs1(y,x);        sum[x]+=sum[y];    &#125;&#125;void dfs0(ll x,ll fa)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        b[y]=b[x]+sum[1]-2*sum[y];        dfs0(y,x);    &#125;&#125;void work1()&#123;    dfs1(1,0);    for(ll i=2;i&lt;=n;i++)&#123;        b[1]+=sum[i];    &#125;    dfs0(1,0);    for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;%lld &quot;,b[i]);    &#125;    printf(&quot;\n&quot;);&#125;void dfs2(ll x,ll fa)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        dfs2(y,x);//        printf(&quot;b[]=%lld %lld\n&quot;,b[y],b[x]);        dt[y]=b[y]-b[x];    &#125;&#125;void dfs3(ll x,ll fa)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        dfs3(y,x);        sum[y]=(sum[1]-dt[y])/2;    &#125;&#125;void dfs4(ll x,ll fa)&#123;    a[x]=sum[x];    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa) continue;        dfs4(y,x);        a[x]-=sum[y];    &#125;&#125;void work2()&#123;    dt[1]=0;    ll zt=0;    dfs2(1,0);    for(ll i=2;i&lt;=n;i++)        zt+=dt[i];    sum[1]=(zt+2*b[1])/(n-1);//    printf(&quot;sum1=%lld\n&quot;,sum[1]);    dfs3(1,0);    dfs4(1,0);    for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;%lld &quot;,a[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;t);    while(t--)&#123;        re();        scanf(&quot;%lld&quot;,&amp;n);        for(ll i=1;i&lt;n;i++)&#123;            scanf(&quot;%lld%lld&quot;,&amp;xx,&amp;yy);            add(xx,yy),add(yy,xx);        &#125;        scanf(&quot;%lld&quot;,&amp;task);        task++;        if(task==1)&#123;            for(ll i=1;i&lt;=n;i++)&#123;                scanf(&quot;%lld&quot;,&amp;a[i]);            &#125;            work1();        &#125;        else&#123;            for(ll i=1;i&lt;=n;i++)&#123;                scanf(&quot;%lld&quot;,&amp;b[i]);            &#125;            work2();        &#125;    &#125;&#125;</code></pre><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p>很好的一个dp？？？？</p><p>我当dp做的？？？？？</p><p>然后dp错了？？？？？？</p><p>首先对于所有的都可以列出来一个dp式子</p><p>$f[i][j][k]$表示为走了$i$步走到$j$ $k$的方案数</p><p>每一个都可以从四面八方转移过来</p><p>比如这个</p><pre><code>　　　　f[0][0+n][0+n]=1;        for(ll i=1;i&lt;=n;i++)&#123;            for(ll x=-n;x&lt;=n;x++)                for(ll y=-n;y&lt;=n;y++)                    f[i&amp;1][x+n][y+n]=0;            for(ll x=0;x&lt;=n;x++)                for(ll y=0;y&lt;=n;y++)                    for(ll j=1;j&lt;=4;j++)　　　　　　　　　　　　　　f[i&amp;1][x+n][y+n]=(f[i&amp;1][x+n][y+n]+f[(i-1)&amp;1][x+nowx[j]+n][y+nowy[j]+n])%mod;                &#125;</code></pre><p>然后就可以打表了</p><p>打表可以95？？？？？？</p><p>然后你优化一下就可以过掉&#x3D;&#x3D;2的数据</p><pre><code>　　　　else if(k==2)&#123;        f[0][0+n][0]=1;        f[0][0+n][1]=1;        for(ll i=1;i&lt;=n;i++)&#123;            for(ll w=-n/2;w&lt;=n/2;w++)                f[i&amp;1][w+n][0]=0,f[i&amp;1][w+n][1]=0;            for(ll x=-n/2;x&lt;=n/2;x++)                if(x==0)                        f[i&amp;1][x+n][0]=((f[i&amp;1][x+n][0]+f[(i-1)&amp;1][x+1+n][0]*4%mod))%mod;                else                     for(ll j=1;j&lt;=2;j++)                    f[i&amp;1][x+n][0]=((f[i&amp;1][x+n][0]+f[(i-1)&amp;1][x+now[j]+n][0]))%mod;        &#125;        printf(&quot;%lld\n&quot;,(f[n&amp;1][n+0][0])%mod);    &#125;</code></pre><p>打着打着发现降掉一维</p><pre><code>    else if(k==2)&#123;        f[0][0+n]=1;        for(ll i=1;i&lt;=n;i++)&#123;            for(ll w=-n/2;w&lt;=n/2;w++)                f[i&amp;1][w+n]=0;            for(ll x=-n/2;x&lt;=n/2;x++)                if(x==0)                    f[i&amp;1][x+n]=((f[i&amp;1][x+n]+f[(i-1)&amp;1][x+1+n]*4%mod))%mod;                else                     for(ll j=1;j&lt;=2;j++)                    f[i&amp;1][x+n]=((f[i&amp;1][x+n]+f[(i-1)&amp;1][x+now[j]+n]))%mod;        &#125;        printf(&quot;%lld\n&quot;,(f[n&amp;1][n+0])%mod);    &#125;</code></pre><p>我们欢乐的过掉了&#x3D;&#x3D;2</p><p>然后&#x3D;&#x3D;1无脑看出Catalan</p><p>然后&#x3D;&#x3D;3无脑Catalan相加其实可以打表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试8「寿司」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%958%E3%80%8C%E5%AF%BF%E5%8F%B8%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%958%E3%80%8C%E5%AF%BF%E5%8F%B8%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-25 21:45</p><p>考试时打的类似$n^2$暴力，然后炸了只有10分</p><p>后来验证我的算法伪了。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><hr><p>显然你有一种解法，假设你要在一个B点断开将R分别移向最左 最右，这样只用分别计算B点右面蓝色数量左面蓝色数量就得到了一个ans</p><p>这个题有一个很不显然的结论，假设你要将R移向两边时，序列唯一确定时，设pos&#x3D;(蓝色数量+1)&#x2F;2，在pos点将R移向左面，右面花费最小（单调性）</p><p>因为这个序列是循环的所以我们只要枚举B点断开的位置就可以$n^2$求出最小的ans值</p><p>$n^2$显然过不了1000000</p><p>现在我们思考$n^2$问题在哪，首先你每次重新计算一次ans额外花费了时间，然后每次都枚举断点又花费了时间</p><p>但实际上我们每次循环到下一个这个序列实际上变化很少，只是前面那个字母删去，后面再加一个字母</p><p>实际对ans改变也很少</p><p>类似于莫队，对于ans+ - 我们可以得到另一个ans</p><p>那么我们可以计算出他的改变</p><p>首先我们可以得出每次循环到下一B，假设我们目前断点不变，那么所有左边R对ans造成贡献都会减1，所有右边R对ans造成贡献都会加1</p><p>然后我们思考下一个断点，假设当前断点显然就是下一个B</p><p>然后我们断点移动过程中我们发现有一些R从右面移动到了左面，那么他要移动贡献也从右面blue数量改成了右面贡献，减去左面贡献加上左面的贡献即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><hr><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 2100000using namespace std;ll t,len,n,ans,pos,zo,p;ll lb[A],rb[A],lr[A],rr[A];char c[A];int main()&#123;//    freopen(&quot;mkd.txt&quot;,&quot;r&quot;,stdin);//    freopen(&quot;wa.txt&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;t);    while(t--)&#123;        ans=0;        zo=ans;        lb[0]=rb[0]=lr[0]=rr[0]=0;        scanf(&quot;%s&quot;,c+1);        len=strlen(c+1);        n=len;pos=-1;        for(ll i=1;i&lt;=len;i++)&#123;            c[n+i]=c[i];        &#125;        len*=2;        rr[len+1]=rb[len+1]=0;        for(ll i=1;i&lt;=len;i++)&#123;            lb[i]=lb[i-1],lr[i]=lr[i-1];            if(c[i]==&#39;B&#39;)lb[i]++;            else lr[i]++;        &#125;        for(ll i=len;i&gt;=1;i--)&#123;            rr[i]=rr[i+1],rb[i]=rb[i+1];            if(c[i]==&#39;B&#39;) rb[i]++;            else rr[i]++;        &#125;        pos=(lb[n]+1)/2;//        printf(&quot;pos=%lld\n&quot;,pos);        for(ll i=1;i&lt;=n;i++)&#123;            if(lb[i]==pos)&#123;                p=i;                for(ll j=n;j&gt;i;j--)&#123;                    if(c[j]==&#39;R&#39;)                    ans+=rb[j]-rb[n+1];//                    printf(&quot;rr=%lld rr[n]=%lld\n&quot;,rr[j],rr[n+1]);                &#125;                break;            &#125;            else if(c[i]==&#39;R&#39;)ans+=lb[i];        &#125;//        printf(&quot;ans=%lld\n&quot;,ans);        zo=ans;        ll head=1,tail=n;        while(head&lt;=n)&#123;            if(c[head]==&#39;B&#39;)&#123;                    ans-=lr[p]-lr[head-1];//如果当前为B将B向后移动那么左边所有R代价-1                ans+=rr[p]-rr[tail+1];//如果当前为B将B向后移动那么右边所有R代价+1                while(c[++p]!=&#39;B&#39;)&#123;//当前指针应当指向下一个B                    ans+=lb[p]-lb[head];//如果R由左变为了右，那么代价从左边变成右边                    ans-=rb[p]-rb[tail+2];                &#125;            &#125;            head++,tail++;            zo=min(zo,ans);        &#125;        cout&lt;&lt;zo&lt;&lt;endl;    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试8「匹配·回家」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%958%E3%80%8C%E5%8C%B9%E9%85%8D%C2%B7%E5%9B%9E%E5%AE%B6%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%958%E3%80%8C%E5%8C%B9%E9%85%8D%C2%B7%E5%9B%9E%E5%AE%B6%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-26 08:48</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>哈希能A</p><p>水到爆炸</p><h3 id="回家"><a href="#回家" class="headerlink" title="回家"></a>回家</h3><p>事实上我做过一个原题，甚至比这个回家难的多，而且那个题多组询问必经点</p><p>然后我做一组询问就打炸了</p><p>大约就是删了很多东西，然后自己想的太简单了</p><p>直接统计了割点，懒得打lca和树上差分，懒得打dfs，偷懒让我付出很大代价</p><p>最后只有10，</p><p>打代码一定不能偷懒，一定不能偷懒</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 810000ll dfn[A],low[A],ver[A],nxt[A],head[A],s[A],fa[A],belong[A],kx[A];ll Head[A],Nxt[A],Ver[A],To[A],vst[A];ll tot=0,tot2=0,num=0,n,m,t,root;vector&lt;ll&gt; dcc[A],ans;bool cut[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void Add(ll x,ll y)&#123;    Nxt[++tot2]=Head[x],Head[x]=tot2,Ver[tot2]=y;&#125;inline ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))&#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c-&#39;0&#39;);        c=getchar();    &#125;    return f*x;&#125;void tarjan(ll x)&#123;    ll flag=0;    dfn[x]=low[x]=++tot;    s[++s[0]]=x;    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(!dfn[y])        &#123;            tarjan(y);            low[x]=min(low[x],low[y]);            if(low[y]&gt;=dfn[x])            &#123;                flag++;                num++;                if(flag&gt;1||x!=root)cut[x]=1;                while(s[0])                &#123;                    ll p=s[s[0]--];                    dcc[num].push_back(p);                    if(p==y)break;                &#125;                dcc[num].push_back(x);            &#125;        &#125;        else low[x]=min(low[x],dfn[y]);    &#125;&#125;void dfs(ll x)&#123;    if(x==belong[n])return ;    vst[x]=1;    for(ll i=Head[x];i;i=Nxt[i])    &#123;        ll y=Ver[i];        if(vst[y])continue;        fa[y]=x;        dfs(y);    &#125;    return ;&#125;void re()&#123;    num=0,tot=0;ans.clear();tot2=0;    for(ll i=0;i&lt;=800000;i++)            dcc[i].clear();    memset(nxt,0,sizeof(nxt));    memset(Head,0,sizeof(Head));    memset(Nxt,0,sizeof(Nxt));    memset(fa,0,sizeof(fa));    memset(vst,0,sizeof(vst));    memset(head,0,sizeof(head));    memset(ver,0,sizeof(ver));    memset(dfn,0,sizeof(dfn));    memset(low,0,sizeof(low));    memset(cut,0,sizeof(cut));    memset(kx,0,sizeof(kx));&#125;int main()&#123;    t=read();    while(t--)&#123;        re();        n=read(),m=read();        for(ll i=1;i&lt;=m;i++)&#123;            ll x=read(),y=read();            add(x,y);            add(y,x);        &#125;        for(ll i=1;i&lt;=n;i++)            if(!dfn[i]) root=i,tarjan(i);        ll nu=num;        for(ll i=1;i&lt;=n;i++)            if(cut[i])belong[i]=++nu,kx[nu]=i;        for(ll i=1;i&lt;=num;i++)            for(ll j=0;j&lt;dcc[i].size();j++)&#123;                ll x=dcc[i][j];                if(cut[x]) Add(belong[x],i),Add(i,belong[x]);                else belong[x]=i;            &#125;/*        for(ll i=1;i&lt;=n;i++)&#123;            cout&lt;&lt;&quot;belong=&quot;&lt;&lt;belong[i]&lt;&lt;endl;        &#125;*/        dfs(belong[1]);        ll x=fa[belong[n]];        while(x!=belong[1])&#123;            if(x==0) break;            if(x&gt;num) ans.push_back(kx[x]);            x=fa[x];        &#125;        printf(&quot;%lld\n&quot;,1ll*ans.size());        sort(ans.begin(),ans.end());        for(ll i=0;i&lt;ans.size();i++)            printf(&quot;%lld &quot;,ans[i]);        cout&lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试7「方程的解·visit」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%957%E3%80%8C%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3%C2%B7visit%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%957%E3%80%8C%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3%C2%B7visit%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-22 19:23</p><h2 id="visit"><a href="#visit" class="headerlink" title="visit"></a>visit</h2><p>由于一些不可预知的错误导致我一直WA 错误最后说</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>假设终点在出发点右上方（这样假设只是为了方便）</p><p>假设向左走了a步，向右下了b布，那么相应的我们要向右走m+a，向上n+b步</p><p>总步数t 所以由多重集方案数可得</p><p>$ \frac{t !}{a !\times b! \times (n+a)! \times (m+b)!}$</p><p>这种方法要特殊处理</p><h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>假设向上下一共走了i步</p><p>如果i超出了范围我们要往回走(i-n)&#x2F;2步（自己在纸上画一下）</p><p>然后如果i-n除不开2那么这种情况是无解的</p><p>左右同理</p><p>得到式子</p><p>$ans&#x3D;\sum\limits_{i&#x3D;n 2|i-n}^{t-m} C_{t}^{i}\times C_{i}^{\frac{i-n}{2}<br>}\times C_{t-i}^{\frac{t-i-m}{2}}$</p><p>因为模数不一定为质数，但是几个质数乘积，所以我们要用先求出来分别模这几个质数结果，然后CRT合并</p><h3 id="我犯的错误"><a href="#我犯的错误" class="headerlink" title="我犯的错误"></a>我犯的错误</h3><p>我一开始看了吴迪的式子（$ \frac{t !}{a !\times b! \times (n+a)! \times<br>(m+b)!}$），他的式子会发生另外一些不可预知的错误，模小数时他的式子会爆炸（$n!$中$n$比模数大时会发生另外一些错误）</p><p>然后我一开始没发现这个错误，发现他的式子跟我的差不多就开始打了，然后我就挂了。</p><p>然后我又自己推了一个式子用线性求逆元发现还是一直WA</p><p>最后wwb调了很长时间还是WA 最后进行了一番大改终于A了。</p><p>我用老套路控制变量（用A的代码一段一段替换WA的代码）发现线性求逆元爆炸了。</p><p>这里线性求逆元并不是我写错了，或者推错了</p><pre><code>        jie[0]=1;        ni[0]=1;        for(ll j=1;j&lt;=t;j++)            jie[j]=jie[j-1]*j%w[i];        ni[t]=meng(jie[t],w[i]-2,i);        for(ll j=t-1;j&gt;=1;j--)            ni[j]=ni[j+1]*(j+1)%w[i];</code></pre><p>观察这段代码，首先如果jie里的j比w大那么他的阶乘取完模之后都为0，（前面有不是0的阶乘）</p><p>而ni 从t开始算的话如果最后一位为0那么这样递推算出来所有的逆元都为0</p><p>然而ni&lt;w的一部分不是0 所以就错了</p><p>警醒</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 2000000#define py printf(&quot;f**k\n&quot;)ll a[A],b[A],k,p,n,m,t,num=0;ll w[A],q[A],v[A],jie[A],ni[A];ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)&#123;        x=1;        y=0;        return a;    &#125;    ll gcd=exgcd(b,a%b,x,y);    ll t=x;    x=y;    y=t-a/b*y;    return gcd;&#125;void getprime(ll x)&#123;    for(ll i=2;i&lt;=sqrt(x);i++)    &#123;        if(x%i==0)        &#123;            while(x%i==0)            &#123;                x=x/i;            &#125;            w[++w[0]]=i;        &#125;    &#125;    if(x!=1) w[++w[0]]=x;    return ;&#125;ll meng(ll x,ll k,ll cix)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%w[cix])        if(k&amp;1)            ans=ans*x%w[cix];    return ans;&#125;ll china()&#123;    ll x,y,a=0,m,n=1;    for(ll i=1;i&lt;=w[0];i++)        n*=w[i];    for(ll i=1;i&lt;=w[0];i++)&#123;        m=n/w[i];        exgcd(w[i],m,x,y);        y%=w[i];        a=(a+y*m*b[i])%n;    &#125;    return (a+n)%n;&#125;ll jic(ll n,ll m,ll cix)&#123;    if(m&gt;n) return 0;    if(m==0) return 1;    return jie[n]%w[cix]*meng(jie[m]*jie[n-m]%w[cix],w[cix]-2,cix)%w[cix];&#125;ll lucas(ll n,ll m,ll cix)&#123;    if(m&gt;n)return 0;    if(n==0)return 1;    return jic(n%w[cix],m%w[cix],cix)*lucas(n/w[cix],m/w[cix],cix)%w[cix];&#125;using namespace std;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;t,&amp;p);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    getprime(p);    n=abs(n),m=abs(m);    for(ll i=1;i&lt;=w[0];i++)&#123;        jie[0]=1;        ni[0]=1;        for(ll j=1;j&lt;=t;j++)            jie[j]=jie[j-1]*j%w[i];        ni[t]=meng(jie[t],w[i]-2,i);        for(ll j=t-1;j&gt;=1;j--)            ni[j]=ni[j+1]*(j+1)%w[i];        for(ll j=n;j&lt;=t-m;j++)&#123;            if((j-n)%2) continue;            if((t-j-m)%2) continue;            ll t1=lucas(t,j,i),t2=lucas(j,(j-n)/2,i),t3=lucas(t-j,(t-j-m)/2,i);            b[i]=(b[i]+t1*t2%w[i]*t3)%w[i];        &#125;    &#125;    cout&lt;&lt;china()&lt;&lt;endl;    &#125;</code></pre><h2 id="方程的解"><a href="#方程的解" class="headerlink" title="方程的解"></a>方程的解</h2><p>各种傻逼特判，判错一个就40</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>思路有两种</p><h5 id="一，"><a href="#一，" class="headerlink" title="一，"></a>一，</h5><p>首先求出来左右边界然后拿右边界减左边界，非常简单，按照解方程的方法求即可</p><p>代码（我没打出来一直40分，这里是nc的代码）</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;ll T,a,b,c,x,y;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)    &#123;        x=1;y=0;        return a;    &#125;    ll d=exgcd(b,a%b,x,y);    ll tmp=x;    x=y;    y=tmp-a/b*y;    return d;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;T);    while(T--)    &#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);        ll d=exgcd(a,b,x,y);        ll l=floor(1.0*c/b*(-x)),r=ceil(1.0*c/a*y);        ll k=r-l-1;        if(a==0&amp;&amp;b==0)        &#123;            if(c==0)            &#123;                puts(&quot;ZenMeZheMeDuo&quot;);                continue;            &#125;            else            &#123;                puts(&quot;0&quot;);                continue;            &#125;        &#125;        if((c%d))        &#123;            puts(&quot;0&quot;);            continue;        &#125;        if(1LL*a*b&lt;0)        &#123;            puts(&quot;ZenMeZheMeDuo&quot;);            continue;        &#125;        if(a==0)        &#123;            if(1LL*b*c&gt;0) puts(&quot;ZenMeZheMeDuo&quot;);            else puts(&quot;0&quot;);            continue;        &#125;        if(b==0)        &#123;            if(1LL*a*c&gt;0) puts(&quot;ZenMeZheMeDuo&quot;);            else puts(&quot;0&quot;);            continue;        &#125;        if(k&lt;0)        &#123;            puts(&quot;0&quot;);            continue;        &#125;        if(k&gt;65535) puts(&quot;ZenMeZheMeDuo&quot;);        else printf(&quot;%lld\n&quot;,k);    &#125;    return 0;&#125;</code></pre><h5 id="二，"><a href="#二，" class="headerlink" title="二，"></a>二，</h5><p>求出来ymax 再求出来ymin 再&#x2F;a</p><p>非常简单的思路（虽然我觉得第一个更简单）</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 100000ll a,b,x,y,c,t;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)    &#123;        x=1;y=0;        return a;    &#125;    ll c=exgcd(b,a%b,x,y);    ll z=x;    x=y;y=z-y*(a/b);//    printf(&quot;x=%lld y=%lld\n&quot;,x,y);    return c; &#125;int main()&#123;//    freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;t);    while(t--)    &#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);//        printf(&quot;a=%lld b=%lld\n&quot;,a,b);        x=0,y=0;        if(a&lt;0&amp;&amp;b&lt;0) a=-a,b=-b,c=-c;                if(a==0)        &#123;            if((b&lt;=0&amp;&amp;c&gt;=0)||(b&gt;=0&amp;&amp;c&lt;=0))            &#123;                printf(&quot;0\n&quot;);                continue;            &#125;            else if(c%b)&#123;                printf(&quot;0\n&quot;);                continue;            &#125;            else&#123;printf(&quot;ZenMeZheMeDuo\n&quot;);continue;&#125;;        &#125;        if(b==0)        &#123;            if((a&lt;=0&amp;&amp;c&gt;=0)||(a&gt;=0&amp;&amp;c&lt;=0))            &#123;                printf(&quot;0\n&quot;);                continue;            &#125;            else if(c%a)&#123;                printf(&quot;0\n&quot;);                continue;            &#125;            else &#123;printf(&quot;ZenMeZheMeDuo\n&quot;);continue;&#125;;        &#125;        ll g=exgcd(a,b,x,y),ans=0;        x*=c/g,y*=c/g;//        printf(&quot;%lld %lld a=%lld b=%lld c=%lld\n&quot;,x,y,a,b,c);        if(c%g)&#123;printf(&quot;0\n&quot;);continue;&#125;        if(a*b&lt;0)        &#123;printf(&quot;ZenMeZheMeDuo\n&quot;);continue;&#125;        a/=g,b/=g,c/=g;x%=b;        while(x&lt;=0) x+=b;        y=(c-a*x)/b;        ll y2=y%a;        while(y2&lt;=0) y2+=a;        ans=(y-y2)/a+1;        if(y2&gt;y) ans=0;//        printf(&quot;y=%lld y2=%lld x=%lld c=%lld\n&quot;,y,y2,x,c);        if(ans&lt;=65535)            printf(&quot;%lld\n&quot;,ans);        else            printf(&quot;ZenMeZheMeDuo\n&quot;);    &#125;&#125;</code></pre><p>题目思路还是挺简单的就是一些恶心的特判</p><h3 id="特判"><a href="#特判" class="headerlink" title="特判"></a>特判</h3><p>首先$c \mod gcd！&#x3D;0$时无解</p><p>然后$a，b$异号时无穷多解</p><p>$a$为$0$，$b$为$0$，$c$为$0$时无穷多解</p><p>$a$为$0$ $b$为$0$ $c$不为$0$ 无解</p><p>$ymax&lt;ymin$无解</p><p>$a&#x3D;&#x3D;0$ $ b,c$异号无解</p><p>$a&#x3D;&#x3D;0$ $ b,c$同号无穷多解</p><p>$b&#x3D;&#x3D;0$ $ a,c$异号无解</p><p>$b&#x3D;&#x3D;0$ $ a,c$同号无穷多解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试6「那一天我们许下约定（背包dp）·那一天她离我而去」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%956%E3%80%8C%E9%82%A3%E4%B8%80%E5%A4%A9%E6%88%91%E4%BB%AC%E8%AE%B8%E4%B8%8B%E7%BA%A6%E5%AE%9A%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89%C2%B7%E9%82%A3%E4%B8%80%E5%A4%A9%E5%A5%B9%E7%A6%BB%E6%88%91%E8%80%8C%E5%8E%BB%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%956%E3%80%8C%E9%82%A3%E4%B8%80%E5%A4%A9%E6%88%91%E4%BB%AC%E8%AE%B8%E4%B8%8B%E7%BA%A6%E5%AE%9A%EF%BC%88%E8%83%8C%E5%8C%85dp%EF%BC%89%C2%B7%E9%82%A3%E4%B8%80%E5%A4%A9%E5%A5%B9%E7%A6%BB%E6%88%91%E8%80%8C%E5%8E%BB%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-20 19:05</p><h2 id="那一天我们许下约定"><a href="#那一天我们许下约定" class="headerlink" title="那一天我们许下约定"></a>那一天我们许下约定</h2><p>内部题，题干不粘了。</p><p>$30分算法$</p><hr><p>首先看数据范围，可以写出来一个普通dp</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll int#define A 2100#define mod 998244353using namespace std;ll f[1501][A+A+A],n,d,m;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;d,&amp;m);    while(n!=0&amp;&amp;d!=0&amp;&amp;m!=0)&#123;        memset(f,0,sizeof(f));        f[0][0]=1;        for(ll i=1;i&lt;=d;i++)        f[0][i]=1;        for(ll i=1;i&lt;=n;i++)            for(ll k=1;k&lt;=d;k++)            &#123;                for(ll j=min(m-1,i);j&gt;=0;j--)                if(i-j&gt;=0)    f[i][k]=(f[i][k]+f[i-j][k-1])%mod;            &#125;        printf(&quot;%d\n&quot;,f[n][d]);        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;d,&amp;m);    &#125;&#125;</code></pre><p>View Code</p><p>d最大为$1e^12$所以你这个dp会完美T掉或者M掉</p><p>$100分算法$</p><hr><p>观察，发现n的范围非常小，m的范围也特别小。</p><p>所以我们利用这条性质，先片面的忽视掉这一天不给她饼干的情况，我们设定$f$定义为每天都给她饼干的情况。</p><p>设$f[i][j]$中i表示为前$i$天目前给了$j$个饼干的情况</p><p>然后可以推出来方程式</p><p>可以给她1～m-1个饼干</p><p>$f[i][j]&#x3D;\sum_\limits {k&#x3D;(j-M-1)}^{k&lt;&#x3D;j-1} f[i-1][k]$</p><p>然后直接转移，复杂度仍然难以接受，观察dp式子发现它是由一个字段转移过来的，我们要用前缀和维护优化一下。</p><p>仍然AC不了？</p><p>可能你会乘爆long long</p><p>注意多取模</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define  A 2010#define mod 998244353using namespace std;ll f[A][A],n,m,q,d;ll sum[A];ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=x*ans%mod;    return ans%mod;&#125;int main()&#123;        while(1)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;d,&amp;m);        ll ans=0;        if(n==0&amp;&amp;d==0&amp;&amp;m==0)&#123;            return 0;        &#125;        memset(f[1],0,sizeof(f[1]));        f[0][0]=1;        for(ll i=1;i&lt;=min(n,m-1);i++)            f[1][i]=1;        for(ll i=2;i&lt;=n;i++)&#123;            for(ll j=0;j&lt;=n;j++)                sum[j]=(sum[j-1]%mod+f[i-1][j]%mod)%mod;            for(ll j=1;j&lt;=n;j++)                f[i][j]=(sum[j-1]%mod-sum[max(j-m,0ll)]%mod+mod)%mod;        &#125;        ll sd=d%mod;        for(ll i=1;i&lt;=min(n,d);i++)        &#123;                if(i==1)                    ans=(ans+sd*f[i][n]%mod)%mod,ans%=mod;                else&#123;                    sd=(sd%mod*meng(i,mod-2)%mod*((d-i+1)%mod))%mod;                    ans%=mod;                    ans=(ans+f[i][n]%mod*sd%mod)%mod;                &#125;//                if(sd!=0)printf(&quot;sd=%lld ans=%lld f*s=%lld\n&quot;,sd,ans,f[i][n]*sd%mod);        &#125;         cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl;    &#125;&#125;</code></pre><p>View Code</p><h2 id="那一天她离我而去"><a href="#那一天她离我而去" class="headerlink" title="那一天她离我而去"></a>那一天她离我而去</h2><p>听说暴力可以AC所以我打的A*？？？</p><p>看不懂题解，如果给一个菊花图题解不就爆炸了吗？$2^{10000}$我觉得会炸</p><p>所以这个题瞎搞就行了？？？</p><p>然后我就瞎搞了个A*</p><p>跑的还特别快。大约600毫。</p><p>思路大约就是把每个直接与1相连的点拿出来，然后对于每个点跑A*，因为已经提前处理出来各种dis所以比较快。</p><p>然后没了</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 100010#define in inline ll n,m;bool flag[A],ok=0;ll head[A],nxt[A],ver[A],tot1=0,t;ll head2[A],nxt2[A],ver2[A],cnt=0,tot2=0;ll value[A],value2[A],e,d[A],len=0;struct qnode&#123;    ll v,w,sz,id;    friend bool operator &lt; (qnode x,qnode y)    &#123;        return x.w+d[x.v]&gt;y.w+d[y.v];    &#125;&#125;;void re()&#123;    tot1=1,tot2=1;    memset(flag,0,sizeof(flag));    memset(head,0,sizeof(head));memset(head2,0,sizeof(head2));    memset(ver,0,sizeof(ver));memset(ver2,0,sizeof(ver2));    memset(nxt,0,sizeof(nxt));memset(nxt2,0,sizeof(nxt2));    memset(value,0,sizeof(value));memset(value2,0,sizeof(value2));&#125;in void add1(ll u,ll v,ll w)&#123;    ver[++tot1]=v;    nxt[tot1]=head[u];    value[tot1]=w;    head[u]=tot1;&#125;in void add2(ll x,ll y,ll w)&#123;    ver2[++tot2]=y;    nxt2[tot2]=head2[x];    value2[tot2]=w;    head2[x]=tot2;&#125;in void spfa(ll root)&#123;    memset(flag,0,sizeof(flag));    memset(d,0x3f,sizeof(d));    queue &lt;ll&gt;q;    q.push(root);    flag[root]=1;    d[root]=0;    while(!q.empty())    &#123;        ll x=q.front();        q.pop();        flag[x]=0;        for(ll i=head[x];i;i=nxt[i])        &#123;            ll y=ver[i],w=value[i];            if(d[y]&gt;d[x]+w)            &#123;                d[y]=d[x]+w;                if(!flag[y])                &#123;                    flag[y]=1;                    q.push(y);                &#125;            &#125;        &#125;    &#125;    return ;&#125;in ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))    &#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))    &#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;        c=getchar();    &#125;    return x*f;&#125;in ll astar()&#123;//    从每个直接相连的点开始跑A*    ll ans=0x7ffffff;    for(ll i=head[1];i;i=nxt[i])    &#123;        ll y=ver[i];        priority_queue&lt;qnode&gt; h;        memset(flag,0,sizeof(flag));            qnode s;        s.v=y,s.w=value[i],s.id=0;        h.push(s);        bool ok=0;        while(!h.empty())        &#123;            qnode no=h.top();//            printf(&quot;当前 %d sumvalue=%d\n&quot;,no.v,no.w);            if(no.v==1)&#123;                ans=min(no.w,ans);                break;            &#125;            h.pop();            flag[no.v]=1;            for(ll i=head2[no.v];i;i=nxt2[i])&#123;                ll tu=ver2[i];//                printf(&quot;tu=%d\n&quot;,tu);                if(tu==1&amp;&amp;!ok)&#123;                    ok=1;//                    printf(&quot;tu=%d \n&quot;,tu);                    continue;                &#125;                if(flag[tu])                &#123;/*printf(&quot;掠过\n&quot;);*/continue;&#125;//                printf(&quot;没有掠过\n&quot;);                qnode t;                t.v=tu;t.w=value[i]+no.w;t.sz=no.sz+1;                h.push(t);//                printf(&quot;推入 %d-&gt;%d z=%d\n&quot;,no.v,tu,value2[i]+no.w);            &#125;        &#125;    &#125;    return ans;&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    &#123;        re();        ll xx,yy;ll zz;        n=read(),m=read();        for(ll i=1;i&lt;=m;i++)        &#123;            xx=read(),yy=read();zz=read();            add1(yy,xx,zz);            add1(xx,yy,zz);            add2(xx,yy,zz);            add2(yy,xx,zz);        &#125;        spfa(1);/*        for(ll i=2;i&lt;=tot1;i++)&#123;            printf(&quot;%d\n&quot;,ver[i]);        &#125;        for(ll i=1;i&lt;=n;i++)&#123;            printf(&quot;%d\n&quot;,d[i]);        &#125;*/        ok=1;        ll ans=astar();        if(ans&gt;=1000000) cout&lt;&lt;-1&lt;&lt;endl;        else        printf(&quot;%d\n&quot;,ans);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试5「星际旅行·砍树·超级树」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%955%E3%80%8C%E6%98%9F%E9%99%85%E6%97%85%E8%A1%8C%C2%B7%E7%A0%8D%E6%A0%91%C2%B7%E8%B6%85%E7%BA%A7%E6%A0%91%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%955%E3%80%8C%E6%98%9F%E9%99%85%E6%97%85%E8%A1%8C%C2%B7%E7%A0%8D%E6%A0%91%C2%B7%E8%B6%85%E7%BA%A7%E6%A0%91%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-18 20:55</p><h2 id="星际旅行"><a href="#星际旅行" class="headerlink" title="星际旅行"></a>星际旅行</h2><p>0分</p><p>瞬间爆炸。</p><p>考试的时候觉得这个题怎么这么难，</p><p>打个dp，可以被儿子贡献，可以被父亲贡献，还有自环，叶子节点连边可以贡献，非叶子也可以贡献，自环可以跑一回，自环可以跑两回，</p><p>关键是同一子树会贡献，不同子树也会贡献。</p><p>这还不是欧拉图欧拉路问题，awsl</p><p>然后我就放弃了这个题</p><p>考完试看题解，tm一个大水题</p><p>虽然好像不算水，</p><p>思考两个点之间因为连接的是无向边，所以所有点入度出度都为2。</p><p>先不考虑自环</p><p>如果把两个点之间无向边拆成两个有向边，那么问题就变成去掉两个边使原图存在欧拉路。</p><p>于是乎，问题就变得很简单了</p><p>如果有自环</p><p>可以去掉两个自环，或者去掉一个自环和一个边</p><h2 id="砍树"><a href="#砍树" class="headerlink" title="砍树"></a>砍树</h2><p>做砍树时问大佬说，“这是一个数论分块”模板题</p><p>我：？？？</p><p>原来只有我没学过数论分块吗？</p><p><a href="https://www.cnblogs.com/0xfffe/p/9648943.html">https://www.cnblogs.com/0xfffe/p/9648943.html</a></p><p>略微理解了理解，写的非常清楚</p><p>你说这是向下取整，不是向上取整，砍树要向上取整，那篇博客不适用于砍树？</p><p>确实不适用</p><p>我们要分块的是等式右面的$\sum_{i}^{n} a[i] +k$除以d</p><p>因为C是固定的，所以这是一个分段函数，我们要处理的是不同的右面的值最后再跟左面对应</p><p>我们然后f存下这一段具体的值，</p><p>r存下具体右端点</p><p>然后就完了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 11000000ll l=1,r,n,m,a[A],dl[A],R[A],f[A],zz=0,num=0,ans=0,sum=0;void precl()&#123;    while(1)&#123;        if(!(sum/l)) break;        r=sum/(sum/l);        f[++num]=sum/r;        R[num]=r;        l=r+1;    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    sum=m;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);        sum+=a[i];    &#125;    precl();    for(ll j=1;j&lt;=num;j++)    &#123;        ll t=0;        for(ll i=1;i&lt;=n;i++)&#123;            t+=ceil((double)a[i]/(double)R[j]);        &#125;//        printf(&quot;f=%lld R=%lld\n&quot;,f[j],R[j]);        if(t&lt;=f[j]) ans=R[j];    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><p>以下是我完全错误的解释  </p><p>设$k\times i-p&#x3D;N$ 向上取整设</p><p>$\large{\lceil \frac N{i+d} \rceil}&#x3D;k$</p><p>于是$k\times (i+d)-p2&#x3D;N$</p><p>同样得出p2&#x3D;p+kd</p><p>就是照猫画虎的一个过程</p><p>底下我不具体推了，</p><p>$\large \left \lceil \frac N{\left \lfloor \frac Ni \right \rfloor } \right<br>\rceil$</p><p>所以对砍树这道题来说，这确实是个模板题，分析发现这是一个分段函数，维护每一段大小相同，维护l，r下一个l&#x3D;r+1</p><p>具体来说</p><p>$\large \left \lceil \frac {a[i]}{d} \right \rceil$不是为我们具体分块的值</p><p>$\large \lfloor \frac Ni \rfloor$才是</p><p>然后等式右面是$\sum_{i}^{n} a[i] +k$再除以d</p><p>这个N就是$\sum_{i}^{n} a[i] +k$</p><p>那么这个题就迎刃而解了。</p><h2 id="超级树"><a href="#超级树" class="headerlink" title="超级树"></a>超级树</h2><p>等我AC了可怜与超市</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试4「礼物·通讯·奇袭」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%954%E3%80%8C%E7%A4%BC%E7%89%A9%C2%B7%E9%80%9A%E8%AE%AF%C2%B7%E5%A5%87%E8%A2%AD%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%954%E3%80%8C%E7%A4%BC%E7%89%A9%C2%B7%E9%80%9A%E8%AE%AF%C2%B7%E5%A5%87%E8%A2%AD%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-17 11:39</p><h2 id="礼物、"><a href="#礼物、" class="headerlink" title="礼物、"></a>礼物、</h2><p>首先见到期望一定要想dp，看到n的范围无脑想状压，</p><p>然后我就只想到这了。</p><p>dp方程式还是比较好想的，但是我依然想不出来</p><p>略经思考 颓题解</p><hr><p>依然不会,随便写了个式子</p><p>i状态中不含j</p><p>$f[i]&#x3D;\sum_\limits{j&#x3D;1}^{j&lt;&#x3D;n} {f[j]\times p[j] }(买到之前没有的) $$+(1-p[i])\times<br>{f[i]}(由自己转移过来(买到已经买过的)) $</p><p>$+1(什么也不买)$</p><p>显然不是i吖</p><p>然后</p><p>$f[i]&#x3D;\sum_\limits{j&#x3D;1}^{j&lt;&#x3D;n} {f[j]\times p[j] }(买到之前没有的) $ $+$<br>$(1-$$\sum_\limits{j&#x3D;1}^{j&lt;&#x3D;n}p[j] )$ $\times f[i]+1(店员什么也没拿)$</p><p>观察，等式右面也有fi，如果我们楞做就是高斯消元了</p><p>那么移项得</p><p>$f[i]&#x3D;$ $\frac{\sum_\limits{j&#x3D;1}^{j&lt;&#x3D;n}f[j]\times p[j]+1}<br>{\sum_\limits{j&#x3D;1}^{j&lt;&#x3D;n} p[j]}$</p><p>转移就完了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1&lt;&lt;24double f[A],p[A];ll n,m,sum=0,Smily;void turn(ll x,ll n)&#123;     ll t=x,num=0,xx[100];     while(x) xx[num++]=x%2,x/=2;         for(ll i=num;i&lt;n;i++)printf(&quot;0&quot;);     for(ll i=num-1;i&gt;=0;i--)printf(&quot;%lld&quot;,xx[i]);     puts(&quot;&quot;);&#125;using namespace std;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lf%lld&quot;,&amp;p[i],&amp;Smily);        sum+=Smily;    &#125;    printf(&quot;%lld\n&quot;,sum);    for(ll i=(1&lt;&lt;n)-2;i&gt;=0;i--)&#123;        double now=0;        for(ll j=1;j&lt;=n;j++)&#123;            if(!((1&lt;&lt;(j-1))&amp;i))                f[i]+=f[i|(1&lt;&lt;(j-1))]*p[j],now+=p[j];        &#125;//        printf(&quot;f=%lf now=%lf\n&quot;,f[i],now);        f[i]++;        f[i]/=now;    &#125;//    for(ll i=1;i&lt;=(1&lt;&lt;n)-1;i++)//    &#123;//        printf(&quot;%lf\n&quot;,f[i]);//    &#125;    printf(&quot;%.3lf\n&quot;,f[0]);&#125;</code></pre><p>View Code</p><h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><p>（有向图）有环不花费，没环有花费，求使所有点连通最小花费。（保证从0节点可以到达任何节点&amp;&amp;图是连通的）</p><p>一眼秒错解！！！！！！！</p><p>打了个缩点+kuskal，然后自己以为能AC然后完美得到10分</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>正解，贪心+缩点。</p><p>因为保证0可以到任何节点</p><p>每次取出当前点入边最小值，得到图依然保持连通，所以贪心正确。</p><p>代码懒得放</p><h2 id="奇袭"><a href="#奇袭" class="headerlink" title="奇袭"></a>奇袭</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><a href="https://blog.csdn.net/sadnohappy/article/details/52199051">https://blog.csdn.net/sadnohappy/article/details/52199051</a></p><p><a href="https://www.cnblogs.com/12mango/p/7465667.html">https://www.cnblogs.com/12mango/p/7465667.html</a></p><p>耐心看完这两篇博客相信你已经大概理解了。</p><p>以下是我自己的一些理解，</p><p>首先</p><p>$n^3$算法</p><hr><p>无脑维护前缀和</p><p>MLE+TLE</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 10100using namespace std;ll a[A][A];bool b[A][A];ll n,m,ans=0;const int L=1&lt;&lt;20|1;char buffer[L],*S,*T;#define getchar() ((S==T&amp;&amp;(T=(S=buffer)+fread(buffer,1,L,stdin),S==T))?EOF:*S++)inline int Read()&#123;    register int ret;    register char r;    while(r=getchar(),r&lt;&#39;0&#39;||r&gt;&#39;9&#39;);ret=r-48;    while(r=getchar(),r&gt;=&#39;0&#39;&amp;&amp;r&lt;=&#39;9&#39;)ret=ret*10+r-48;    return ret;&#125;void dfs(ll k)&#123;    if(k==n) return ;    for(ll i=1;i&lt;=n-k+1;i++)        for(ll j=1;j&lt;=n-k+1;j++)&#123;            if(a[i+k-1][j+k-1]+a[i-1][j-1]-a[i-1][j+k-1]-a[i+k-1][j-1]==k)                ans++/*,printf(&quot;k=%lld i=%lld j=%lld a[%lld][%lld]=%lld a[%lld][%lld]=%lld a[%lld][%lld]=%lld a[%lld][%lld]=%lld\n&quot;,k,i,j,i+k-1,j+k-1,a[i+k-1][j+k-1],i-1,j-1,a[i-1][j-1],i-1,j+k-1,a[i-1][j+k-1],i+k-1,j-1,a[i+k-1][j-1])*/;        &#125;    dfs(k+1);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        &#123;            ll xx=Read(),yy=Read();            b[xx][yy]++;        &#125;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=n;j++)        &#123;a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j];&#125;//    cout&lt;&lt;a[2][4]&lt;&lt;endl;    dfs(2);    cout&lt;&lt;ans+n+1&lt;&lt;endl;&#125;</code></pre><p>View Code</p><p>$n^2$</p><hr><p>略微思考，发现可以把它转换为一维的，行列不重复，所以可以用一个a数组存下来值 a[i]就下标代表第一行，具体存的数就代表第j列</p><p>那么我们发现从a[i]-a[j]中a中最大值减a中最小如果为j-i那么就符合题目中所说的子矩阵</p><p>维护ST表或单调队列维护，严格$n^2$</p><p>约55–64分，看你常数大小</p><p>减减枝91</p><p>$n\times log n$</p><hr><p>一个非常玄学做法，</p><p>建议结合代码来看，虽然我知道你不想看代码</p><p>玄学二分加桶</p><p>这还是我第一次遇到这样的题</p><p>事实上该做法是$n^2$的一个优化，思路和它类似a[i]-a[j]中a中最大值减a中最小如果为j-i那么就符合题目中所说的子矩阵。</p><p>那么我们二分一个区间时有如下情况</p><p>1，当前枚举区间最大值最小值都在mid左面</p><p>2，当前枚举区间最大值最小值都在mid右面</p><p>3，最小值在左面，最大值在右面</p><p>4，最大值在右面，最小值在左面</p><p>对于1，我们要做的是扫一遍mid以左就完了，我们max-min+i就是当前区间，要判断j是否&gt;mid<br>因为即使符合&lt;&#x3D;mid的情况也会在二分时解决（因为全部在左区间），我们找的最大值最小值都在mid左面，并不一定全在左面，有部分在右面</p><p>对于2，做法同1</p><p>对于3，我们首先先找到了mid以左最小，以及最大，设mid以左最小minl，最大maxl</p><p>我们定义两个指针一个minn指针，一个maxx指针，当前指针都指向mid<br>因为maxx&lt;&#x3D;maxl我们要满足3最大值在右面只能往右搜。我们需要找到minn&gt;minl最大位置（因为minn往右搜只会越来越小满足单调性），maxx&gt;ml最小位置（maxx越搜只会越来越大满足单调性）。</p><p>找到指针指向位置我们可以断定mid–maxx之间所有方案都不符合3，mid–minn之间可能符合3。</p><p>宗上那么maxx–minn之间值可能符合3;</p><p>对于”“思路和它类似a[i]-a[j]中a中最大值减a中最小如果为j-i那么就符合题目中所说的子矩阵”“ 这句话 移项</p><p>maxx-r&#x3D;&#x3D;minn-l 我们在桶里存maxx-r 然后找到minn-l对应就完了。</p><p>对于4，做法同3</p><p>以下是本人丑陋的代码</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1100000using namespace std;ll tong[A],lmax[A],lmin[A],rmax[A],rmin[A];ll a[A];ll n;ll work(ll l,ll r,ll mid)&#123;    ll w=0;    lmax[mid]=a[mid];lmin[mid]=a[mid];    rmax[mid+1]=a[mid+1];rmin[mid+1]=a[mid+1];    for(ll i=mid-1;i&gt;=l;i--)&#123;        lmax[i]=max(lmax[i+1],a[i]);        lmin[i]=min(lmin[i+1],a[i]);    &#125;    for(ll i=mid+2;i&lt;=r;i++)&#123;        rmax[i]=max(rmax[i-1],a[i]);        rmin[i]=min(rmin[i-1],a[i]);    &#125;    for(ll i=l;i&lt;=mid;i++)&#123;        ll j=i+lmax[i]-lmin[i];        if(j&gt;mid&amp;&amp;rmax[j]&lt;lmax[i]&amp;&amp;rmin[j]&gt;lmin[i]) w++;    &#125;    ll p1=mid+1,p2=mid;    while(p1&lt;=r&amp;&amp;rmax[p1]&lt;lmax[l]) tong[rmax[p1]-p1]--,p1++;    while(p2&lt;r&amp;&amp;rmin[p2+1]&gt;lmin[l]) p2++,tong[rmax[p2]-p2]++;    for(ll i=l;i&lt;=mid;i++)&#123;        while(p1&gt;mid+1&amp;&amp;rmax[p1-1]&gt;lmax[i]) p1--,tong[rmax[p1]-p1]++;         while(p2&gt;mid&amp;&amp;rmin[p2]&lt;lmin[i]) tong[rmax[p2]-p2]--,p2--;        w+=max(tong[lmin[i]-i],0ll);    &#125;    for(ll i=mid+1;i&lt;=r;i++)&#123;        tong[rmax[i]-i]=0;    &#125;    return w;&#125;ll solve(ll l,ll r)&#123;    if(l==r) return 1;    ll mid=(l+r)&gt;&gt;1;    ll zz=solve(l,mid)+solve(mid+1,r);    zz+=work(l,r,mid);    reverse(a+l,a+r+1);    if((r-l+1)&amp;1) mid--;    zz+=work(l,r,mid);    reverse(a+l,a+r+1);    return zz;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        ll xx,yy;        scanf(&quot;%lld%lld&quot;,&amp;xx,&amp;yy);        a[xx]=yy;    &#125;    cout&lt;&lt;solve(1,n);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试3「序列·熟练剖分·建造游乐园（play）」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%953%E3%80%8C%E5%BA%8F%E5%88%97%C2%B7%E7%86%9F%E7%BB%83%E5%89%96%E5%88%86%C2%B7%E5%BB%BA%E9%80%A0%E6%B8%B8%E4%B9%90%E5%9B%AD%EF%BC%88play%EF%BC%89%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%953%E3%80%8C%E5%BA%8F%E5%88%97%C2%B7%E7%86%9F%E7%BB%83%E5%89%96%E5%88%86%C2%B7%E5%BB%BA%E9%80%A0%E6%B8%B8%E4%B9%90%E5%9B%AD%EF%BC%88play%EF%BC%89%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-15 09:23</p><p>-–恢复内容开始—</p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>刚调出来样例就A了，假装是水题。</p><p>因为是乱序，我们要求出来每两项之间最小公比，而不是直接比</p><p>求出来每两项之间最小公比，然后扫一遍就完了。（还要注意重复情况）</p><p>那么问题就转化成了怎么求最小公比。</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190715093903624-710433398.png"></p><p>完了</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 100000using namespace std;ll n,a[10*A],tot=0,maxlen[10*A],nowlen=0,dl[10*A],zuixiaogongbi,prime[10*A],mark[10*A],ges[1010],ml=0,big[A];   set &lt;ll&gt; s;ll gcd(ll x,ll y)&#123;    return y==0?x:gcd(y,x%y);&#125;bool pol(ll ooo)&#123;    ll x=ooo;    for(ll i=1;i&lt;=tot;i++)&#123;        if(prime[i]&gt;x) break;        while(x!=prime[i])&#123;            if(x%prime[i]==0)&#123;                if(!ges[prime[i]])                    dl[++dl[0]]=prime[i];                ges[prime[i]]++;                x=x/prime[i];        &#125;            else break;        &#125;        if(x==prime[i])&#123;            if(!ges[x])dl[++dl[0]]=x;            ges[x]++;            break;        &#125;    &#125;    if(x)return 0;    return 1;&#125;bool check(ll x,ll y)&#123;    memset(ges,0,sizeof(ges));    dl[0]=0;    if(x&lt;=y) swap(x,y);    if(x%y) return 0;    ll z=x/y,gd=1;    if(pol(z))return 0;    if(dl[0]!=1)    &#123;        gd=gcd(ges[dl[1]],ges[dl[2]]);        zuixiaogongbi=1;        for(ll i=3;i&lt;=dl[0];i++)            gd=gcd(ges[dl[i]],gd);    &#125;    else        gd=ges[dl[1]],zuixiaogongbi=1;//    for(ll i=1;i&lt;=dl[0];i++)&#123;//        printf(&quot;ges=%lld dl=%lld \n&quot;,ges[dl[i]],dl[i]);//    &#125;//    printf(&quot;pd=%lld\n&quot;,gd);    for(ll i=1;i&lt;=dl[0];i++)        ges[dl[i]]/=gd,zuixiaogongbi*=ges[dl[i]]*dl[i];        return 1;&#125;int main()&#123;    for(ll i=2;i&lt;=1000;i++)&#123;        if(!mark[i])&#123;            prime[++tot]=i;                &#125;        for(ll j=1;j&lt;=tot;j++)&#123;            if(i*prime[j]&gt;1000) break;            mark[i*prime[j]]=1;            if(i%prime[j]==0)&#123;break;&#125;        &#125;    &#125;    ll man=0;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    ll len=1;    for(ll i=2;i&lt;=n;i++)        if(a[i]==a[i-1])&#123;len++;&#125;        else&#123;man=max(man,len);len=1;&#125;    man=max(man,len);    for(ll i=2;i&lt;=n;i++)&#123;        if(check(a[i],a[i-1]))        big[i]=zuixiaogongbi;        else big[i]=-1;    &#125;    len=1;s.insert(a[1]);    for(ll i=2;i&lt;=n;i++)//枚举开头    &#123;        if((big[i]!=-1)&amp;&amp;(big[i]==big[i-1]||big[i-1]==0||s.size()==1))        &#123;            ll x=a[i];            bool ok=0;            if((s.find(x))==s.end())            &#123;//                printf(&quot;insert a[%lld]=%lld big[%lld]=%lld big[%lld]=%lld\n&quot;,i,a[i],i-1,big[i-1],i-2,big[i-2]);                s.insert(x);                ll sz=s.size();                man=max(man,sz);            &#125;            else             &#123;//                printf(&quot;因重复而清空 i=%lld\n&quot;,i);                ll sz=s.size();                man=max(man,sz);                s.clear();s.insert(a[i]);                ll ss=s.size();//                printf(&quot;目前size=%lld\n&quot;,ss);            &#125;        &#125;        else         &#123;                        ll sz=s.size();//            printf(&quot;因不相等而清空 i=%lld sz=%lld\n&quot;,i,sz);            man=max(man,sz);            s.clear();            s.insert(a[i]);        &#125;        ll w=s.size();//        printf(&quot;w=%lld\n&quot;,w);    &#125;    ll sz=s.size();    man=max(man,sz);    cout&lt;&lt;man&lt;&lt;endl;&#125;</code></pre><p>View Code</p><h2 id="熟练剖分"><a href="#熟练剖分" class="headerlink" title="熟练剖分"></a>熟练剖分</h2><p>这个题还是挺好的。</p><p>这是学长的题解</p><p>时间复杂度为O(n^2)的树上dp，关键在如何设计状态以及如何合并dp数组</p><p>对于这个关键部分可以有很多种不同的设计，欢迎同学们积极设计自己的状态定义以及转移方式</p><p>我分享一下我的做法</p><p>f[i][j]表示对于点i，其子树内最大代价为j的方案数</p><p>转移方式为</p><ol><li>以dfs为大框架进行</li><li>对于每个节点先处理所有的儿子节点，最后将已获得的所有子节点信息进行合并得到该节点信息</li><li>合并时，依次将每一个子节点的信息纳入暂时的动态的一个dp数组储存，该dp数组分为0&#x2F;1两个数组，大概长成g[0&#x2F;1][j]这个样子（可以使用滚动数组变成g[0&#x2F;1][0&#x2F;1][j]）0数组表示之前的子节点中不含重边的情况,1表示之前的子节点中已含有重边，j表示对应状况下，最大代价为j（不是前缀和），数组内存储信息为该情况下的方案数</li><li>转移就简单了，枚举g数组的每一种情况以及正在合并的子节点dp数组的每一种情况，进行转移，转移时注意代价与重边的变化</li><li>这个时间复杂度的计算来自于点对总数，所以一定要把合并时的时间复杂度准确控制，不要错误写成O(n^3)的dp</li></ol><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 10000using namespace std;const ll mod=1e9+7;ll g[2][2][A],f[A][A],son[A][A],size[A],n,sum;bool flag[A];inline ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;void dfs(ll x)&#123;    if(!son[x][0])&#123;f[x][0]=1;return ;&#125;    for(ll i=1;i&lt;=son[x][0];i++)&#123;        ll y=son[x][i];        dfs(y);size[x]=max(size[x],size[y]+1);    &#125;    ll cur=0,maxn=size[son[x][1]]+1;    memset(g,0,sizeof(g));    for(ll i=1;i&lt;=maxn;i++)&#123;        g[0][0][i]=f[son[x][1]][i-1];//因为g选择的是x的儿子，当前面没有选择重链时应该由i-1转移过来        g[0][1][i]=f[son[x][1]][i];//因为g选择了重链，所以i代价应该减1    &#125;    g[0][1][0]=f[son[x][1]][0];    for(ll i=2;i&lt;=son[x][0];i++)&#123;        memset(g[cur^1],0,sizeof(g[cur^1]));        for(ll j=0;j&lt;=maxn;j++)&#123;            for(ll k=0;k&lt;=size[son[x][i]];k++)&#123;//枚举儿子的深度                g[cur^1][0][max(j,k+1)]=(g[cur^1][0][max(j,k+1)]+f[son[x][i]][k]*g[cur][0][j])%mod;//还没有重链                g[cur^1][1][max(j,k+1)]=(g[cur^1][1][max(j,k+1)]+f[son[x][i]][k]*g[cur][1][j])%mod;//之前的点已经有了重链                g[cur^1][1][max(j,k)]=(g[cur^1][1][max(j,k)]+f[son[x][i]][k]*g[cur][0][j])%mod;//选择当前点为重链            &#125;        &#125;        cur^=1;        maxn=max(maxn,size[son[x][i]]+1);    &#125;    memcpy(f[x],g[cur][1],sizeof(f[x]));&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    sum=1;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;son[i][0]);        if(son[i][0])&#123;            for(ll j=1;j&lt;=son[i][0];j++)&#123;                ll r;scanf(&quot;%lld&quot;,&amp;r);                son[i][j]=r;                flag[r]=1;            &#125;        &#125;        (sum*=((son[i][0]==0)?1:meng(son[i][0],mod-2)))%=mod;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        if(!flag[i])&#123;            dfs(i);            ll ans=0;            for(ll j=1;j&lt;=size[i];j++)                &#123;ans=(ans+f[i][j]*j)%mod;&#125;            ans=sum*ans%mod;            printf(&quot;%lld\n&quot;,ans);            return 0;        &#125;    &#125;&#125;</code></pre><p>View Code</p><h2 id="建造游乐园"><a href="#建造游乐园" class="headerlink" title="建造游乐园"></a>建造游乐园</h2><p>首先我们要知道无向图的一条性质，一个无向图一定有偶数个度数为奇数的点。<br>那么我们在i-1中随意连边（可连可以不连，共2^种情况）$C_{i-1}^{2}$是哪两个点之间连边的情况，而$2^{C_{i-1}^{2}}$则是每个边都可以选择或者不选，</p><p>那么即使有度数为奇数的点，我们让i与它相连就保证了i点入度仍为偶数，并且其他奇数入度点变成了偶数。<br>这样我们就保证了它一定是偶数条边</p><p>设g&#x3D;$2^{C_{i-1}^{2}}$（为可能不连通的欧拉图） f为符合的连通的欧拉图<br>因为欧拉图必须所有点都入度为偶数<br>只要有入度为奇数的点就不符合<br>于是我们用一个类似于容斥的东西只要有不联通就不行。</p><p>g[j]中本身包含只有一个点连通，只有两个点连通一直到j个点连通我们让g[j]减去1–j-1的连通情况就构成了j个点连通。</p><p>我们让f包含i点，我们还要从剩余i-1个点中，选择j-1个点使它与i点组成连通图f[j]。</p><p>剩余i-j个点随意连（g图与f图完全分割，没有连边）</p><p>然后我们从i-1个点中选择j-1个让j-1个点与i相连。</p><p>于是我们得到了：<br>$f[i]&#x3D;g[i]-\sum \limits_{j&#x3D;1}^{i-1}f[j]<em>g[i-j]</em>{C_{i-1}^{j-1}}$</p><p>至于为什么不是i个里面选，会选重复</p><p>完了</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2100const ll mod=1000000007;ll n,sum[A],c=0,ans,cishu,C[A][A],g[A],f[A];ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)    ans=ans*x%mod;    return ans;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    C[0][0]=1;    for(ll i=1;i&lt;=n;i++) C[i][0]=1;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=i;j++)            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;    for(ll i=1;i&lt;=n;i++)        g[i]=meng(2,C[i-1][2]);    //首先我们要知道无向图的一条性质，一个无向图一定有偶数个度数为奇数的点    //那么我们在i-1中随意连边（可连可以不连，共2^种情况），即使有度数为奇数的点我们相连仍为偶数    for(ll i=1;i&lt;=n;i++)&#123;        f[i]=g[i];        for(ll j=1;j&lt;=i-1;j++)&#123;            f[i]-=f[j]*g[i-j]%mod*C[i-1][j-1]%mod;            //乘i-1,j-1原因。很简单，我们从i-1个数中选，让他们与i相连        &#125;        f[i]=(f[i]%mod+mod)%mod;    &#125;    cout&lt;&lt;(f[n]*C[n][2]%mod+mod)%mod&lt;&lt;endl;&#125;</code></pre><p>View Code</p><p>-–恢复内容结束—</p><h2 id="序列-1"><a href="#序列-1" class="headerlink" title="序列"></a>序列</h2><p>刚调出来样例就A了，假装是水题。</p><p>因为是乱序，我们要求出来每两项之间最小公比，而不是直接比</p><p>求出来每两项之间最小公比，然后扫一遍就完了。（还要注意重复情况）</p><p>那么问题就转化成了怎么求最小公比。</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190715093903624-710433398.png"></p><p>完了</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif">View<br>Code</p><h2 id="熟练剖分-1"><a href="#熟练剖分-1" class="headerlink" title="熟练剖分"></a>熟练剖分</h2><p>这个题还是挺好的。</p><p>一切尽在代码之中</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif">tj</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif">View<br>Code</p><h2 id="建造游乐园-1"><a href="#建造游乐园-1" class="headerlink" title="建造游乐园"></a>建造游乐园</h2><p>首先我们要知道无向图的一条性质，一个无向图一定有偶数个度数为奇数的点。<br>那么我们在i-1中随意连边（可连可以不连，共2^种情况）$C_{i-1}^{2}$是哪两个点之间连边的情况，而$2^{C_{i-1}^{2}}$则是每个边都可以选择或者不选，</p><p>那么即使有度数为奇数的点，我们让i与它相连就保证了i点入度仍为偶数，并且其他奇数入度点变成了偶数。<br>这样我们就保证了它一定是偶数条边</p><p>设g&#x3D;$2^{C_{i-1}^{2}}$（为可能不连通的欧拉图） f为符合的连通的欧拉图<br>因为欧拉图必须所有点都入度为偶数<br>只要有入度为奇数的点就不符合<br>于是我们用一个类似于容斥的东西只要有不联通就不行。</p><p>g[j]中本身包含只有一个点连通，只有两个点连通一直到j个点连通我们让g[j]减去1–j-1的连通情况就构成了j个点连通。</p><p>我们让f包含i点，我们还要从剩余i-1个点中，选择j-1个点使它与i点组成连通图f[j]。</p><p>剩余i-j个点随意连（g图与f图完全分割，没有连边）</p><p>然后我们从i-1个点中选择j-1个让j-1个点与i相连。</p><p>于是我们得到了：<br>$f[i]&#x3D;g[i]-\sum \limits_{j&#x3D;1}^{i-1}f[j]<em>g[i-j]</em>{C_{i-1}^{j-1}}$</p><p>至于为什么不是i个里面选，会选重复</p><p>完了</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2100const ll mod=1000000007;ll n,sum[A],c=0,ans,cishu,C[A][A],g[A],f[A];ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)    ans=ans*x%mod;    return ans;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    C[0][0]=1;    for(ll i=1;i&lt;=n;i++) C[i][0]=1;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=i;j++)            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;    for(ll i=1;i&lt;=n;i++)        g[i]=meng(2,C[i-1][2]);    //首先我们要知道无向图的一条性质，一个无向图一定有偶数个度数为奇数的点    //那么我们在i-1中随意连边（可连可以不连，共2^种情况），即使有度数为奇数的点我们相连仍为偶数    for(ll i=1;i&lt;=n;i++)&#123;        f[i]=g[i];        for(ll j=1;j&lt;=i-1;j++)&#123;            f[i]-=f[j]*g[i-j]%mod*C[i-1][j-1]%mod;            //乘i-1,j-1原因。很简单，我们从i-1个数中选，让他们与i相连        &#125;        f[i]=(f[i]%mod+mod)%mod;    &#125;    cout&lt;&lt;(f[n]*C[n][2]%mod+mod)%mod&lt;&lt;endl;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试2「排列 （搜索）·APIO划艇」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%952%E3%80%8C%E6%8E%92%E5%88%97%20%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%C2%B7APIO%E5%88%92%E8%89%87%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%952%E3%80%8C%E6%8E%92%E5%88%97%20%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%C2%B7APIO%E5%88%92%E8%89%87%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-09 14:36</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p><img src="http://hzoj.com/images/190707_2HdjfQh7mF.png" alt="image"></p><h6 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h6><h6 id=""><a href="#" class="headerlink" title=""></a><img src="http://hzoj.com/images/190707_a5kp8JK2Ja.png" alt="image"></h6><h6 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h6><p>对于30%的数据，1&lt;&#x3D;N&lt;&#x3D;4； 对于全部的数据，1&lt;&#x3D;N&lt;&#x3D;12。</p><p>一群数论题中出了一个搜索。</p><p>甚至我考试时一点也不会。</p><p>自己算复杂度比较大然后交上去只跑了90ms。</p><p>这也太</p><p>不多说了。</p><p>引理1</p><p>当前可以将原数列变成排序的操作，其每一种其他排列都可以将原序列变成排序。</p><p>证明 不太好证，举几个例子</p><p>例如 3 4 2 1这个序列可以经过操作1 操作2 变成 1 2 3 4</p><p>那么显然 先进行操作2 再进行操作1 也可以变成 1 2 3 4</p><p>于是推而广之 （数学归纳）用cnt次操作可以达到目的，那么所有符合的方案数为cnt!</p><p>这样通过引理1 可以剪很多枝</p><p>我们从小到大枚举每一种方案，每次验证符合，若符合ans+cnt！就完了</p><p>引理2</p><p>假设枚举到第i个方案 设划分序列为区间长度为1&lt;&lt;(i+1)的序列，如果有三个及以上不符合递增且相连的区间，那么这个序列没救了。</p><p>这个我们可以验证</p><p>首先我们保证如果我们进行到第i个方案那么所有长度1&lt;&lt;i的序列都符合递增且相连</p><p>如果有一个长度1&lt;&lt;(i+1)不是递增且相连的区间，我们把它划分成两个1&lt;&lt;i,i&lt;&lt;i的序列，我们直接用第i种操作（可能）就行了</p><p>然后如果有两个长度那么把它划分成四个，然后也（可能）行</p><p>但如果有三个及以上我们最多保证经过i操作后，两个序列符合条件</p><p>所以得证</p><p>然后搜就完了</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1000000using namespace std;ll xx[A],a[A],b[A],ans,n;ll read()&#123;        ll x=0,f=1;char ch=getchar();        while(!isdigit(ch))&#123;                if(ch==&#39;-&#39;) f=-1;                ch=getchar();        &#125;        while(isdigit(ch))&#123;                x=x*10+ch-&#39;0&#39;;                ch=getchar();        &#125;        return f*x;&#125;void SWAP(ll x,ll k,ll len)&#123;        for(ll i=x,j=k;len;len--,i++,j++)                 swap(a[i],a[j]);&#125;bool check(ll l,ll r)&#123;        for(ll i=l;i&lt;r;i++)                if(a[i]+1!=a[i+1])                        return 0;        return 1;&#125;void shuchu()&#123;        for(ll i=1;i&lt;=(1&lt;&lt;n);i++)                cout&lt;&lt;a[i]&lt;&lt;&quot;&quot;;        cout&lt;&lt;endl;&#125;void dfs(ll k,ll cnt)&#123;//        shuchu();//        cout&lt;&lt;k&lt;&lt;endl;        if(k==n)        &#123;                ans+=xx[cnt];                return ;        &#125;        ll now=(1&lt;&lt;(k+1)),x=(1&lt;&lt;k),b[5],tot=0;        for(ll i=1;i&lt;=(1&lt;&lt;n);i+=now)        &#123;       //                printf(&quot;检查i=%lld j=%lld\n&quot;,i,i+now-1);                 if(!check(i,i+now-1))                &#123;                        b[++tot]=i;                        if(tot==3) return ;                &#125;        &#125;//        cout&lt;&lt;&quot;tot=&quot;&lt;&lt;tot&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;&quot;now=&quot;&lt;&lt;now&lt;&lt;endl;//        for(ll i=1;i&lt;=n;i++)//        &#123;//                //        &#125;        if(tot==0) &#123;dfs(k+1,cnt);return ;&#125;        if(tot==1)        &#123;                SWAP(b[1],b[1]+x,x);                if(check(b[1],b[1]+x)) dfs(k+1,cnt+1);                SWAP(b[1],b[1]+x,x);        &#125;        if(tot==2)        &#123;                SWAP(b[1],b[2],x);                if(check(b[1],b[1]+x)&amp;&amp;check(b[2],b[2]+x)) dfs(k+1,cnt+1);                SWAP(b[1],b[2],x);                SWAP(b[1]+x,b[2],x);                if(check(b[1],b[1]+x)&amp;&amp;check(b[2],b[2]+x)) dfs(k+1,cnt+1);                SWAP(b[1]+x,b[2],x);                SWAP(b[1],b[2]+x,x);                if(check(b[1],b[1]+x)&amp;&amp;check(b[2],b[2]+x)) dfs(k+1,cnt+1);                SWAP(b[1],b[2]+x,x);                SWAP(b[1]+x,b[2]+x,x);                if(check(b[1],b[1]+x)&amp;&amp;check(b[2],b[2]+x)) dfs(k+1,cnt+1);                SWAP(b[1]+x,b[2]+x,x);        &#125;//        shuchu();&#125;int main()&#123;        n=read();xx[0]=1;        for(ll i=1;i&lt;=(1&lt;&lt;n);i++) a[i]=read();        for(ll i=1;i&lt;=n;i++) xx[i]=xx[i-1]*i;        dfs(0,0);        cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><p>View Code</p><h3 id="划艇"><a href="#划艇" class="headerlink" title="划艇"></a>划艇</h3><p>有点难。</p><p>至少对于我来说有点难。弱的我在loj交了5页wa 才AC。</p><p>不多说了。</p><p><a href="https://blog.csdn.net/qq_22541499/article/details/51674707">https://blog.csdn.net/qq_22541499/article/details/51674707</a></p><p><a href="https://www.cnblogs.com/hzoi-DeepinC/p/11158757.html#4298030">https://www.cnblogs.com/hzoi-DeepinC/p/11158757.html#4298030</a></p><p><a href="https://www.cnblogs.com/heoitys/p/11166727.html">https://www.cnblogs.com/heoitys/p/11166727.html</a></p><p>这三篇博客已经讲的很清楚了。</p><p>所以我鸽掉了</p><p>必须写出来，填掉这个这个坑，要不这个题就白做了。</p><hr><p>首先这个题必须离散化，肯定开不了这么大的数组。</p><p>我们把区间离散化一下，把每段区间设置成左开右闭（或者左闭右开）的，把每个区间出现次序处理出来，左右端点处理出来，区间长度处理出来，</p><p>注意这里区间不可以设置成左闭右闭的，因为如果这样设置会出现重复枚举，前面这段区间会枚举最右面这个端点，后面这个区间会枚举最左面这个区间。</p><p>然后思考这个题肯定要dp</p><p>说明f数组含义。</p><p>设$f[i][j]$表示第i个学校选择第j个区间中某一个数</p><p>思考会被什么转移</p><p>首先如果前面所有学校都没有选择j之后的区间（要么没选要么选择了j之前的区间），那么这个区间可以选择任何一个数。</p><p>$\sum\limits_{l&#x3D;1}^{i-1}\sum\limits_{r&#x3D;1}^{j-1} f[l][r]*C_{len}^{1}$</p><p>然后如果前面有学校同样选择了j这个区间</p><p>先假设前面选择这个区间的学校为k</p><p>那么对当前这个区间的贡献即为</p><p>$\sum\limits_{l&#x3D;1}^{k-1}\sum\limits_{r&#x3D;1}^{j-1} f[l][r]$*（k～i之间一堆方案数）</p><p>$\sum\limits_{l&#x3D;1}^{k-1}\sum\limits_{r&#x3D;1}^{j-1}<br>f[l][r]$$\sum\limits_{l&#x3D;1}^{i-1}\sum\limits_{r&#x3D;1}^{j-1}<br>f[l][r]*C_{len}^{1}$这两个式子都可以用前缀和进行维护</p><p>那么我们现在要做的就是求出来（k～i之间一堆方案数）</p><p>剩下的明天写</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试1「co……·记忆的轮廓·雨天的尾巴」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%951%E3%80%8Cco%E2%80%A6%E2%80%A6%C2%B7%E8%AE%B0%E5%BF%86%E7%9A%84%E8%BD%AE%E5%BB%93%C2%B7%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%951%E3%80%8Cco%E2%80%A6%E2%80%A6%C2%B7%E8%AE%B0%E5%BF%86%E7%9A%84%E8%BD%AE%E5%BB%93%C2%B7%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-06-23 14:28</p><p>考试的时候用哈希水过了第一题本来想用哈希只可以得20左右没想到由于数据过于水A了</p><p>然后雨天的尾巴骗了5分，总分105 我太菜了</p><p>首先时间分配的不合理：第一题大水题ac自动机打完了都不会，第二题略微想了想打了个高斯消元，然后样例没过……，最后输出了一个随机数，第三题（lca板子忘了，打错一个地方，没有调出来）最后骗了五分</p><p>考后主要讲一下第二题：记忆的轮廓（bzoj4899）和第三题：雨天的尾(yi)巴（bzoj3307）</p><hr><h1 id="Censoring"><a href="#Censoring" class="headerlink" title="Censoring"></a>Censoring</h1><p>FJ把杂志上所有的文章摘抄了下来并把它变成了一个长度不超过的字符串S。他有一个包含n个单词的列表，列表里的n个单词记t1<br>….tn为他希望从S中删除这些单词。<br>FJ每次在S中找到最早出现的列表中的单词(最早出现指该单词的开始位置最小)，然后从S中删除这个单词。他重复这个操作直到S中没有列表里的单词为止。注意删除一个单词后可能会导致S中出现另一个列表中的单词<br>FJ注意到列表中的单词不会出现一个单词是另一个单词子串的情况，这意味着每个列表中的单词在S中出现的开始位置是互不相同的<br>请帮助FJ完成这些操作并输出最后的S串​1​​…tNt_Nt​N​​。他希望从S中删除这些单词。<br>FJ每次在S中找到最早出现的列表中的单词(最早出现指该单词的开始位置最小)，然后从S中删除这个单词。他重复这个操作直到S中没有列表里的单词为止。注意删除一个单词后可能会导致S中出现另一个列表中的单词<br>FJ注意到列表中的单词不会出现一个单词是另一个单词子串的情况，这意味着每个列表中的单词在S中出现的开始位置是互不相同的<br>请帮助FJ完成这些操作并输出最后的S</p><p>没什么好讲的，ac自动机然后开栈维护</p><hr><h1 id="记忆的轮廓"><a href="#记忆的轮廓" class="headerlink" title="记忆的轮廓"></a>记忆的轮廓</h1><p>内存限制：512 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>通往贤者之塔的路上，有许多的危机。<br>我们可以把这个地形看做是一颗树，根节点编号为1，目标节点编号为n，其中1-n的简单路径上，编号依次递增，在[1,n]中，一共有n个节点。我们把编号在[1,n]的叫做正确节点，[n+1,m]的叫做错误节点。一个叶子，如果是正确节点则为正确叶子，否则称为错误叶子。莎缇拉要帮助昴到达贤者之塔，因此现在面临着存档位置设定的问题。<br>为了让昴成长为英雄，因此一共只有p次存档的机会，其中1和n必须存档。被莎缇拉设置为要存档的节点称为存档位置。当然不能让昴陷入死循环，所以存档只能在正确节点上进行，而且同一个节点不能存多次档。因为通往贤者之塔的路上有影响的瘴气，因此莎缇拉假设昴每次位于树上一个节点时，都会等概率选择一个儿子走下去。每当走到一个错误叶子时，再走一步就会读档。具体的，每次昴到达一个新的存档位置，存档点便会更新为这个位置（假如现在的存档点是i，现在走到了一个存档位置j&gt;i，那么存档点便会更新为j）。读档的意思就是回到当前存档点。初始昴位于1，当昴走到正确节点n时，便结束了路程。莎缇拉想知道，最优情况下，昴结束路程的期望步数是多少？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个正整数T表示数据组数。<br>接下来每组数据，首先读入三个正整数n,m,p。<br>接下来m-n行，描述树上所有的非正确边（正确边即连接两个正确节点的边）<br>用两个正整数j，k表示j与k之间有一条连边，j和k可以均为错误节点，也可以一个为正确节点另一个为错误节点。<br>数据保证j是k的父亲。<br>50&lt;&#x3D;p&lt;&#x3D;n&lt;&#x3D;700，m&lt;&#x3D;1500，T&lt;&#x3D;5。<br>数据保证每个正确节点均有至少2个儿子，至多3个儿子。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>T行每行一个实数表示每组数据的答案。请保留四位小数。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>13 7 21 42 53 63 7</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>9.0000</code></pre><p>这个题还是挺有意思的</p><p>题目中提到这一句话<br>““我们可以把这个地形看做是一颗树，根节点编号为1，目标节点编号为n，其中1-n的简单路径上，编号依次递增，在[1,n]中，一共有n个节点。我们把编号在[1,n]的叫做正确节点，[n+1,m]的叫做错误节点。””<br>那么题目中就暗示了1–n的路径肯定是一条链</p><p>首先题目中说简单路径<br>其次具体可以反证出来<br>比如假设有三个点1-2 1-3 各有一条边那么1-3的简单路径就只有两个节点与n（n&#x3D;&#x3D;3）个节点矛盾所以1-n的路径一定是一条链</p><p>这一个小点一定要读出来</p><p>设d[i]为i的出度，g[i]为错误儿子i返回存档期望步数,s[i]为当前点走到所有错误节点g之和</p><p>设a[i][j]表示以i为最新存档点走到j时期望步数，f[i][j]为以i为下一个存档点当前还剩余j个存档点</p><p>我们逆着转移f，f可以由任意一个在i之后的点并且剩余存档数量为j-1的f贡献</p><p>然后分析 这个dp实际上就是在1-n一条链上进行的, 那么我们其实就可以写出一个”类似“于线性dp的方程式</p><blockquote><p><strong>$f[i][j]&#x3D;min(f[i][j],f[k][j-1]+a[i][k])$</strong></p></blockquote><p>这里a数组求法分析</p><p>设c是从j-1走到j的期望步数</p><p>a[i][j]&#x3D;a[i][j-1]+c</p><p>分析</p><p>首先1&#x2F;d[j-1]概率走到正确节点</p><p>其他可以由首先走到错误节点son</p><p>然后返回存档i，再继续走一个a[i][j-1]，然后再加上从j-1走到j的期望步数</p><p>这里有一个注意点 这里的c在Σ中要加一（走到错误节点要走一步）</p><p>于是</p><blockquote><p>$c&#x3D;1&#x2F;d[j-1]+Σ(g[son]+a[i][j-1]+c+1)$&#x2F;&#x2F;<strong>(son表示j-1的错误儿子)</strong></p></blockquote><p>分析我们将所有g相加就是s</p><blockquote><p>$c&#x3D;(1&#x2F;d[j-1])+(d[j-1]-1)&#x2F;d[j-1]+(1&#x2F;d[j-1])*s[j-1]+((d[j-1]-1)&#x2F;d[j-1])*a[i][j-1]+((d[j-1]-1)&#x2F;d[j-1])*c$</p></blockquote><p>移项</p><blockquote><p>**$1&#x2F;d[j-1]*c&#x3D;1+1&#x2F;d[j-1]<em>s[j-1]+((d[j-1]-1)&#x2F;d[j-1])<em>a[i][j-1];$</em></em></p></blockquote><p>首先要预处理出走到错误节点返回的期望，具体可以通过一个简单dfs处理</p><p>然后我们再次相乘得出</p><blockquote><p>**$c&#x3D;d[j-1]+s[j-1]+(d[j-1]-1)<em>a[i][j-1];$</em>*</p></blockquote><p>最后相加</p><p>得出</p><blockquote><p>**$a[i][j]&#x3D;a[i][j-1]<em>d[j-1]+d[j-1]+s[j-1];$</em>*</p></blockquote><p>然后</p><blockquote><p><strong>$f[i][j]&#x3D;min(f[i][j],f[k][j-1]+a[i][k]);$</strong></p></blockquote><p>那么我们推测对于a数组来说 它的快速增长肯定会爆</p><p>然后我们记录一个step，推测每次转移大致最大相差40步左右（但我觉得这么做是qj测试点）</p><p>然后就有了<code>if(k-i&gt;40) break;</code></p><p>经过实际测试（由于测试点过水） k-i 取到20左右就可以了</p><p>以下是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define db double#define A 2500using namespace std;ll t,tot=0,n,m,p,head[A],nxt[A],ver[A];db g[A],a[A][A],cur,f[A][A],d[A],s[A];bool flag[A];inline void add(ll x,ll y)&#123;nxt[++tot]=head[x];head[x]=tot;ver[tot]=y;&#125;inline ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c))    &#123;        if(c==&#39;-&#39;)        f=-1;        c=getchar();    &#125;    while(isdigit(c))    &#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;void dfs(ll x)&#123;    flag[x]=1;    g[x]=1.0;    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(!flag[y])            dfs(y);        g[x]+=1.0/d[x]*g[y];    &#125;&#125;int main()&#123;    t=read();    while(t--)    &#123;            tot=0;        memset(flag,0,sizeof(flag));        memset(head,0,sizeof(head));        memset(nxt,0,sizeof(nxt));        memset(ver,0,sizeof(ver));        memset(d,0,sizeof(d));        memset(g,0,sizeof(g));        memset(flag,0,sizeof(flag));        memset(f,125,sizeof(f));        n=read();m=read();p=read();        for(ll i=1;i&lt;=m-n;i++)        &#123;            ll x,y;            x=read(),y=read();            add(x,y);d[x]++;        &#125;        for(ll i=1;i&lt;n;i++)            d[i]++;        for(ll i=1;i&lt;=n;i++)            if(!flag[i])dfs(i);        for(ll i=1;i&lt;=n;i++)        &#123;            s[i]=0;            for(ll j=head[i];j;j=nxt[j])            &#123;                ll y=ver[j];                s[i]+=g[y];            &#125;        &#125;        for(ll i=1;i&lt;=n;i++)        &#123;                a[i][i]=0;            for(ll j=i+1;j&lt;=n;j++)                a[i][j]=a[i][j-1]*d[j-1]+s[j-1]+d[j-1];        &#125;            f[n][1]=0.0;            for(ll j=2;j&lt;=p;j++)        &#123;            for(ll i=1;i&lt;=n;i++)                for(ll k=i+1;k&lt;=n;k++)                &#123;                    if(k-i&gt;40) break;                    f[i][j]=min(f[i][j],f[k][j-1]+a[i][k]);                &#125;        &#125;        db ans=f[1][p];        printf(&quot;%.4lf\n&quot;,ans);        &#125;    return 0;&#125;</code></pre><p>View Code</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 #define ll long long 3 #define db double 4 #define A 2500 5 using namespace std; 6 ll t,tot=0,n,m,p,head[A],nxt[A],ver[A]; 7 db g[A],a[A][A],cur,f[A][A],d[A],s[A]; 8 bool flag[A]; 9 inline void add(ll x,ll y)10 &#123;nxt[++tot]=head[x];head[x]=tot;ver[tot]=y;&#125;11 inline ll read()12 &#123;13     ll x=0,f=1;char c=getchar();14     while(!isdigit(c))15     &#123;16         if(c==&#39;-&#39;)17         f=-1;18         c=getchar();19     &#125;20     while(isdigit(c))21     &#123;22         x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;23         c=getchar();24     &#125;25     return f*x;26 &#125;27 void dfs(ll x)28 &#123;29     flag[x]=1;30     g[x]=1.0;31     for(ll i=head[x];i;i=nxt[i])32     &#123;33         ll y=ver[i];34         if(!flag[y])35             dfs(y);36         g[x]+=1.0/d[x]*g[y];37     &#125;38 &#125;39 int main()40 &#123;41     t=read();42     while(t--)43     &#123;    44         tot=0;45         memset(flag,0,sizeof(flag));46         memset(head,0,sizeof(head));47         memset(nxt,0,sizeof(nxt));48         memset(ver,0,sizeof(ver));49         memset(d,0,sizeof(d));50         memset(g,0,sizeof(g));51         memset(flag,0,sizeof(flag));52         memset(f,125,sizeof(f));53         n=read();m=read();p=read();54         for(ll i=1;i&lt;=m-n;i++)55         &#123;56             ll x,y;57             x=read(),y=read();58             add(x,y);d[x]++;59         &#125;60         for(ll i=1;i&lt;n;i++)61             d[i]++;62         for(ll i=1;i&lt;=n;i++)63             if(!flag[i])dfs(i);64         for(ll i=1;i&lt;=n;i++)65         &#123;66             s[i]=0;67             for(ll j=head[i];j;j=nxt[j])68             &#123;69                 ll y=ver[j];70                 s[i]+=g[y];71             &#125;72         &#125;73         for(ll i=1;i&lt;=n;i++)74         &#123;    75             a[i][i]=0;76             for(ll j=i+1;j&lt;=n;j++)77                 a[i][j]=a[i][j-1]*d[j-1]+s[j-1]+d[j-1];78         &#125;    79         f[n][1]=0.0;    80         for(ll j=2;j&lt;=p;j++)81             for(ll i=1;i&lt;=n;i++)82                 for(ll k=i+1;k&lt;=n;k++)83                 &#123;84                     if(k-i&gt;40) break;85                     f[i][j]=min(f[i][j],f[k][j-1]+a[i][k]);86                 &#125;87         db ans=f[1][p];88         printf(&quot;%.4lf\n&quot;,ans);    89     &#125;90     return </code></pre><hr><h1 id="C-雨天的尾巴"><a href="#C-雨天的尾巴" class="headerlink" title="C. 雨天的尾巴"></a>C. 雨天的尾巴</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>N个点，形成一个树状结构。有M次发放，每次选择两个点x,y对于x到y的路径上（含x,y)每个点发一袋Z类型的物品。完成所有发放后，每个点存放最多的是哪种物品。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行数字N，M<br>接下来N-1行，每行两个数字a,b,表示a与b间有一条边<br>再接下来M行，每行三个数字x,y,z.如题</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出有N行<br>每i行的数字表示第i个点存放最多的物品是哪一种，如果有<br>多种物品的数量一样，输出编号最小的。如果某个点没有物品则输出0</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>20 508 610 618 620 107 202 1819 81 614 2016 1013 193 1417 1811 194 1115 145 189 1012 1511 14 8712 1 8714 3 8417 2 366 5 9317 6 8710 14 935 16 786 15 9315 5 1611 8 5017 19 505 4 8715 20 781 17 5020 13 877 15 2216 11 9419 8 8718 3 9313 13 872 1 872 6 225 20 8410 12 9318 12 8716 10 938 17 9314 7 367 4 225 9 8713 10 1620 11 509 16 8410 17 1619 6 8712 2 3620 9 949 2 8414 1 945 5 948 17 1612 8 3620 17 7812 18 5016 8 942 19 3610 18 3614 19 504 12 50</code></pre><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>8736842287872250848750368793369416875050</code></pre><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>1&lt;&#x3D;N,M&lt;&#x3D;100000<br>1&lt;&#x3D;a,b,x,y&lt;&#x3D;N<br>1&lt;&#x3D;z&lt;&#x3D;10910^910​9​​</p><p>也是一道不错的题</p><p>思考我们如果按照既定套路，进行树上拆分的话</p><p>我们还需要维护每一个节点出现的值中最大的是什么</p><p>我们首先可以想到开一个v[n][max_size]数组</p><p>然后要i至j的z值+1就</p><p>v[i][z]++，v[j][z]++,v[lca][z]–,v[f[lca][0]][z]–;</p><p>如果只是简单开数组会MLE+TLE</p><p>为了省时间+省空间</p><p>我们可以建立n棵权值线段树</p><p>如果我们不举行别的措施仍然会MLE，故使用动态开点线段树</p><p>另外由于值特别大而我们开的是权值线段树，我们可以进行离散化也可以采取”别的操作“</p><p>别的操作：具体来说例如有m组询问，我们值域只需要开到m 其实还是和离散化差不多</p><p>最后统一进行线段树合并</p><p>完了（数据结构题真不知道要说些什么）</p><p>以下依然是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define A 100005#define ll intusing namespace std;bool flag[A*2];ll cnt=0,Ans[A*60],ans[A*60],deep[A*2],f[A][24],head[A*2],next[A*2],ver[A*2],lc[A*60],rc[A*60],tot=0,T[A*60];ll n,m,sum[A];inline ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))    &#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))    &#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;void pushup(ll now)&#123;    if(ans[lc[now]]&gt;=ans[rc[now]])    ans[now]=ans[lc[now]],Ans[now]=Ans[lc[now]];    else    ans[now]=ans[rc[now]],Ans[now]=Ans[rc[now]];&#125;void add(ll x,ll y)&#123;    next[++tot]=head[x];    head[x]=tot;    ver[tot]=y;&#125;ll merge(ll x,ll y,ll l,ll r)&#123;    if(l==r&amp;&amp;x&amp;&amp;y) ans[x]+=ans[y];    if(!x||!y) return y+x;    ll mid=(l+r)&gt;&gt;1;    lc[x]=merge(lc[x],lc[y],l,mid);    rc[x]=merge(rc[x],rc[y],mid+1,r);    if(l!=r)pushup(x);    return x;&#125;void change(ll &amp;p,ll l,ll r,ll pos,ll v)&#123;    if(!p) p=++cnt;    if(l==r)    &#123;ans[p]+=v;Ans[p]=l;return ;&#125;    ll mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) change(lc[p],l,mid,pos,v);    else change(rc[p],mid+1,r,pos,v);    if(l!=r) pushup(p);&#125;void dfs(ll x,ll dep)&#123;    flag[x]=1,deep[x]=dep;    for(ll i=head[x];i;i=next[i])    &#123;        ll y=ver[i];        if(flag[y]) continue;        f[y][0]=x;        deep[y]=dep;        dfs(y,dep+1);    &#125;&#125;ll lca(ll x,ll y)&#123;    if(deep[x]&gt;deep[y])        swap(x,y);    for(ll i=20;i&gt;=0;i--)    &#123;        if(deep[x]&lt;=deep[f[y][i]])            y=f[y][i];        if(deep[x]==deep[y]) break;    &#125;    if(x==y) return x;    for(ll i=20;i&gt;=0;i--)    &#123;        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    &#125;    return f[x][0];&#125;void dfs_(ll x)&#123;    flag[x]=1;    for(ll i=head[x];i;i=next[i])    &#123;        ll y=ver[i];        if(flag[y]) continue;        dfs_(y);        T[x]=merge(T[x],T[y],1,A);    &#125;    if(ans[T[x]]&gt;0)        sum[x]=Ans[T[x]];&#125;int main()&#123;    n=read(),m=read();    for(ll i=1;i&lt;n;i++)    &#123;        ll xx=read(),yy=read();        add(xx,yy);        add(yy,xx);    &#125;    dfs(1,1);    f[1][0]=0;    for(ll i=1;i&lt;=20;i++)        for(ll j=1;j&lt;=n;j++)            f[j][i]=f[f[j][i-1]][i-1];    ll LCA;    for(ll i=1;i&lt;=m;i++)    &#123;        ll x=read(),y=read(),z=read();        LCA=lca(x,y);        change(T[x],1,A,z,1);        change(T[y],1,A,z,1);        change(T[LCA],1,A,z,-1);        change(T[f[LCA][0]],1,A,z,-1);    &#125;    memset(flag,0,sizeof(flag));    dfs_(1);    for(ll i=1;i&lt;=n;i++)        printf(&quot;%d\n&quot;,sum[i]);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP模拟测试「简单的区间·简单的玄学·简单的填数·简单的序列」</title>
      <link href="/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%E3%80%8C%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E9%97%B4%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E7%8E%84%E5%AD%A6%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E5%A1%AB%E6%95%B0%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%8F%E5%88%97%E3%80%8D/"/>
      <url>/2025/03/14/NOIP%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%E3%80%8C%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E9%97%B4%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E7%8E%84%E5%AD%A6%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E5%A1%AB%E6%95%B0%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%8F%E5%88%97%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-06 12:06</p><h2 id="简单的区间"><a href="#简单的区间" class="headerlink" title="简单的区间"></a>简单的区间</h2><p>$update$</p><p>终于$AC$了</p><p>找到$(sum[r]+sum<a href="sum%E8%A1%A8%E7%A4%BA%E4%BB%A5%E4%B8%AD%E9%97%B4%E7%82%B9%E4%B8%BA%E5%9F%BA%E5%87%86%E7%9A%84sum">l</a>-mx)%k&#x3D;&#x3D;0$的点</p><p>注意这里$sum$表示是以$mid$为基准点,(即$sum[l]$为后缀和,$sum[r]$为前缀和)</p><p>回忆$(sum[r]-sum[l])%k&#x3D;&#x3D;0$这个经典问题做法(入阵曲简化版),开桶,桶里维护$sum[l]%k$,那么$r$贡献就是桶里$sum[r]%k$个数</p><p>于是这个题开桶维护$sum$,问题转化为求$max$即可</p><p>记录$max$位置是否$&gt;mid$,区别对待</p><p>设$f[i][0]$表示$max$在$mid$右面,$f[i][1]$表示$max$在$mid$左面</p><p>$f[i][0]$存下右面$sum[r]-mx$,找桶里是否存在左面$sum[l]$<br>$f[i][1]$存下右面$sum[r]$ 找到左面是否存在$mx-sum[l]$<br>完了</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define A 1010101ll f[A][2],a[A],pos[A],mx[A],sum[A];ll cnt,n,k,ans;void solve(ll l,ll r)&#123;    if(l==r) return ;    ll mid=(l+r)&gt;&gt;1;    cnt=sum[mid]=mx[0]=0;    for(ll i=mid+1;i&lt;=r;i++)&#123;        if(a[i]&gt;a[mx[cnt]]) mx[++cnt]=i;        sum[i]=(sum[i-1]+a[i])%k;        f[(sum[i]-a[mx[cnt]]%k+k)%k][0]++;        pos[i]=mx[cnt];//        printf(&quot;f[%lld]=%lld  sum=%lld cnt=%lld\n&quot;,(sum[i]-a[mx[cnt]]%k+k)%k,f[(sum[i]-a[mx[cnt]]%k+k)%k][0],sum[i],cnt);    &#125;    mx[cnt+1]=r+1;    ll suml=0,rnow=mid+1,mxl=0,p=1;    for(ll i=mid;i&gt;=l;i--)&#123;        suml=(suml+a[i])%k;        mxl=max(mxl,a[i]);        while(p&lt;=cnt&amp;&amp;a[mx[p]]&lt;=mxl) p++;        while(rnow&lt;mx[p]) &#123;            f[(sum[rnow]-a[pos[rnow]]%k+k)%k][0]--;            f[sum[rnow]%k][1]++;            rnow++;        &#125;//        printf(&quot;ans=%lld f[%lld][1]=%lld p=%lld rnow=%lld mx[%lld]=%lldsum[%lld]=%lld\n&quot;,ans,(k+mxl%k-suml)%k,f[(k+mxl%k-suml)%k][1],p,rnow,p,mx[p],rnow,sum[rnow]);        ans+=f[(mxl-suml+k)%k][1];        if(p&lt;=cnt) ans+=f[(k-suml)%k][0];//        printf(&quot;ans=%lld f[%lld][0]=%lld\n&quot;,ans,k-suml,f[(k-suml)%k][0]);    &#125;    for(ll i=mid+1;i&lt;rnow;i++)        f[sum[i]][1]--;    for(ll i=rnow;i&lt;=r;i++)        f[(sum[i]-a[pos[i]]%k+k)%k][0]--;    solve(l,mid);solve(mid+1,r);&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    solve(1,n);    printf(&quot;%lld&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="简单的玄学"><a href="#简单的玄学" class="headerlink" title="简单的玄学"></a>简单的玄学</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目中说至少两个相同那么答案就所有方案-全不相同</p><p>所有方案${(2^n)}^m&#x3D;2^{n*m}$,</p><p>互不相同,首先第一个随便选剩下避开已经选过就行$2^n*2^{n-1}……2^{n-m+1}$</p><p>那么题目很傻逼的让你取模并且约分,你需要先约分再取模(取模再约分的话这个题就太水了,所以是先约分再取模)</p><p>思考怎么约分</p><p>下面全是$2$多少次方,于是我们看上面多少个二就行了</p><p>$2^n*(2^{n}-1)……({2^n}-m+1)$很恶心,思考转化</p><p>性质:$2^n-x$中二个数$&#x3D;$$x$中二的个数</p><p>证明:假设$x$可以表示为$j*(2^w)$(j可以是分数),乘法分配率$2^w*(2^{n-w}-j)$后面这个里面没有别的$2$因子了,原式$&#x3D;$$2^w$,又$j$中没有$2$因子故相乘因子数不变,得证</p><p>那么原式就变成求$(m-1)!$里$2$因子数</p><p>可以简单求</p><pre><code>    for(ll i=1;(1ll&lt;&lt;i)&lt;=m-1;i++)&#123;        (ercnt+=(m-1)/(1ll&lt;&lt;i));    &#125;</code></pre><p>例如$1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$这个序列</p><p>分别有$(2^1)*2$,$(2^2)*1$,$(2^3)*1$那么就是$8&#x2F;8+8&#x2F;4+8&#x2F;2$</p><p>可以看作$&#x2F;2$时给所有有$2$因子填上一个二(即$2$,$4$,$6$,$8$中填一个2),此时$4$还剩$1$个没填$8$还剩$2$个没填</p><p>$&#x2F;4$给$4$,$8$里填此时$8$还剩$1$个没填</p><p>最后$&#x2F;8$,全部填满</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod=1e6+3;const ll phi=1e6+2;ll x,y,n,m;ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;int main()&#123;//    freopen(&quot;sd.txt&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);/*    if(log(m)&gt;n)&#123;        printf(&quot;1 1\n&quot;);        return 0;    &#125;*/    ll maxn=meng(2,n%phi);    y=meng(maxn,m%phi);    x=1;    ll ercnt=n;        for(ll i=0;i&lt;m;i++)&#123;//        printf(&quot;maxn-i=%lld i=%lld m=%lld x=%lld\n&quot;,maxn-i,i,m,x);        x=x*(maxn-i)%mod;        if(!x) break;    &#125;//2逆元500002    for(ll i=1;(1ll&lt;&lt;i)&lt;=m-1;i++)&#123;        (ercnt+=(m-1)/(1ll&lt;&lt;i));        printf(&quot;ercnt=%lld 1&lt;&lt;=%lld\n&quot;,ercnt-n,1ll&lt;&lt;i);    &#125;    y=y*meng(500002,ercnt)%mod;    x=x*meng(500002,ercnt)%mod;    printf(&quot;%lld %lld\n&quot;,(y-x+mod)%mod,y);&#125;</code></pre><p>View Code</p><h2 id="简单的填数"><a href="#简单的填数" class="headerlink" title="简单的填数"></a>简单的填数</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>一个$up$代表填的上界,$down$代表填的下界</p><p>先不考虑已经填了的</p><p>$up$两位一进,$down$五位一进</p><p>考虑已经填的</p><p>先考虑上界</p><p>若$a[i]&gt;up$比上界大肯定不合法</p><p>若$a[i]&#x3D;up$取$min(2,up)$</p><p>若$a[i]&lt;up$则将$up$调整到$a[i]$次数变为$2$</p><p>下界类似</p><p>若$a[i]&lt;down$比下界小不合法</p><p>若$a[i]&gt;down$将$down$调整到$a[i]$</p><p>统计答案时反着扫</p><p>序列为什么不是$up$呢</p><pre><code>70 0 0 2 0 2 0 正解21 1 2 2 2 2 2 用up:21 1 2 2 3 2 2 </code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>/*70 0 0 2 0 2 0 hack21 1 2 2 2 2 2 up:21 1 2 2 3 2 2 10f*/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101struct node &#123;    ll cnt,x;&#125;up[A],down[A];ll n;ll a[A],tong[A];int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin); freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);    &#125;    if(a[1]!=1&amp;&amp;a[1]!=0)&#123;        printf(&quot;-1\n&quot;);        return 0;    &#125;    up[1].cnt=1,up[1].x=1;    down[1].cnt=1,down[1].x=1;    for(ll i=2;i&lt;=n;i++)&#123;        up[i]=up[i-1],down[i]=down[i-1];        if(++up[i].cnt&gt;2) up[i].cnt=1,up[i].x++;        if(++down[i].cnt&gt;5) down[i].cnt=1,down[i].x++;        if(a[i])&#123;            if(up[i].x&gt;a[i])&#123;                up[i].x=a[i];                up[i].cnt=2;            &#125;            else if(up[i].x==a[i])&#123;                up[i].cnt=min(up[i].cnt,2ll);            &#125;            if(down[i].x&lt;a[i])                down[i].x=a[i],down[i].cnt=1;            if(up[i].x&lt;a[i]||down[i].x&gt;a[i])&#123;                printf(&quot;-1\n&quot;);                return 0;            &#125;        &#125;    &#125;    if(up[n].cnt==1)&#123;        up[n].x=up[n-1].x;    &#125;    if(up[n].x&lt;down[n].x)&#123;        printf(&quot;-1\n&quot;);        return 0;    &#125;    printf(&quot;%lld\n&quot;,up[n].x);    tong[up[n].x]=1;    a[n]=up[n].x;    for(ll i=n-1;i&gt;=1;i--)&#123;        if(!a[i])&#123;            ll t=min(a[i+1],up[i].x);            if(tong[t]==5) t--;            a[i]=t;        &#125;        tong[a[i]]++;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        printf(&quot;%lld &quot;,a[i]);    &#125;&#125;</code></pre><p>View Code</p><h2 id="简单的序列"><a href="#简单的序列" class="headerlink" title="简单的序列"></a>简单的序列</h2><p>这是一个简单$dp$,但我觉得很棒在此写下题解</p><p>真的非常简单,</p><p>有一个长度$n$括号序列(只有$”()”$ ),给定其中长度为$m$一段,求满足括号匹配方案数</p><p>$n,m&lt;&#x3D;1e6$ $n-m&lt;&#x3D;4000$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>性质:我们发现一个合法匹配序列左扩号时刻比右括号多(显然),最后左扩号数量等于右括号数量</p><p>设$f[i][j]$表示长度为$i$序列,左扩号比右括号多$j$个方案数</p><p>那么类似的设$g[i][j]$为右括号比左扩号多$j$的方案数</p><p>(其实$f$和$g$值完全一样)</p><p>转移非常简单</p><p>当前括号可能是$($则贡献$f[i][j]&#x3D;f[i-1][j-1]$为$)$则$f[i][j]&#x3D;f[i-1][j+1]$</p><p>总贡献$f[i][j]&#x3D;f[i-1][j-1]+f[i-1][j+1]$</p><p>类似的$g[i][j]&#x3D;g[i-1][j-1]+g[i-1][j+1]$</p><p>那么思考统计答案</p><p>其实也非常简单</p><p>枚举第一段长度$i$,第一段左扩号比右括号多$j$,设给定序列左扩号比右括号多$j$</p><p>$ans&#x3D;\sum\limits_{i&#x3D;1}^{i&lt;&#x3D;n-m} \sum\limits_{j&#x3D;0}^{j&lt;&#x3D;i}<br>f[i][j]*g[(n-m)-i][j+tot]$</p><p>注意判是否合法</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 4040const ll mod=1e9+7;char c[2020202];ll f[A][A];ll tot,mint,n,m,ans;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin); freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    scanf(&quot;%s&quot;,c+1);    for(ll i=1;i&lt;=m;i++)&#123;        if(c[i]==&#39;(&#39;)            tot++;        else tot--;        if(i==1) mint=tot;        else mint=min(mint,tot);    &#125;    f[0][0]=1;    for(ll i=1;i&lt;=n-m;i++)&#123;        for(ll j=0;j&lt;=i;j++)&#123;            if(j==0) f[i][j]=f[i-1][j+1];            else f[i][j]=(f[i-1][j+1]+f[i-1][j-1])%mod;        &#125;    &#125;    for(ll i=0;i&lt;=n-m;i++)&#123;        for(ll j=0;j&lt;=i;j++)&#123;            if(j+mint&gt;=0&amp;&amp;j+tot&lt;=n-m)                ans=(ans+f[i][j]*f[(n-m)-i][j+tot]%mod)%mod;        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>我没数据,也没法提交,和$std$对拍了一下</p><p>下面是我的数据生成及对拍</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 int main()&#123; 4     system(&quot;g++ bf.cpp -o bf&quot;); 5     system(&quot;g++ sol.cpp -o sol&quot;); 6     system(&quot;g++ da.cpp -o da&quot;); 7     int rp=0; 8     while(++rp)&#123; 9         cout&lt;&lt;rp&lt;&lt;&quot; &quot;;10         system(&quot;./da&quot;);11         system(&quot;./sol&quot;);12         system(&quot;./bf&quot;);13         if(system(&quot;diff -B -b ans.sol ans.bf&quot;))&#123;14             puts(&quot;WA&quot;);15             while(1);16         &#125;17         puts(&quot;AC&quot;);18     &#125;19 &#125;</code></pre><p>对拍</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 int main()&#123; 4     freopen(&quot;da.in&quot;,&quot;w&quot;,stdout); 5     srand(time(NULL)); 6      7     int m=rand()%10000+300; 8     int c=rand()%m+1; 9     while(m-c&gt;2000)&#123;10         c=rand()%m+1;11     &#125;12     cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;13     for(int i=1;i&lt;=c;i++)&#123;14         if(rand()%2)&#123;15             printf(&quot;(&quot;);16         &#125;17         else printf(&quot;)&quot;);18     &#125;19     cout&lt;&lt;endl;20 &#125;</code></pre><p>数据生成</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190906135427887-1953220853.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lcis</title>
      <link href="/2025/03/14/lcis/"/>
      <url>/2025/03/14/lcis/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-06 18:55</p><p>关于$dp$数组定义的思考</p><p>$lcis$最简单定义$f[x][y]$表示以$x$,$y$结尾的最长子序列,$n^4$看上去很难优化</p><p>$lcs$本来也是$n^4$回忆怎么优化的,$f[x][y]$原本表示以$x$,$y$结尾的最长子序列,然而数组定义稍微改变一下表示枚举到$x$,$y$为止的最长子序列,定义成了类似于最长前缀的性质</p><p>$f[x][y]&#x3D;max(f[x][y-1],f[x-1][y])$再$f[x][y]&#x3D;max(f[x][y],f[x-1][y-1]+1)$为什么这样定义,我们并不关心之前转移具体是多少,我们要找的是之前最大的,我们并不关心之前状态是什么,所以这样定义是对的,</p><p>$lcis$也可以用这个优化一下,但不能完全定义成前缀最大值,我们要保证公共的前提下还要保证单调上升,但我们注意到$i,j$表示相同,那么我们可以舍弃掉一维来优化</p><p>$f[i][j]$定义成在$A_1-A_i$ 以$B_j$为结尾的最长公共子序列是多少</p><p>考虑转移</p><p>$f[i][j]&#x3D;f[i-1]<a href="if(b%5Bj%5D!=a%5Bi%5D)">j</a>$当前点不是合法转移点,直接继承</p><p>$f[i][j]&#x3D;max(f[i-1][k])+1(b[k]&lt;b[j])$又$b[j]&#x3D;&#x3D;a[i]$(当前点)则$f[i][j]&#x3D;max(f[i-1][k])+1(b[k]&lt;a[i])$</p><p>然后考虑再次优化,再拿一个最大前缀优化即可</p><p>事实上,我之前做过类似定义的,一个树上$dp$叫消防局的建立,优化也是这样优化,自己做题就像没有任何收获</p><p>遇到题,不要一味看题解,抄代码,多思考,是做一名合格$oier$所需的,这些我都没做到自己码力越来越弱,又越来越颓废,我沦落到现在这个底部是罪有应得,但还是希望自己以后能够金盆洗手,改过自新</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jzoj5195 数的划分</title>
      <link href="/2025/03/14/jzoj5195%20%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86/"/>
      <url>/2025/03/14/jzoj5195%20%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-07 06:32</p><p>$n$个 <em><strong>相同</strong></em> 球放$m$<em><strong>相同</strong></em> 方案</p><p>我太弱了,一开始以为是隔板法,后来以为斯特林,</p><p>然后隔板法是相同球不同盒子,</p><p>斯特林是不同球相同盒子</p><p>所以这个题$dp$,相同球,相同盒子会出现一些乱子(2 1 1 )( 1 1 2 )是相同方案</p><p>我们强迫每个盒子放的球有序$x_1&gt;&#x3D;x_2&gt;&#x3D;x_3&gt;&#x3D;x_4&gt;&#x3D;x_5$那么这样我们可以避免算重</p><p>定义$f[i][j]$为前$i$个球放$j$个盒子方案数</p><p>考虑转移</p><p>1.如果新建一个一个盒子一定是满足条件的前面盒子中球的数量一定比当前大$f[i][j]+&#x3D;f[i-1][j-1]$</p><p>2.如果不新建我们同时往所有盒子里放1个球仍然可以保证$x_1&gt;&#x3D;x_2&gt;&#x3D;x_3…….&gt;&#x3D;x_n$</p><p>这样并不会算少,往所有盒子里放一个球是囊扩所有情况的</p><p>比如我一开始有个疑问,</p><p>例如现在第一个盒子放$5$个球,第二个盒子放$4$个球,第三个放$1$个球</p><p>情况2中为什么不能往第一个盒子放$2$个球,第二个放$2$个球,第三个放$1$个等等,为什么必须是全放$1$个</p><p>这种情况被第一个盒子$6$个球,第二个盒子放$5$个球,第三个放$1$个球,然后所有盒子再放一个球考虑到了</p><p><em><strong>全放一个是至少的情况</strong></em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hash表及带注释插头dp</title>
      <link href="/2025/03/14/hash%E8%A1%A8%E5%8F%8A%E5%B8%A6%E6%B3%A8%E9%87%8A%E6%8F%92%E5%A4%B4dp/"/>
      <url>/2025/03/14/hash%E8%A1%A8%E5%8F%8A%E5%B8%A6%E6%B3%A8%E9%87%8A%E6%8F%92%E5%A4%B4dp/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-28 15:36</p><pre><code>struct hash_map&#123;    node s[SZ+10];int e,adj[SZ+10];    inline void init()&#123;e=0;memset(adj,0,sizeof(adj));&#125;    inline void update(LL state,int val,int cnt)    &#123;        RG int i,pos=(state%SZ+(LL)val*SZ)%SZ;        for(i=adj[pos];i&amp;&amp;(s[i].state!=state||s[i].val!=val);i=s[i].next);        if(!i)s[++e].state=state,s[e].val=val,s[e].cnt=cnt,s[e].next=adj[pos],adj[pos]=e;        else s[i].cnt=(s[i].cnt+cnt)%mod;    &#125;    inline void find(LL state,int val)    &#123;        RG int i,pos=(state%SZ+(LL)val*SZ)%SZ;        for(i=adj[pos];i&amp;&amp;(s[i].state!=state||s[i].val!=val);i=s[i].next);        if(!i)printf(&quot;no such val\n&quot;);        else printf(&quot;cnt=%d\n&quot;,s[i].cnt);    &#125;&#125;f[2];#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1100000#define mod 299989#define P 8#define N 100000000ll n,m;inline ll find(ll state,ll id)&#123;    return (state&gt;&gt;((id-1)&lt;&lt;1))&amp;3;&#125;//看当前插头究竟是什么插头//因为是四进制每两位代表一个状态struct bignum&#123;    ll n[10],l;    bignum()&#123;l=1,memset(n,0,sizeof(n));&#125;    void clear()&#123;while(l&gt;1&amp;&amp;!n[l-1]) l--;&#125;    void print()&#123;        printf(&quot;%lld&quot;,n[l-1]);        for(ll i=l-2;i&gt;=0;i--)            printf(&quot;%0*lld&quot;,P,n[i]);        printf(&quot;\n&quot;);    &#125;    bignum operator +(bignum x)const&#123;        bignum t=*this;        if(t.l&lt;x.l) t.l=x.l;        t.l++;        for(ll i=0;i&lt;t.l;i++)&#123;            t.n[i]+=x.n[i];            if(t.n[i]&gt;=N)&#123;                t.n[i+1]+=t.n[i]/N;                t.n[i]%=N;            &#125;        &#125;        t.clear();        return t;    &#125;    bignum operator =(ll x)&#123;        l=0;        while(x)&#123;            n[l++]=x%N;            x/=N;        &#125;        return *this;    &#125;    inline void operator +=(bignum b)&#123;*this=*this+b;&#125;&#125;Ans;struct hash_map&#123;    bignum val[mod];    ll key[A],hash[mod],size;    inline void init()&#123;        memset(val,0,sizeof(val));        memset(key,-1,sizeof(key));size=0;        memset(hash,0,sizeof(hash));    &#125;    inline void newhash(ll id,ll v)&#123;hash[id]=++size;key[size]=v;&#125;    bignum &amp;operator [] (const ll &amp;state)&#123;        for(ll i=state%mod;;i=(i+1==mod)?0:i+1)        &#123;            if(!hash[i]) newhash(i,state);            if(key[hash[i]]==state) return val[hash[i]];        &#125;    &#125;&#125;f[2];inline void Set(ll &amp;state,ll bit,ll val)&#123;    bit=(bit-1)&lt;&lt;1;    state|=3&lt;&lt;bit;    state^=3&lt;&lt;bit;    //把state高位先赋成0再把它赋成别的    state|=val&lt;&lt;bit;    //state表示状态    //因为插头的编号为0--m所以bit要-1    //因为是四进制,所以3&lt;&lt;    //全都是4进制    //2&lt;&lt;bit    //1&lt;&lt;bit    //貌似还能理解    //每两位代表一个具体状态&#125;ll link(ll state,ll pos)&#123;    //找到对应的插头(用括号匹配的方式)然后    ll cnt=0,delta=(find(state,pos)==1)?1:-1;    //如果是左括号应该向右寻找右括号    //如果是右括号应该向左寻找左括号    for(ll i=pos;i&amp;&amp;i&lt;=m+1;i+=delta)//一共m+1个插头    &#123;        ll plug=find(state,i);        if(plug==1)            cnt++;//左括号数量++        else if(plug==2)            cnt--;//右括号数量++        if(cnt==0)//当左括号数量与右括号数量相等时找到匹配             return i;//找到了与当前插头对应的插头    &#125;    return -1;    //当前状态是非法的找不到与之对应的插头&#125;inline void education(ll x,ll y)&#123;    ll now=((x-1)*m+y)&amp;1,last=now^1,tot=f[last].size;    f[now].init();    for(ll i=1;i&lt;=tot;i++)&#123;//        printf(&quot;i=%lld\n&quot;,i);        ll state=f[last].key[i];//key状态        bignum Val=f[last].val[i];//取出上一次权值（方案数）        ll plug1=find(state,y),plug2=find(state,y+1);        //0--m编号,寻找轮廓线上编号y-1,y对应的插头        //至于为什么是y y+1,因为在上面函数里进行了减1        //编号为y-1是左右插头,y代表上下插头        if(link(state,y)==-1||link(state,y+1)==-1)            continue;        //当前括号无法找到匹配无解        if(!plug1&amp;&amp;!plug2)&#123;            if(x!=n&amp;&amp;y!=m)&#123;        //如果没有插头,直接拽过来两个插头相连(此题保证必须连通)                Set(state,y,1);                //在轮廓线上位置为y-1添加一个左括号                Set(state,y+1,2);                //y位置添加一个右括号                f[now][state]+=Val;            &#125;        &#125;        else if(plug1&amp;&amp;!plug2)&#123;        //拥有左右插头没有上下插头        //两种转移方式,转弯向下走        //这样插头状态不变            if(x!=n)                f[now][state]+=Val;        //向右连接一个插头        //向右推进要发生改变            if(y!=m)&#123;                Set(state,y,0);                Set(state,y+1,plug1);                f[now][state]+=Val;            &#125;        &#125;        else if(!plug1&amp;&amp;plug2)&#123;        //拥有上下插头而没有左右插头        //两种转移方式,向右转移        //这样插头状态不变            if(y!=m)                f[now][state]+=Val;        //向右连接一个插头            if(x!=n)&#123;                Set(state,y,plug2);                Set(state,y+1,0);                //plug2是左右插头让上下方向转弯                f[now][state]+=Val;            &#125;        &#125;        else if(plug1==1&amp;&amp;plug2==1)&#123;            //两个左括号插头相连接,然后让最靠左的右括号插头变成左括号插头            Set(state,link(state,y+1),1);            Set(state,y,0);            Set(state,y+1,0);            f[now][state]+=Val;        &#125;        else if(plug1==1&amp;&amp;plug2==2)&#123;            //右插头是左括号插头,上插头是右括号插头,连在一起            //构成回路            if(x==n&amp;&amp;y==m)                Ans+=Val;        &#125;        else if(plug1==2&amp;&amp;plug2==1)&#123;            //无脑合并            Set(state,y,0);            Set(state,y+1,0);            f[now][state]+=Val;        &#125;        else if(plug1==2&amp;&amp;plug2==2)&#123;            //当你有左右插头右括号插头,上下插头为右插头            //合并为1,将最靠右左插头变为右插头            Set(state,link(state,y),2);            Set(state,y,0);            Set(state,y+1,0);            f[now][state]+=Val;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    if(n==1||m==1)&#123;printf(&quot;1\n&quot;);return 0;&#125;    if(m&gt;n) swap(n,m);    f[0].init();f[0][0]=1;    for(ll i=1;i&lt;=n;i++)    &#123;        for(ll j=1;j&lt;=m;j++)                education(i,j);        if(i!=n)&#123;            ll now=(i*m)&amp;1,tot=f[now].size;            for(ll j=1;j&lt;=tot;j++)                f[now].key[j]&lt;&lt;=2;        &#125;    &#125;    Ans+=Ans;    Ans.print();&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HAOI2008 木棍分割 数据结构优化dp+二分答案</title>
      <link href="/2025/03/14/HAOI2008%20%E6%9C%A8%E6%A3%8D%E5%88%86%E5%89%B2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96dp+%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
      <url>/2025/03/14/HAOI2008%20%E6%9C%A8%E6%A3%8D%E5%88%86%E5%89%B2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96dp+%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-02 16:34</p><p>很久之前打的题，现在补篇博客</p><p>打滚动数组</p><p>[  </p><table><thead><tr><th>#E. 木棍分割](<a href="http://hzoj.com:8005/contest/45/problem/5">http://hzoj.com:8005/contest/45/problem/5</a>)</th><th><a href="http://hzoj.com:8005/contest/submission/60456"> Accepted</a></th><th>100</th><th>1712 ms</th><th>1512 KiB</th><th></th><th>2019-05-07 17:01:23</th></tr></thead></table><p>Short 不打滚动数组</p><table><thead><tr><th><a href="http://hzoj.com:8005/problem/419">#419. [HAOI2008]木棍分割</a></th><th><a href="http://hzoj.com:8005/contest/submission/60448"> Accepted</a></th><th>100</th><th>5219 ms</th><th>100960 KiB</th><th></th><th>2019-05-07 15:12:41</th></tr></thead></table><p>木棍分割 题解</p><h1 id="木棍分割"><a href="#木棍分割" class="headerlink" title="木棍分割"></a><strong>木棍分割</strong></h1><p><strong>内存限制： 128 MiB时间限制：3000 ms标准输入输出</strong></p><p><strong>题目类型：传统评测方式：文本比较</strong></p><p><strong>提交</strong><a href="http://hzoj.com:8005/contest/45/submissions?problem_id=5"><strong>提交记录</strong></a><a href="http://hzoj.com:8005/contest/45"><strong>返回比赛</strong></a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h4><p>有n根木棍, 第i根木棍的长度为Li,n根木棍依次连结了一起, 总共有n-1个连接处. 现在允许你最多砍断m个连接处,<br>砍完后n根木棍被分成了很多段,要求满足总长度最大的一段长度最小, 并且输出有多少种砍的方法使得总长度最大的一段长度最小.</p><p>并将结果mod 10007。。。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h4><p>输入文件第一行有2个数n,m.接下来n行每行一个正整数Li,表示第i根木棍的长度.n&lt;&#x3D;50000,0&lt;&#x3D;m&lt;&#x3D;min(n-1,1000),1&lt;&#x3D;Li&lt;&#x3D;1000.</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h4><p>输出有2个数, 第一个数是总长度最大的一段的长度最小值, 第二个数是有多少种砍的方法使得满足条件.</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a><strong>样例</strong></h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a><strong>样例输入</strong></h4><p>3 2</p><p>1</p><p>1</p><p>10</p><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a><strong>样例输出</strong></h4><p>10 2</p><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a><strong>数据范围与提示</strong></h4><p>两种砍的方法: (1)(1)(10)和(1 1)(10)</p><p>二分答案+dp滚动数组</p><p>第一步 二分答案求长度</p><p>每次枚举木棍可以分成的值下界为所有木棍最小值上界为所有木棍最大值</p><p>当 当前值可以分成的时候，比它小的值可能可以分成故让当前r&#x3D;mid-1</p><p>当 当前值不可以分成的时候比它大的值可能分成故让l&#x3D;mid+1</p><p>当r&gt;mid时得到最终答案</p><p>然后find函数检验当前值是否可以分成</p><p>具体操作：枚举！</p><p>初始化add&#x3D;0，指针&#x3D;0，块数&#x3D;0；</p><p>只需要扫一遍当add&lt;&#x3D;x的时候直接在add加上当前这个值；否则令分成的块数++ 并且令add值重新附成当前指针指向的木棍长度</p><p>值得注意的一点是 当指针已经指向最后一个数的时候 若add不为0 块数需要+1</p><p>最后比较块数与m即可</p><p>第二步 dp求方案数</p><p>首先暴力枚举求方案数肯定会超时,很自然的想到统计方案需要用dp</p><p>首先想要至少开二维 当前切割位置可能由任何满足之间木棍长度之和&lt;&#x3D;第一步求得的答案 的切割位置转移过来</p><p>需要枚举每一根木棍（枚举当前切割的位置） ，每一个前一个切割的位置，和切割的次数</p><p>可以看到是n2*m复杂度 还不如打一个暴力 同样是t掉</p><p>dp暴力转移式$f[i][j]+&#x3D;f[k]<a href="if(sum%5Bi%5D-sum%5Bk-1%5D%3C=maxn">j-1</a>$</p><p>善良的出题人肯定不会让你AC的</p><p>你会得到0分的好成绩</p><table><thead><tr><th><a href="http://hzoj.com:8005/contest/submission/60421"> Time Limit Exceeded</a></th><th>0</th><th>30150 ms</th></tr></thead></table><p>然后我们要考虑一些优化</p><p>我们可以看到事实上一些位置是加重了的</p><p>在每一个切割次数下要枚举一遍k 每次都枚举了k 但事实上每个木棍长是始终不变的</p><p>每次枚举一遍就太区区了</p><p>我们需要一个数据结构来快速查询每一段所代表的值并且维护一个before数组代表在其之前最长的一段&lt;&#x3D;第一步求的答案</p><p>before可以暴力去求也可以用 lower_bound</p><p>for(ll i&#x3D;1;i&lt;&#x3D;n;i++)</p><p>last[i]&#x3D;lower_bound(sum+1,sum+i+1,sum[i]-cun)-sum;</p><p>理解一下</p><p>例如 9 3</p><p>5 4 3 2 1 2 3 4 5</p><p>这一组数据对应 before为</p><p>1 1 1 1 2 2 3 5 7</p><p>cun&#x3D;7；</p><p>sum 值 5 9 12 14 15 17 20 24 29</p><p>对应下标 1 2 3 4 5 6 7 8 9</p><p>last[1]&#x3D;1 sum[1]-cun&#x3D;-4</p><p>last[2]&#x3D;1 sum[2]-cun&#x3D;0</p><p>last[3]&#x3D;1 sum[3]-cun&#x3D;3</p><p>last[4]&#x3D;1 sum[4]-cun&#x3D;5</p><p>last[5]&#x3D;2 sum[5]-cun&#x3D;6</p><p>last[6]&#x3D;2 sum[6]-cun&#x3D;8</p><p>last[7]&#x3D;3 sum[7]-cun&#x3D;11</p><p>last[8]&#x3D;5 sum[8]-cun&#x3D;15</p><p>last[9]&#x3D;7 sum[9]-cun&#x3D;20</p><p>lower_查到的下标 事实就是sum[i]-sum[now]&lt;&#x3D;cun 其实还是挺好理解的</p><p>然后就是数据结构</p><p>事实上 考虑到区间查值 我们可以用前缀和（当然树状数组不行 并没有单点修改仅仅是每次要查值而已 前缀和维护是o(1) 树状数组o(logn)）</p><p>然后dp就完了</p><p>代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define re register#define i_ inline #define huan cout&lt;&lt;endl#define ll int#define A 50010ll n,m,before[A],a[A],maxx=-1,last[A],sum[A],su[A],jilu;short f[50101][2];using namespace std;#define mod 10007inline ll read()&#123;    ll f=1,x=0;char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    &#123;        if(ch==&#39;-&#39;) f=-1;        ch=getchar();    &#125;    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    &#123;        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);        ch=getchar();    &#125;    return f*x;&#125;i_ bool find(ll x)&#123;    ll zhizhen=0,zan=0,add=0,dangqian;    if(x&lt;maxx)        return false;    while(zhizhen&lt;=n)    &#123;        zhizhen++;        if(add+a[zhizhen]&lt;=x)        &#123;            add+=a[zhizhen];        &#125;        else         &#123;            zan++;            add=a[zhizhen];            dangqian=zhizhen;        &#125;    &#125;    if(add!=0)        zan++;    return (zan&lt;=m?1:0);&#125;i_ ll er()&#123;    ll l=0,r=sum[n],mid,ans;    while(l&lt;=r)    &#123;        mid=(l+r)&gt;&gt;1;        if(find(mid)==1)            ans=mid,r=mid-1;        else             l=mid+1;    &#125;//    printf(&quot;m=%lld\n&quot;,jilu);    return ans;&#125;void tiaos(bool x)&#123;    printf(&quot;记录=%lld\n&quot;,jilu);    if(x)    &#123;        for(ll i=1;i&lt;=n;i++)            printf(&quot;last[%lld]=%lld &quot;,i,last[i]);        cout&lt;&lt;endl;        for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))            for(ll j=0;j&lt;=m;j++)                printf(&quot;f[%lld][%lld]=%lld  &quot;,i,j,f[i][j]);        return ;    &#125;    else     &#123;        for(ll i=1;i&lt;=n;i++,puts(&quot;&quot;))            for(ll j=0;j&lt;=m;j++)                printf(&quot;f[%lld][%lld]=%lld  &quot;,i,j,f[i][j]);    &#125;&#125;int main()&#123;    //    freopen(&quot;out.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;wrong.out&quot;,&quot;w&quot;,stdout);    n=read(),m=read();    m+=1;    for(ll i=1;i&lt;=n;i++)    &#123;        a[i]=read();        sum[i]=sum[i-1]+a[i];        maxx=max(a[i],maxx);    &#125;    ll cun=er(),zhe=1;    m=m-1;    ll uscao=0;    for(ll i=1;i&lt;=n;i++)    &#123;        if(sum[i]&gt;cun) break;        else f[i][0]=1;    &#125;    for(ll i=1;i&lt;=n;i++)        last[i]=lower_bound(sum+1,sum+i+1,sum[i]-cun)-sum;    for(ll j=1;j&lt;=m;j++)    &#123;        for(ll i=1;i&lt;=n;i++)            su[i]=su[i-1]+f[i][j&amp;1^1],f[i][j&amp;1]=0;        for(ll i=j+1;i&lt;=n;i++)            f[i][j&amp;1]=(f[i][j&amp;1]+su[i-1]-su[last[i]-1])%mod;        uscao=(uscao+f[n][j&amp;1])%mod;    &#125;//    tiaos(1);    cout&lt;&lt;cun&lt;&lt;&quot; &quot;&lt;&lt;uscao;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gdoi2018&amp;jzoj5698  密码锁</title>
      <link href="/2025/03/14/gdoi2018&amp;jzoj5698%20%20%E5%AF%86%E7%A0%81%E9%94%81/"/>
      <url>/2025/03/14/gdoi2018&amp;jzoj5698%20%20%E5%AF%86%E7%A0%81%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-14 11:47</p><p>每次可以给一段序列+1\-1,若&lt;0变为m-1,若&#x3D;m变为0</p><p>问最后序列全变为0,最少操作数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>正解,差分,</p><p>不差分真的很难做,这里差分是用的差分数组$dif[i]&#x3D;a[i]-a[i-1]$然后我们操作就转化成了在$dif$上$+1,-1$</p><p>具体看图片,来自<a href="https://blog.csdn.net/qq_36551189/article/details/80204514">https://blog.csdn.net/qq_36551189/article/details/80204514</a></p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191014114410452-529701510.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>e[树上主席树]</title>
      <link href="/2025/03/14/e%5B%E6%A0%91%E4%B8%8A%E4%B8%BB%E5%B8%AD%E6%A0%91%5D/"/>
      <url>/2025/03/14/e%5B%E6%A0%91%E4%B8%8A%E4%B8%BB%E5%B8%AD%E6%A0%91%5D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-12 20:58</p><p>主席树掌握不牢啊</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191011175240556-313794341.png"></p><p>之前那棵树继承父亲的树就行了</p><p>挺难打的，细节很多，具体还是看代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ls(x) tr[x].son[0]#define rs(x) tr[x].son[1]#define A 1111111ll head[A],ver[A],nxt[A],a[A],f[A][25],dep[A],rt[A],r[A],k[A];ll q,n,type,t,anspre,ansnxt,maxx=0,tot=1;void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;struct node&#123;    ll son[2],sz;&#125;tr[A*8];void insert(ll &amp;x,ll v,ll num,ll l,ll r)&#123;    if(!x) x=++tot;    if(l==r)&#123;        tr[x].sz=tr[v].sz+1;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    ll opt=num&gt;mid,L,R;    tr[x].son[opt^1]=tr[v].son[opt^1];    if(opt) L=mid+1,R=r;    else L=l,R=mid;    insert(tr[x].son[opt],tr[v].son[opt],num,L,R);    tr[x].sz=tr[ls(x)].sz+tr[rs(x)].sz;&#125;ll lca(ll x,ll y)&#123;    if(dep[x]&gt;dep[y]) swap(x,y);    for(ll i=t;i&gt;=0;i--)&#123;        if(dep[x]==dep[y]) break;        if(dep[x]&lt;=dep[f[y][i]]) y=f[y][i];    &#125;    if(x==y) return x;    for(ll i=t;i&gt;=0;i--)&#123;        if(f[x][i]!=f[y][i])&#123;            x=f[x][i];y=f[y][i];        &#125;    &#125;    return f[x][0];&#125;void dfs(ll x,ll pre)&#123;    insert(rt[x],rt[pre],a[x],1,maxx);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        f[y][0]=x;        dep[y]=dep[x]+1;                dfs(y,x);    &#125;&#125;void findpre(ll x,ll v,ll l,ll r)&#123;//    printf(&quot;tr[x].sz=%lld v.sz=%lld x=%lld v=%lld\n&quot;,tr[x].sz,tr[v].sz,x,v);    if(!(tr[x].sz-tr[v].sz)) return ;    if(l==r)&#123;//        printf(&quot;***l=%lld r=%lld\n&quot;,l,r);        anspre=max(l,anspre);        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;//    printf(&quot;pre x.sz=%lld .sz=%lld rs.sz=%lld .sz=%lld l=%lld r=%lld mid+1=%lld r=%lld\n&quot;,tr[x].sz,tr[v].sz,tr[rs(x)].sz,tr[rs(x)].sz,l,r,mid+1,r);    if(tr[rs(x)].sz-tr[rs(v)].sz) /*printf(&quot;findr\n&quot;),*/findpre(rs(x),rs(v),mid+1,r);    else if(tr[ls(x)].sz-tr[ls(v)].sz) /*printf(&quot;findl\n&quot;),*/findpre(ls(x),ls(v),l,mid);&#125;void findnxt(ll x,ll v,ll l,ll r)&#123;    if(!(tr[x].sz-tr[v].sz)) return ;    if(l==r) &#123;//        printf(&quot;*********l=%lld r=%lld\n&quot;,l,r);        ansnxt=min(l,ansnxt);        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;//    printf(&quot;nxt x.sz=%lld .sz=%lld rs.sz=%lld .sz=%lld l=%lld mid=%lld mid+1=%lld r=%lld\n&quot;,tr[x].sz,tr[v].sz,tr[rs(x)].sz,tr[rs(x)].sz,l,mid,mid+1,r);    if(tr[ls(x)].sz-tr[ls(v)].sz) findnxt(ls(x),ls(v),l,mid);    else if(tr[rs(x)].sz-tr[rs(v)].sz) findnxt(rs(x),rs(v),mid+1,r);&#125;void chosepre(ll x,ll v,ll ql,ll qr,ll l,ll r)&#123;//    printf(&quot;l=%lld r=%lld ql=%lld qr=%lld\n&quot;,l,r,ql,qr);//    printf(&quot;l=%lld r=%lld\n&quot;,l,r);    if(l&gt;=ql&amp;&amp;r&lt;=qr)&#123;//        printf(&quot;chose l=%lld r=%lld\n&quot;,l,r);        findpre(x,v,l,r);        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;//    printf(&quot;l=%lld r=%lld mid=&quot;)    if(mid&gt;=ql) chosepre(ls(x),ls(v),ql,qr,l,mid);    if(mid&lt;qr) chosepre(rs(x),rs(v),ql,qr,mid+1,r);&#125;void chosenxt(ll x,ll v,ll ql,ll qr,ll l,ll r)&#123;    if(l&gt;=ql&amp;&amp;r&lt;=qr)&#123;        findnxt(x,v,l,r);        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    if(mid&gt;=ql) chosenxt(ls(x),ls(v),ql,qr,l,mid);    if(mid&lt;qr) chosenxt(rs(x),rs(v),ql,qr,mid+1,r);&#125;ll lsh[A];vector &lt;ll&gt; que[A];int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.sol&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;q,&amp;type);    t=log(n)/log(2)+1;    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]),lsh[++lsh[0]]=a[i];    for(ll i=1;i&lt;n;i++)&#123;        ll x,y;        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);        add(x,y);    &#125;    for(ll i=1;i&lt;=q;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;r[i],&amp;k[i]);        que[i].push_back(0);        for(ll j=1;j&lt;=k[i];j++)&#123;            ll d;scanf(&quot;%lld&quot;,&amp;d);            que[i].push_back(d);        &#125;        lsh[++lsh[0]]=r[i];//        printf(&quot;i=%lld q=%lld\n&quot;,i,q);    &#125;    sort(lsh+1,lsh+lsh[0]+1);    ll len=unique(lsh+1,lsh+lsh[0]+1)-lsh-1;    for(ll i=1;i&lt;=n;i++)&#123;//        printf(&quot;pre a[i]=%lld\n&quot;,a[i]);        a[i]=lower_bound(lsh+1,lsh+len+1,a[i])-lsh;//        printf(&quot;a[i]=%lld\n&quot;,a[i]);    &#125;    for(ll i=1;i&lt;=q;i++)&#123;//        printf(&quot;pre r[i]=%lld\n&quot;,r[i]);        r[i]=lower_bound(lsh+1,lsh+len+1,r[i])-lsh;//        printf(&quot;r[i]=%lld\n&quot;,r[i]);    &#125;    maxx=len;    dep[1]=1;    dfs(1,0);f[1][0]=0;    for(ll j=1;j&lt;=t;j++)        for(ll i=1;i&lt;=n;i++)            f[i][j]=f[f[i][j-1]][j-1];    ll lastans=0;    //    printf(&quot;lsh[0]=%lld\n&quot;,lsh[0]);    for(ll i=1;i&lt;=q;i++)&#123;        for(ll j=1;j&lt;=k[i];j++)            que[i][j]=(que[i][j]-1+lastans*type)%n+1;        ll publiclca=que[i][k[i]];        for(ll j=1;j&lt;k[i];j++)            publiclca=lca(publiclca,que[i][j]);        ansnxt=0x7ffffffff,anspre=0;        ll fa=f[publiclca][0];//        printf(&quot;lca=%lld\n&quot;,publiclca);        for(ll j=1;j&lt;=k[i];j++)&#123;//            printf(&quot;rt[%lld]=%lld rt[%lld]=%lld\n&quot;,que[j],rt[que[j]],fa,rt[fa]);            chosepre(rt[que[i][j]],rt[fa],1,r[i],1,maxx);            chosenxt(rt[que[i][j]],rt[fa],r[i],maxx,1,maxx);        &#125;    //    lastans=min(abs(lsh[ansnxt]-lsh[r[i]]),abs(lsh[anspre]-lsh[r[i]]));//        printf(&quot;ansnxt=%lld anspre=%lld\n&quot;,ansnxt,anspre);//        printf(&quot;lsh[ansnxt]=%lld lsh[]=%lld\n&quot;,lsh[ansnxt],lsh[anspre]);        if(anspre==0)&#123;//            printf(&quot;*********\n&quot;);            printf(&quot;%lld\n&quot;,abs(lsh[ansnxt]-lsh[r[i]]));            lastans=abs(lsh[ansnxt]-lsh[r[i]]);        &#125;        else if(ansnxt==0x7ffffffff)&#123;            printf(&quot;%lld\n&quot;,abs(lsh[anspre]-lsh[r[i]]));            lastans=abs(lsh[anspre]-lsh[r[i]]);        &#125;        else printf(&quot;%lld\n&quot;,min(abs(lsh[ansnxt]-lsh[r[i]]),abs(lsh[anspre]-lsh[r[i]]))),lastans=min(abs(lsh[ansnxt]-lsh[r[i]]),abs(lsh[anspre]-lsh[r[i]]));    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>d[贪心]</title>
      <link href="/2025/03/14/d%5B%E8%B4%AA%E5%BF%83%5D/"/>
      <url>/2025/03/14/d%5B%E8%B4%AA%E5%BF%83%5D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-11 17:50</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191011173850840-542905605.png"></p><p>拉到最后就能看到我了</p><p>t1,每个矩形有长宽,可以删去m个矩形使min{长}*min{宽}最大</p><p>t1打了个假的贪心,同时以$a,b$排序,每次找到$a,b$中较小的删去,然后大样例过不了</p><p>其实自己手摸了一组也过不了</p><p>3 1</p><p>6 5</p><p>1 10000</p><p>1 10000</p><p>按照我的贪心删掉1 10000(1比较小),其实删掉6 5更优</p><p>于是很慌,又打了个假的贪心,每次找到$delta$最小的,</p><p>然后大样例又过不了…</p><p>有点崩,然后又随便打了两个贪心基本就是往上蒙贪心策略了</p><p>然后大样例依然过不了,</p><p>然后想难道这是反悔贪心,</p><p>然后就扔了</p><p>其实t1跟之前一道t2很像,和多面手那个贪心很像啊,自己没有迁移过来,罪有应得</p><p>一层循环枚举删掉多少长最小的,剩下删掉宽小的</p><p>这样一定保证贪心是正确的,这样是$n^2$,然后优化一下就$n*log(n)$了(主席树优化,二分优化,堆优化,各种优化都能过)</p><p>哈我不知道我考试时在想什么</p><p>我好傻逼啊</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111111ll T,n,m;ll vis[A];struct node&#123;    ll a,b,id;    node()&#123;&#125;    node(const ll &amp;x,const ll &amp;y,const ll &amp;z)&#123;a=x,b=y,id=z;&#125;    friend bool operator &lt; (const node &amp;x,const node &amp;y)&#123;        return x.a&lt;y.a;    &#125;&#125;p1[A];struct node2&#123;    ll b;    node2()&#123;&#125;    node2(const ll &amp;y)&#123;b=y;&#125;    friend bool operator &lt; (const node2 &amp;x,const node2 &amp;y)&#123;        return x.b&gt;y.b;    &#125;&#125;;priority_queue&lt;node2&gt;q;int main()&#123;//    freopen(&quot;d2.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;zj.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;T);    while(T--)&#123;        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);        while(q.size()) q.pop();        for(ll i=1;i&lt;=n;i++)&#123;            ll x,y;            scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);            p1[i]=node(x,y,i);        &#125;        sort(p1+1,p1+n+1);                for(ll i=m+1;i&lt;=n;i++)            q.push(node2(p1[i].b));        ll maxx=0;        for(ll i=m;i&gt;=0;i--)&#123;//            printf(&quot;p1[i+1].a=%lld q.top()=%lld\n&quot;,p1[i+1].a,q.top().b);            maxx=max(p1[i+1].a*q.top().b,maxx);            q.push(node2(p1[i].b));            q.pop();//            if(p1[i].b&lt;q.top().b) continue ;//一定被删//            else q.pop(),q.push(node2(p1[i].b));        &#125;        printf(&quot;%lld\n&quot;,maxx);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试104「中间值·最小值」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95104%E3%80%8C%E4%B8%AD%E9%97%B4%E5%80%BC%C2%B7%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95104%E3%80%8C%E4%B8%AD%E9%97%B4%E5%80%BC%C2%B7%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-07 16:10</p><p>考试时的记录(t1)</p><pre><code>//12 14 18//13 15 17 18锅//二分套二分不可行//1 3 5 7 9//2 4 6 8 10//倍增/分块会被卡//主席树需要带修改//线段树根本维护不了//set需要得知序列//可持久化set?//莫队复杂度不对n^(5/3)//分块维护不了</code></pre><p>觉得t1根本没法搞,主要是二分套二分被我否决了</p><p>本来打了个二分套二分,然后一拍就挂</p><p>后来就调,觉得很恶心</p><p>最后发现我二分套二分玮了</p><p>我二分策略是二分第一段长度,然后在第二段里lower_bound,upper_bound找到&lt;第一段二分位置的值的第一位置,和&gt;第一段二分位置值最后一个位置???</p><p>帏的</p><p>12 14 18</p><p>13 15 17 18</p><p>里15是mid我查不到</p><p>其实暴力可以直接二分答案,然后在两段里–upper_bound找到&lt;&#x3D;的值,</p><p>我这不是弱智吗</p><p>简单题复杂化,能力max</p><h2 id="中间值"><a href="#中间值" class="headerlink" title="中间值"></a>中间值</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$n*{log}^2$就是上面说的直接二分答案,两段里–upper_bound找到&lt;&#x3D;的值</p><p>优化成$n*log$就是二分第一段位置,找到第二段对应位置(莫名和考试时苇掉的思路相似)</p><p>看是否符合,如果二分地一段找到一个x,对应第二段位置y,符合a[x]&gt;&#x3D;b[y-1]&amp;&amp;a[x]&lt;&#x3D;b[r+1]就是满足条件的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111ll n,m;ll a[A],b[A];//ll read()&#123;ll x;cin&gt;&gt;x;return x;&#125;ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c)) &#123;if(c==&#39;-&#39;) f=-1;c=getchar();&#125;    while(isdigit(c))&#123;x=x*10+c-&#39;0&#39;;c=getchar();&#125;    return x*f;&#125;ll jud(ll x,ll l,ll r)&#123;    if(x&gt;r) return n+1;    if(x&lt;l) return 0;    return x;&#125;ll erf1(ll l1,ll r1,ll l2,ll r2)&#123;    ll len=(r2-l2+1+r1-l1+1+1)/2;    ll l=l1,r=min(r1,l1+len-1);    while(l&lt;=r)&#123;        ll mid=(l+r)&gt;&gt;1;        if(b[jud(l2+len+l1-mid-2,l2,r2)]&lt;=a[mid]&amp;&amp;b[jud(l2+len-(mid-l1+1),l2,r2)]&gt;=a[mid]) &#123;printf(&quot;%lld\n&quot;,a[mid]);return 1;&#125;        if(b[jud(l2+len+l1-mid-2,l2,r2)]&gt;a[mid]) l=mid+1;        else r=mid-1;    &#125;    return 0;&#125;ll erf2(ll l1,ll r1,ll l2,ll r2)&#123;    ll len=(r2-l2+1+r1-l1+1+1)/2;    ll l=l2,r=min(r2,l2+len-1);    while(l&lt;=r)&#123;        ll mid=(l+r)&gt;&gt;1;        if(a[jud(l2+len+l1-mid-2,l1,r1)]&lt;=b[mid]&amp;&amp;a[jud(l2+len-(mid-l1+1),l1,r1)]&gt;=b[mid]) &#123;printf(&quot;%lld\n&quot;,b[mid]);return 1;&#125;        if(a[jud(l2+len+l1-mid-2,l1,r1)]&gt;b[mid]) l=mid+1;        else r=mid-1;    &#125;    return 0;&#125;int main()&#123;    freopen(&quot;median.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;median.out&quot;,&quot;w&quot;,stdout);    n=read(),m=read();    for(ll i=1;i&lt;=n;i++)        a[i]=read();    for(ll i=1;i&lt;=n;i++)        b[i]=read();    a[n+1]=b[n+1]=123456798101112;    for(ll i=1;i&lt;=m;i++)&#123;        ll opt=read();        if(opt==1)&#123;            ll x=read(),y=read(),z=read();            if(x==0) a[y]=z;            else b[y]=z;        &#125;        else &#123;            ll l1=read(),r1=read(),l2=read(),r2=read();            if(!erf1(l1,r1,l2,r2)) erf2(l1,r1,l2,r2);        &#125;    &#125;    &#125;</code></pre><p>View Code</p><h2 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>水掉没脸,</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define $ 1111111ll read()&#123;    ll x=0,f=1;char c=getchar();    while(!isdigit(c)) &#123;    if(c==&#39;-&#39;) f=-1;c=getchar();&#125;    while(isdigit(c))&#123;x=x*10+c-&#39;0&#39;;c=getchar();&#125;    return x*f;&#125;ll A,B,C,D,n;ll a[$],f[$]; //627982878638142//min满足单调性但这个函数不一定满足int main()&#123;    freopen(&quot;min.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;min.out&quot;,&quot;w&quot;,stdout);    n=read(),A=read(),B=read(),C=read(),D=read();    for(ll i=1;i&lt;=n;i++)&#123;        a[i]=read();    &#125;    memset(f,-0x7f,sizeof(f));    f[0]=0;    for(ll i=1;i&lt;=n;i++)&#123;        ll minn=a[i];        for(ll j=i-1;j&gt;=max(0ll,i-500);j--)&#123;            minn=min(a[j+1],minn);            f[i]=max(f[i],f[j]+minn*minn*minn*A+minn*minn*B+minn*C+D);//            printf(&quot;minn*minn*minn*A+minn*minn*B+minn*C+D=%lld\n&quot;,minn*minn*minn*A+minn*minn*B+minn*C+D);//            if(minn*minn*minn*A+minn*minn*B+minn*C+D&lt;0) break;        &#125;    &#125;    printf(&quot;%lld\n&quot;,f[n]);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试103「game,time」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95103%E3%80%8Cgame,time%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95103%E3%80%8Cgame,time%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-07 07:39</p><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>贪心考虑,考试时想错了,我想的是移动最大值,枚举最大值位置,然后把左面和右面逆序对拼起来,</p><p>当然,处理不了有多个最大值情况,于是我就想着打个部分分吧</p><p>然而对拍还是挂,</p><p>枚举最大值位置是不对的</p><p>考虑一种情况a,b,c,d,e,f,g</p><p>其中d最大可能出现a移动到d右面更优,b,c留在左面,我只移动最大值的话默认a,b,c都在左面</p><p>附赠一组点4 5 2 3 1 6 7 最优决策是6步,方案是2 4 5 6 7 3 1 .</p><p>出现了我说的这种情况</p><p>考试时打这个题花费时间还是过于多了</p><p>正解是贪心移动最小值,这样是保证正确的,只移动最大值相当与限制了一些情况出现</p><p>然后最小值考虑了所有情况且一定正确</p><h3 id="正难则反-by-yangguangjie"><a href="#正难则反-by-yangguangjie" class="headerlink" title="正难则反__by yangguangjie"></a>正难则反__by yangguangjie</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111111ll p[A],a[A],b[A],c1[A],c2[A];ll n,ans=0;vector &lt;ll&gt; v[A];//正void add1(ll x,ll d)&#123;for(ll i=x;i!=0&amp;&amp;i&lt;=100000;i+=i&amp;-i) c1[i]+=d;&#125;ll ask1(ll x,ll ans=0)&#123;for(ll i=x;i&gt;=1;i-=i&amp;-i) ans+=c1[i];return ans;&#125;//逆void add2(ll x,ll d)&#123;for(ll i=x;i&gt;=1;i-=i&amp;-i) c2[i]+=d;&#125;ll ask2(ll x,ll ans=0)&#123;for(ll i=x;i!=0&amp;&amp;i&lt;=100000;i+=i&amp;-i) ans+=c2[i];return ans;&#125;void sol()&#123;    for(ll i=1;i&lt;=n;i++)&#123;        add1(i,1);add2(i,1);        v[a[i]].push_back(i);    &#125;    for(ll i=1;i&lt;=100000;i++)&#123;        if(v[i].size())&#123;            for(ll fr=0,ba=v[i].size()-1;fr&lt;=ba;)&#123;                ll x=v[i][fr],y=v[i][ba];                ll l=ask1(x-1),r=ask2(y+1);//                printf(&quot;l=%lld r=%lld\n&quot;,l,r);                if(l&lt;r)&#123;                    ans+=l;                    add1(x,-1);                    add2(x,-1);                    fr++;                &#125;                else &#123;                    ans+=r;                    add1(y,-1);                    add2(y,-1);                    ba--;                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    freopen(&quot;time.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;time.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]),p[i]=i;    sol();    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>做过一个类似的题(老司机的狂欢),也是求字典序最小,也是第一问特别简单,然后根据第一问推第二问</p><p>但实在没想到可以每一位上二分求字典序最小</p><p>推单调性</p><p>如果upper_bound有值具有单调性,当前选的值越大,以后高的可能性就越小</p><p>如果upper_bound没值具有单调性,当前选的值越大,以后得分高的可能越小</p><p>但是函数是分段的</p><p>可以分两次二分</p><p>这样每次set暴力check复杂度$n^2*{log}^2$</p><p>现在思考如何check</p><p>可以用权值线段树维护</p><p>维护A的没用上的牌</p><p>维护B的没用上的牌</p><p>向上合并时右子树每一张A都可以于左子树中B匹配</p><p>代码大致是这样</p><pre><code>void up(ll x)&#123;    ll de=min(tr[x&lt;&lt;1|1].L,tr[x&lt;&lt;1].R);    tr[x].s=tr[x&lt;&lt;1].s+tr[x&lt;&lt;1|1].s+de;    tr[x].L=tr[x&lt;&lt;1].L+tr[x&lt;&lt;1|1].L-de;    tr[x].R=tr[x&lt;&lt;1].R+tr[x&lt;&lt;1|1].R-de;&#125;</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 1010100#define maxx 100000ll read()&#123;ll x;scanf(&quot;%d&quot;,&amp;x);return x;&#125;ll tot,n;ll b[A],a[A];multiset&lt;ll&gt; st;multiset&lt;ll&gt; ::iterator it;struct node&#123;    ll l,r,L,R,s;//L:A的牌//R:B的牌//s得分&#125;tr[A];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void up(ll x)&#123;    ll de=min(tr[x&lt;&lt;1|1].L,tr[x&lt;&lt;1].R);    tr[x].s=tr[x&lt;&lt;1].s+tr[x&lt;&lt;1|1].s+de;    tr[x].L=tr[x&lt;&lt;1].L+tr[x&lt;&lt;1|1].L-de;    tr[x].R=tr[x&lt;&lt;1].R+tr[x&lt;&lt;1|1].R-de;&#125;void insert(ll x,ll pla,ll vala,ll valb)&#123;    if(tr[x].l==tr[x].r)&#123;        tr[x].L+=vala;        tr[x].R+=valb;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) insert(x&lt;&lt;1,pla,vala,valb);    else insert(x&lt;&lt;1|1,pla,vala,valb);    up(x);&#125;void getans(ll now)&#123;    insert(1,b[now],0,-1);    ll l=b[now]+1,r=*st.rbegin(),ans=0;    while(l&lt;=r)&#123;        ll mid=(l+r)&gt;&gt;1;        insert(1,mid,-1,0);        if(tr[1].s+1==tot)&#123;            l=mid+1;            ans=mid;        &#125;        else r=mid-1;        insert(1,mid,1,0);    &#125;    insert(1,ans,-1,0);    if(tr[1].s+1==tot)&#123;        tot--;        printf(&quot;%d &quot;,ans);        it=st.find(ans);        st.erase(it);        return ;    &#125;    insert(1,ans,1,0);    l=1,r=b[now],ans=0;    while(l&lt;=r)&#123;        ll mid=(l+r)&gt;&gt;1;        insert(1,mid,-1,0);        if(tr[1].s==tot)&#123;            l=mid+1;            ans=mid;        &#125;        else r=mid-1;        insert(1,mid,1,0);    &#125;    insert(1,ans,-1,0);    printf(&quot;%d &quot;,ans);    it=st.find(ans);    st.erase(it);&#125;int main()&#123;    freopen(&quot;game.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;game.out&quot;,&quot;w&quot;,stdout);    n=read();    built(1,1,maxx);    for(ll i=1;i&lt;=n;i++)&#123;        b[i]=read();        insert(1,b[i],0,1);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        a[i]=read();        insert(1,a[i],1,0);        st.insert(a[i]);    &#125;    tot=tr[1].s;    for(ll i=1;i&lt;=n;i++)&#123;        getans(i);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试99「淘淘摘苹果,开心的金明,笨小猴」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9599%E3%80%8C%E6%B7%98%E6%B7%98%E6%91%98%E8%8B%B9%E6%9E%9C,%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E,%E7%AC%A8%E5%B0%8F%E7%8C%B4%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9599%E3%80%8C%E6%B7%98%E6%B7%98%E6%91%98%E8%8B%B9%E6%9E%9C,%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E,%E7%AC%A8%E5%B0%8F%E7%8C%B4%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-05 15:04</p><h2 id="淘淘摘苹果"><a href="#淘淘摘苹果" class="headerlink" title="淘淘摘苹果"></a>淘淘摘苹果</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>分块大法好!</p><p>每一个块内维护单调上升序列</p><p>然后块之间暴力lower_bound</p><p>复杂度$n*\sqrt n log(\sqrt n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 100005ll t,n,m,t2;ll bl[A],h[A],mx[410],sz[410];ll st[410][410];//但是复杂度不对啊!int main()&#123;    freopen(&quot;TaoPApp.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;TaoPApp.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    t=sqrt(n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%d&quot;,&amp;h[i]);        bl[i]=(i-1)/t+1;        t2=max(t2,bl[i]);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        ll belong=bl[i];        mx[belong]=max(mx[belong],h[i]);        if(!sz[belong])&#123;            sz[belong]++;            st[belong][sz[belong]]=h[i];            continue ;        &#125;        else if(h[i]&gt;st[belong][sz[belong]])&#123;            sz[belong]++;            st[belong][sz[belong]]=h[i];        &#125;            &#125;    for(ll i=1;i&lt;=m;i++)&#123;        ll pla,hnow,lst;        scanf(&quot;%d%d&quot;,&amp;pla,&amp;hnow);        ll belong=bl[pla],maxnow=0,cnt=0;        lst=h[pla];h[pla]=hnow;        for(ll j=1;j&lt;=t2;j++)&#123;            if(j==belong)&#123;                for(ll k=(j-1)*t+1;k&lt;=min(j*t,n);k++)&#123;                    if(h[k]&gt;maxnow)&#123;                        maxnow=h[k];                        cnt++;                    &#125;                &#125;            &#125;            else &#123;                if(mx[j]&gt;maxnow)&#123;                    cnt+=(sz[j]-(upper_bound(st[j]+1,st[j]+sz[j]+1,maxnow)-st[j])+1);                    maxnow=mx[j];                &#125;            &#125;        &#125;        h[pla]=lst;        printf(&quot;%d\n&quot;,cnt);    &#125;&#125;</code></pre><p>View Code</p><p>或者可以线段树</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 5555555struct node&#123;    ll l,r,max,val;&#125;tr[A];ll a[A];ll n,m,lst;void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;ll ask(ll x,ll val)&#123;    if(tr[x].l==tr[x].r)    return tr[x].max&gt;val;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(tr[x&lt;&lt;1].max&lt;=val) return ask(x&lt;&lt;1|1,val);    else return ask(x&lt;&lt;1,val)+tr[x].val-tr[x&lt;&lt;1].val;&#125;void up(ll x)&#123;    tr[x].max=max(tr[x&lt;&lt;1].max,tr[x&lt;&lt;1|1].max);    tr[x].val=tr[x&lt;&lt;1].val+ask(x&lt;&lt;1|1,tr[x&lt;&lt;1].max);&#125;void change(ll x,ll pla,ll val)&#123;    if(tr[x].l==tr[x].r)&#123;        tr[x].val=1;        tr[x].max=a[pla];        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) change(x&lt;&lt;1,pla,val);    else change(x&lt;&lt;1|1,pla,val);    up(x);&#125;int main()&#123;    freopen(&quot;TaoPApp.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;TaoPApp.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    built(1,1,n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);        change(1,i,a[i]);    &#125;    for(ll i=1;i&lt;=m;i++)&#123;        ll p,h;        scanf(&quot;%lld%lld&quot;,&amp;p,&amp;h);        lst=a[p];        a[p]=h;        change(1,p,a[p]);        printf(&quot;%lld\n&quot;,tr[1].val);        a[p]=lst;        change(1,p,a[p]);    &#125;&#125;</code></pre><p>View Code</p><p>然而分块比线段树快的多</p><h2 id="开心的金明"><a href="#开心的金明" class="headerlink" title="开心的金明"></a>开心的金明</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>dp不可做就要往贪心\二分上想了</p><p>贪心考虑每原材料</p><pre><code>    val[1]=s1[1].c;    for(ll i=2;i&lt;=k;i++)&#123;        val[i]=min(val[i-1]+s2[i-1].R,s1[i].c);    &#125;</code></pre><p>我们先把所有电脑生产出来,等卖出时再计算生产消耗,能生产就生产</p><p>贪心卖就是卖出生产代价最小的</p><p>证明:如果最后生产代价大生产代价小都卖出去了,那么和先卖生产代价小再卖生产代价大,情况一样</p><p>如果生产代价小没卖出去,而卖出生产代价大的肯定不优</p><p>于是拿个堆维护一下</p><p>这种费用滞后计算思想还是要见一见</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111111ll read()&#123;    ll x;scanf(&quot;%lld&quot;,&amp;x);return x;&#125;ll tot,n,k,tot2,ans;ll val[A];struct node&#123;    ll val,sum;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b)&#123;val=a;sum=b;&#125;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.val&lt;b.val;    &#125;&#125;tmp[A],now[A];struct some&#123;    ll c;//原材料价格    ll d;//至少d个电脑    ll m;//生产电脑费用    ll p;//可以生产p台    ll e;//最多储存e台    ll R;//储存消耗R    ll E;//储存电脑消耗&#125;s1[A],s2[A];int main()&#123;    freopen(&quot;happy.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;happy.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;k);    for(ll i=1;i&lt;=k;i++)&#123;        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;s1[i].c,&amp;s1[i].d,&amp;s1[i].m,&amp;s1[i].p);    &#125;    for(ll i=1;i&lt;=k-1;i++)&#123;        scanf(&quot;%lld%lld%lld&quot;,&amp;s2[i].e,&amp;s2[i].R,&amp;s2[i].E);    &#125;    val[1]=s1[1].c;    for(ll i=2;i&lt;=k;i++)&#123;        val[i]=min(val[i-1]+s2[i-1].R,s1[i].c);    &#125;    for(ll i=1;i&lt;=k;i++)&#123;        for(ll j=1;j&lt;=tot;j++)            tmp[j].val+=s2[i-1].E;        tmp[++tot]=node(val[i]+s1[i].m,s1[i].p);//        printf(&quot;s1.d=%lld\n&quot;,s1[i].d);        sort(tmp+1,tmp+tot+1);        ll ned=s1[i].d,cun=s2[i].e;        for(ll j=1;j&lt;=tot;j++)&#123;            if(tmp[j].sum&lt;=ned)&#123;                ans+=tmp[j].sum*tmp[j].val;//                printf(&quot;i=%lld val=%lld sum=%lld\n&quot;,i,tmp[j].val,tmp[j].sum);                ned-=tmp[j].sum;                tmp[j].sum=0;                            &#125;            else &#123;                ans+=ned*tmp[j].val;//                printf(&quot;val=%lld ned=%lld\n&quot;,tmp[j].val,ned);                tmp[j].sum-=ned;                ned=0;            &#125;        &#125;        if(ned)&#123;            puts(&quot;-1&quot;);            return 0;        &#125;//        printf(&quot;ans=%lld\n&quot;,ans);        tot2=0;        for(ll j=1;j&lt;=tot;j++)&#123;            if(tmp[j].sum==0) continue ;            if(tmp[j].sum&lt;=cun)&#123;                now[++tot2]=tmp[j];                cun-=tmp[j].sum;            &#125;            else &#123;                now[++tot2]=node(tmp[j].val,cun);                cun=0;            &#125;        &#125;        tot=tot2;        for(ll j=1;j&lt;=tot;j++)            tmp[j]=now[j];    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="笨小猴"><a href="#笨小猴" class="headerlink" title="笨小猴"></a>笨小猴</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>发现check是O1的(维护前缀和)然而可能初始给定序列根本组不成</p><p>然后可以每random_shuffle1次再check500000次</p><p>进行上述操作50次就AC了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A  1111111 struct node&#123;    ll a,b,id;&#125;c[A];ll suma[A],sumb[A],sa,sb,n;ll random(ll x)&#123;    return rand()%x;&#125;int main()&#123;    freopen(&quot;grandmaster.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;grandmaster.out&quot;,&quot;w&quot;,stdout);    srand((unsigned)time(0));    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=2*n+1;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;c[i].a,&amp;c[i].b);        c[i].id=i;        sa+=c[i].a,sb+=c[i].b;    &#125;    for(ll i=1;i*n&lt;=1000000;i++)&#123;        random_shuffle(c+1,c+2*n+2);        for(ll j=1;j&lt;=2*n+1;j++)            suma[j]=suma[j-1]+c[j].a,            sumb[j]=sumb[j-1]+c[j].b;        for(ll j=1;j&lt;=n;j++)&#123;            ll l=random(n+1)+1;            if(suma[l+n]-suma[l-1]&gt;sa-(suma[l+n]-suma[l-1]))                if(sumb[l+n]-sumb[l-1]&gt;sb-(sumb[l+n]-sumb[l-1]))&#123;                    for(ll k=l;k&lt;=l+n;k++)                        printf(&quot;%lld\n&quot;,c[k].id);                    return 0;                &#125;        &#125;        if(clock()&gt;990000)&#123;            printf(&quot;-1\n&quot;);            return 0;        &#125;    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试98「装饰·午餐」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9598%E3%80%8C%E8%A3%85%E9%A5%B0%C2%B7%E5%8D%88%E9%A4%90%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9598%E3%80%8C%E8%A3%85%E9%A5%B0%C2%B7%E5%8D%88%E9%A4%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-03 15:36</p><h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>其实是挺好的一道题</p><p>正着实在不好做,还要考虑当前点是否可以传递,</p><p>可以提前把整个链都处理出来,例如第一秒点灯把整条链都染上色</p><p>然而你不知道终止时间</p><p>枚举终止时间即可</p><p>算是时光倒流</p><p>还有,感谢wwb_ape</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 111ll sta[A],light[A],qw[A],fa[A],ff[35][35],f[35][1&lt;&lt;17|1];ll vis[20];ll n,ans=0x3f3f3f3f,top,mudi;int main()&#123;    freopen(&quot;decoration.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;decoration.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=2;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;fa[i]);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;qw[i]);        if(qw[i]==1) mudi|=1&lt;&lt;(i-1);    &#125;    ll maxn=(1&lt;&lt;n)-1;    fa[1]=0;    for(ll i=1;i&lt;=32;i++)&#123;        for(ll j=1;j&lt;=n;j++)&#123;            ll cnt=0,now=j,tot=n-i;            while(cnt&lt;=tot&amp;&amp;now!=0)&#123;                cnt++;                ff[i][j]|=1&lt;&lt;(now-1);//                printf(&quot;ff[%lld][%lld]=%lld now=%lld\n&quot;,i,j,ff[i][j],now);                now=fa[now];            &#125;        &#125;    &#125;    f[n+1][0]=1;    for(ll i=n;i&gt;=1;i--)&#123;        for(ll j=0;j&lt;=maxn;j++)&#123;            if(!f[i+1][j]) continue ;            for(ll k=1;k&lt;=n;k++)&#123;                f[i][j^ff[i][k]]|=f[i+1][j];//                printf(&quot;f[%lld][%lld]=%lld i+1=%lld j=%lld\n&quot;,i,j^ff[i][k],f[i+1][j],i+1,j);            &#125;            f[i][j]|=f[i+1][j];//            printf(&quot;f[%lld][%lld]=%lld\n&quot;,i,j,f[i][j]);//            printf(&quot;mudi=%lld\n&quot;,mudi);            if(f[i][mudi])&#123;                printf(&quot;%lld\n&quot;,n-i+1);                return 0;            &#125;        &#125;    &#125;&#125;</code></pre><p>View Code</p><h2 id="午餐"><a href="#午餐" class="headerlink" title="午餐"></a>午餐</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>考场真是什么也没想出来</p><p>暴力都没打对,真是没救了</p><p>还好我现在稍微会了一点</p><p>有一个奇怪的子任务:不存在<strong>确定</strong> 没有学会毒瘤算法的同学。</p><p>看上去这个子任务给的性质好像没什么用</p><p>我们还是可以推一推</p><p>贪心取L即可</p><p>证明感性理解一下</p><p>于是f[x]&#x3D;min(f[x],L)</p><p>最短路形式,可以用最短路转移</p><p>然后将这个子任务推广</p><p>如果存在没有学会毒瘤算法的同学就是相当于给上述转移加了一个限制条件</p><p>例如</p><p>现有wwb,whs二人</p><p>已知wwb学习毒瘤算法时间在&gt;R,那么就意味着这次吃饭时whs也不会毒瘤算法</p><p>仍然贪心考虑</p><p>whs和wwb二人吃饭于L,然后whs在L+1学会毒瘤算法,就满足限制了</p><p>于是lim[x]&#x3D;max(L+1)</p><p>先把lim算出来,再转移f就可以了</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111ll n,m,tot;ll vis[A],mn[A],mx[A],head[A],nxt[A],ver[A],dis[A],flag[A],lst[A],lim[A];struct node&#123;    ll x,y,l,r;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b,const ll &amp;c,const ll &amp;d)&#123;x=a,y=b,l=c,r=d;&#125;&#125;u[A];void add(ll x,ll y,ll minn,ll maxx)&#123;    nxt[++tot]=head[x],ver[tot]=y,head[x]=tot,mn[tot]=minn,mx[tot]=maxx;&#125;void pre_spfa()&#123;    deque&lt;ll&gt; q;    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;lst[i]);        if(lst[i]==-1) lim[i]=1e9+7,vis[i]=1,q.push_back(i);        else vis[i]=0;    &#125;    while(!q.empty())&#123;        ll x=q.front();q.pop_front();        vis[x]=0;        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i],minn=mn[i],maxx=mx[i];            if(lim[x]&gt;maxx)&#123;                if(lim[y]&lt;minn+1)&#123;                    lim[y]=minn+1;                    if(!vis[y])&#123;                        vis[y]=1;                        q.push_back(y);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;void spfa()&#123;    deque&lt;ll&gt; q;    for(ll i=1;i&lt;=n;i++)        vis[i]=0,dis[i]=1e9+7;    dis[1]=0;q.push_back(1);    while(!q.empty())&#123;        ll x=q.front();q.pop_front();        vis[x]=0;        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i],minn=mn[i],maxx=mx[i],g=max(max(lim[y],minn),dis[x]);//            printf(&quot;y=%lld minn=%lld maxx=%lld g=%lld\n&quot;,y,minn,maxx,g);            if(dis[y]&gt;g&amp;&amp;g&lt;=maxx)&#123;                dis[y]=g;//                printf(&quot;dis[%lld]=%lld\n&quot;,y,dis[y]);                if(!vis[y])&#123;                    vis[y]=1;                    q.push_back(y);                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    freopen(&quot;lunch.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;lunch.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=1;i&lt;=m;i++)&#123;        ll x,y,a,b;        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;a,&amp;b);        add(x,y,a,b);        add(y,x,a,b);        u[i]=node(x,y,a,b);    &#125;    pre_spfa();    spfa();     for(ll i=1;i&lt;=n;i++)        if(lst[i]==1&amp;&amp;dis[i]&gt;1e9)&#123;            puts(&quot;Impossible\n&quot;);            return 0;        &#125;    for(ll i=1;i&lt;=m;i++)&#123;        ll x=u[i].x,y=u[i].y;        if(lst[x]==-1&amp;&amp;dis[y]&lt;u[i].l)&#123;            puts(&quot;Impossible\n&quot;);            return 0;        &#125;        if(lst[y]==-1&amp;&amp;dis[x]&lt;u[i].l)&#123;            puts(&quot;Impossible\n&quot;);            return 0;        &#125;    &#125;//    for(ll i=1;i&lt;=n;i++)//        printf(&quot;lim=%lld dis=%lld\n&quot;,lim[i],dis[i]);    for(ll i=1;i&lt;=m;i++)&#123;        ll x=u[i].x,y=u[i].y;        if(lst[x]==-1||lst[y]==-1) printf(&quot;%lld\n&quot;,u[i].l);        else printf(&quot;%lld\n&quot;,max(dis[x],dis[y])&gt;u[i].r?u[i].l:max(u[i].l,max(dis[x],dis[y])));    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试95「简单计算,格式化」csp-s模拟测试96「分组配对」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9595%E3%80%8C%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97,%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%8Dcsp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9596%E3%80%8C%E5%88%86%E7%BB%84%E9%85%8D%E5%AF%B9%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9595%E3%80%8C%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97,%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%8Dcsp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9596%E3%80%8C%E5%88%86%E7%BB%84%E9%85%8D%E5%AF%B9%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-06 09:48</p><h2 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$\sum\limits_{i&#x3D;0}^{i&lt;&#x3D;p}\large \lfloor \frac {i*q}{p} \rfloor$</p><p>$\sum\limits_{i&#x3D;0}^{i&lt;&#x3D;p}\large \lfloor \frac {i*q}{p} \rfloor$*2可转化</p><p>$\lfloor \frac {i*q}{p} \rfloor \lfloor \frac {(n-i)*q}{p} \rfloor$</p><p>考虑转化,本来是两部分加和完整的,&#x3D;q,现在拆成两部分如果i*q不能整除那么最终贡献就是q-1,否则贡献就是q</p><p>那么考虑容斥,先不考虑整除答案就是q*(p+1)先把所有贡献-p-1,最后再加上可以整除就是gcd(p,q),再算上0的情况+1</p><p>所以答案就是$\frac{q*(p+1)-p+gcd(p,q)}{2}$</p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>考虑贪心,如果a&lt;&#x3D;b那么按照a从小到大排序,如果a&gt;b按照b从大到小排序</p><p>证明第一个,因为都是做正贡献所以越小越好,因为买大的可能会需要多花钱买,</p><p>例如2 3</p><p>3 4</p><p>先买3 4需要3代价,再买2 3,多出来贡献浪费了</p><p>先买2 3 再买3 4可以只花2</p><p>证明第二个,因为肯定是做副贡献,但是还是有贡献的,因为所有必须都要选,如果最后选相对贡献大的,多出来的贡献会造成浪费</p><h2 id="分组配对"><a href="#分组配对" class="headerlink" title="分组配对"></a>分组配对</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>倍增+二分</p><p>倍增减少二分次数</p><p>因为check时间复杂度过于大(n*log(n))</p><p>一个一个区间拓展极限情况就每一个点是一段这样二分次数logn,check(n<em>logn),然后每个点进行上述操作$n^2</em>{log}^2$</p><p>倍增一点一点前进减少次数,第一次不符合情况下在最后一次符合-第一次不符合之间二分</p><p>复杂度正确(不是优化复杂度是避免了最差复杂度)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试94「凉宫春日的犹豫·漫无止境的八月·射手座之日」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9594%E3%80%8C%E5%87%89%E5%AE%AB%E6%98%A5%E6%97%A5%E7%9A%84%E7%8A%B9%E8%B1%AB%C2%B7%E6%BC%AB%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%85%AB%E6%9C%88%C2%B7%E5%B0%84%E6%89%8B%E5%BA%A7%E4%B9%8B%E6%97%A5%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9594%E3%80%8C%E5%87%89%E5%AE%AB%E6%98%A5%E6%97%A5%E7%9A%84%E7%8A%B9%E8%B1%AB%C2%B7%E6%BC%AB%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%85%AB%E6%9C%88%C2%B7%E5%B0%84%E6%89%8B%E5%BA%A7%E4%B9%8B%E6%97%A5%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-01 19:21</p><h2 id="凉宫春日的犹豫"><a href="#凉宫春日的犹豫" class="headerlink" title="凉宫春日的犹豫"></a>凉宫春日的犹豫</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>第一次秒切题,5分钟切掉</p><p>比较$x^y$和$y!$大小</p><p>如果$x^y&lt;y!$输出Yes</p><p>问题转化为</p><p>$\frac{1}{x} <em>\frac{2}{x}</em>\frac{3}{x},,,,,*\frac{y}{x}&gt;&#x3D;1$输出$Yes$</p><p>开双端队列维护,一直保持单调,然后让队首*队尾就行了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define A 111111long double zhajing;double x,y;ll t;deque&lt;long double&gt; q;int main()&#123;    freopen(&quot;yuuutsu.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;yuuutsu.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);        zhajing=1.0;        while(q.size()) q.pop_front();        for(double i=1;i&lt;=y;i++)&#123;            q.push_back(i/x);        &#125;        while(q.size()&gt;=2)&#123;            long double x1=q.front(),x2=q.back(),now;            q.pop_front(),q.pop_back();            now=x1*x2;            if(now&lt;x1)&#123;                q.push_front(now);            &#125;            else &#123;                q.push_back(now);            &#125;        &#125;        long double now=q.front();        if(now&gt;=1.0000000000000)&#123;            printf(&quot;Yes\n&quot;);        &#125;        else printf(&quot;No\n&quot;);    &#125;&#125;</code></pre><p>View Code</p><h2 id="漫无止境的八月"><a href="#漫无止境的八月" class="headerlink" title="漫无止境的八月"></a>漫无止境的八月</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>其实都是套路,映射到最后一块然后线段树维护</p><p>考场水掉了QwQ</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2100000ll cha[A],a[A],thelast[A];ll n,k,q,l,r,minn,maxx;ll abs_(ll x)&#123;    if(x&lt;0) return -x;    return x;&#125;struct node&#123;    ll l,r,mn,mx;&#125;tr[A*8];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        tr[x].mn=tr[x].mx=cha[l];        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void change(ll x,ll pla,ll val)&#123;    if(tr[x].l==tr[x].r)&#123;        tr[x].mn+=val;        tr[x].mx+=val;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) change(x&lt;&lt;1,pla,val);    else change(x&lt;&lt;1|1,pla,val);    tr[x].mn=min(tr[x&lt;&lt;1].mn,tr[x&lt;&lt;1|1].mn);    tr[x].mx=max(tr[x&lt;&lt;1].mx,tr[x&lt;&lt;1|1].mx);&#125;void seg_ask(ll x,ll l,ll r)&#123;    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        maxx=max(maxx,tr[x].mx);        minn=min(minn,tr[x].mn);        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_ask(x&lt;&lt;1,l,r);    if(mid&lt;r) seg_ask(x&lt;&lt;1|1,l,r);&#125;void workbf()&#123;    for(ll p=0;p+k&lt;=n;p++)&#123;        if(cha[p]&lt;0)&#123;            ll x=abs_(cha[p]);            cha[p]+=x;            cha[p+k]-=x;        &#125;        if(cha[p]&gt;0)&#123;            ll x=abs_(cha[p]);            cha[p]-=x;            cha[p+k]+=x;        &#125;    &#125;    ll ok=1;    for(ll p=0;p&lt;=n;p++)&#123;        if(cha[p])&#123;            ok=0;            break;        &#125;    &#125;    if(ok) printf(&quot;Yes\n&quot;);    else printf(&quot;No\n&quot;);&#125;void worksol()&#123;    for(ll p=0;p+k&lt;=n;p++)&#123;        if(cha[p]&lt;0)&#123;            ll x=abs_(cha[p]);            cha[p]+=x;            cha[thelast[p]]-=x;        &#125;        if(cha[p]&gt;0)&#123;            ll x=abs_(cha[p]);            cha[p]-=x;            cha[thelast[p]]+=x;        &#125;    &#125;    ll ok=1;    for(ll p=0;p&lt;=n;p++)&#123;        if(cha[p])&#123;            ok=0;            break;        &#125;    &#125;    if(ok) printf(&quot;Yes\n&quot;);    else printf(&quot;No\n&quot;);&#125;int main()&#123;    freopen(&quot;august.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;august.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;q);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a[i]);    &#125;    for(ll i=0;i&lt;=n;i++)        cha[i]=a[i]-a[i+1];    for(ll i=0;i&lt;=n;i++)&#123;        ll l=0,r=n,ans;        while(l&lt;=r)&#123;            ll mid=(l+r)&gt;&gt;1;            if(i+mid*k&lt;=n)&#123;                ans=mid;                l=mid+1;            &#125;            else r=mid-1;        &#125;        thelast[i]=ans*k+i;    &#125;    if(q&lt;=2000)workbf();    else worksol();    built(1,0,n);    for(ll i=1;i&lt;=q;i++)&#123;        ll pla,dx;        scanf(&quot;%lld%lld&quot;,&amp;pla,&amp;dx);        &#123;            change(1,thelast[pla],dx);            change(1,thelast[pla-1],-dx);            maxx=0,minn=0;            seg_ask(1,n-k+1,n);            if(maxx==0&amp;&amp;minn==0)&#123;                printf(&quot;Yes\n&quot;);            &#125;            else printf(&quot;No\n&quot;);        &#125;    &#125;&#125;</code></pre><p>View Code</p><h2 id="射手座之日"><a href="#射手座之日" class="headerlink" title="射手座之日"></a>射手座之日</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先解释为什么要差分</p><p>思考dfs序包含一段区间,你可能找到的是祖先,不是最近的</p><p>然后差分转化权值$p[i]&#x3D;w[i]-w[fa[i]]$</p><p>例如一棵树</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201911/1708132-20191101191625624-2037250803.png"></p><p>现在算3点贡献,你在2时算一次,1算一次贡献</p><p>在3时贡献$w[3]-w[2]$在二算$w[2]-w[1]$,在一算$w[1]-w[0]$</p><p>在一条链时,你把除了最近公共祖先贡献都消掉了,最后一定会归到第一个节点,</p><p>再例如算3,4,你在2算时贡献是$w[2]-w[1]$,在1$w[1]-w[2]$,你把除了最近公共祖先贡献都消掉了</p><p>然后现在就可以对于每个节点算了,而不用考虑是否满足最近条件</p><p>现在问题转化成了,对于一个节点,有多少区间,每一个区间贡献是(len)*(len-1)&#x2F;2(即所有区间个数)</p><p>然后线段树维护即可</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define  A 12222222#define ll long longll w[A],rt[A],d[A],a[A],c[A],pos[A],head[A],nxt[A],ver[A];ll n,ans,tot;struct tree&#123;    ll l,r,lw,rw,tw;&#125;tr[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void update(ll x,ll l,ll r)&#123;    tr[x].lw=tr[tr[x].l].lw,tr[x].rw=tr[tr[x].r].rw;    ll mid=(l+r)&gt;&gt;1;    if(tr[x].lw==mid-l+1) tr[x].lw+=tr[tr[x].r].lw;    if(tr[x].rw==r-mid) tr[x].rw+=tr[tr[x].l].rw;    tr[x].tw=tr[tr[x].l].tw+tr[tr[x].r].tw+tr[tr[x].l].rw*tr[tr[x].r].lw;&#125;void insert(ll &amp;x,ll l,ll r,ll id)&#123;    if(!x) x=++tot;    if(l==r)&#123;tr[x].lw=tr[x].rw=tr[x].tw=1;return ;&#125;    ll mid=(l+r)&gt;&gt;1;    if(mid&gt;=id) insert(tr[x].l,l,mid,id);    else insert(tr[x].r,mid+1,r,id);    update(x,l,r);&#125;ll merge(ll x,ll k,ll l,ll r)&#123;    if(!x||!k) return x|k;    ll mid=(l+r)&gt;&gt;1;    tr[x].l=merge(tr[x].l,tr[k].l,l,mid);    tr[x].r=merge(tr[x].r,tr[k].r,mid+1,r);    update(x,l,r);    return x;&#125;void dfs(ll x,ll pre)&#123;    insert(rt[x],1,n,pos[x]);    c[x]=w[x]-w[pre];    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue;            dfs(y,x);        rt[x]=merge(rt[x],rt[y],1,n);    &#125;    ans+=c[x]*tr[rt[x]].tw;&#125;int main()&#123;        freopen(&quot;sagittarius.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;sagittarius.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=2,x;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;x),add(i,x),add(x,i);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;d[i]),pos[d[i]]=i;    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;w[i]);    dfs(1,0);    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试91「cards·sort·naive」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9591%E3%80%8Ccards%C2%B7sort%C2%B7naive%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9591%E3%80%8Ccards%C2%B7sort%C2%B7naive%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-29 14:02</p><p>拿(na)衣(i)服(ve)</p><h2 id="cards"><a href="#cards" class="headerlink" title="cards"></a>cards</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>发现牌堆最多只有$\sqrt{n}$种,即1,2,3,4,5,6,7,8,9,10,成等差数列$\frac{n*(n+1)}{2}&#x3D;&#x3D;m$所以可以用链表维护</p><p>考场没打,懒了,其实即使没有这个性质我也应该打上链表啊,是对暴力优化,一定能使你暴力分更高就对了</p><p>知道自己暴力跑的慢就一定要优化,没时间优化算法可以,懒得优化一定不行</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>用的是DeepinC的状态定义,再次先%%%为敬,定义比题解简单很多,转移起来也很好转移</p><p>看到期望一眼dp(废话)</p><p>$rk[x][y]$表示在原有位置为x,新 <em><strong>相对</strong></em> 位置为y的概率</p><p>注意这里算的是相对位置,这个相对位置只在数相同时计算</p><p>例如1,1,1,1,2,2,2,原有位置5,新相对位置可以为1,2,3,表示在所有相同的2中它相对位置为1&#x2F;2&#x2F;3</p><p>有了这个,答案就很好算了</p><p>假设我们rk已经全部计算完成,维护sum[x]表示&lt;&#x3D;x数有sum[x]个,原位置为u</p><p>位置u答案就是$\sum\limits_{j}rk[u][j]*j+sum[x-1]$就是枚举相对位置每一种情况</p><p>$rk$单独转移不好转移</p><p>$f[x][y][0&#x2F;1]$归并排序时考虑完左面$x$个右面$y$个,最后考虑的是左&#x2F;右</p><p>这里有了第三维定义我们就可以得知最后一个数是谁</p><p>转移就是左右相等随机取一个,要考虑其中一个已经考虑完</p><p>$f$转移就不放了</p><p>$f-&gt;rk$的转移</p><p>$tmp[j1+j2]&#x3D;f[j1][j2][0]*rk[x][j1]$</p><p>$rk[x][nrk]&#x3D;tmp[nrk]$</p><p>$tmp[j1+j2]&#x3D;f[j1][j2][1]*rk[x][j2]$</p><p>$rk[x][nrk]&#x3D;tmp[nrk]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inv  499122177#define mod 998244353#define A 547ll f[A][A][2],rk[A][A],a[A],lcnt[A*10],rcnt[A*10],tmp[A*10];vector &lt;ll&gt; lv[A*10],rv[A*10];ll ans,n;//rk[i][j],原位置i,新相对位置为j//只对相同的计算相对位置void merge_sort(ll l,ll r)&#123;//    printf(&quot;l=%lld r=%lld\n&quot;,l,r);    if(l==r) return ;    ll mid=(l+r)&gt;&gt;1;    merge_sort(l,mid);merge_sort(mid+1,r);    for(ll i=l;i&lt;=mid;i++)        lv[a[i]].push_back(i),lcnt[a[i]]++;    for(ll i=mid+1;i&lt;=r;i++)        rv[a[i]].push_back(i),rcnt[a[i]]++;    for(ll i=1;i&lt;=1000;i++)&#123;        if(lcnt[i]==0&amp;&amp;rcnt[i]==0) continue ;        for(ll j=0;j&lt;=lcnt[i];j++)            for(ll k=0;k&lt;=rcnt[i];k++)                f[j][k][0]=f[j][k][1]=0;        f[0][0][0]=1;        for(ll j=0;j&lt;=lcnt[i];j++)            for(ll k=0;k&lt;=rcnt[i];k++)&#123;                if(j!=lcnt[i]&amp;&amp;k!=rcnt[i])&#123;                    f[j+1][k][0]=(f[j+1][k][0]+(f[j][k][0]+f[j][k][1])*inv%mod)%mod;                    f[j][k+1][1]=(f[j][k+1][1]+(f[j][k][0]+f[j][k][1])*inv%mod)%mod;                &#125;                else if(j!=lcnt[i]) f[j+1][k][0]=(f[j+1][k][0]+f[j][k][0]+f[j][k][1])%mod;                else if(k!=rcnt[i]) f[j][k+1][1]=(f[j][k+1][1]+f[j][k][0]+f[j][k][1])%mod;//                printf(&quot;i=%lld f[%lld][%lld]=%lld %lld\n&quot;,i,j,k,f[j][k][0],f[j][k][1]);            &#125;        for(ll j=0;j&lt;lcnt[i];j++)&#123;            for(ll j1=1;j1&lt;=lcnt[i];j1++)&#123;                for(ll j2=0;j2&lt;=rcnt[i];j2++)&#123;                    tmp[j1+j2]=(tmp[j1+j2]+rk[lv[i][j]][j1]*f[j1][j2][0]%mod)%mod;                &#125;            &#125;                            for(ll nowrk=1;nowrk&lt;=lcnt[i]+rcnt[i];nowrk++)&#123;                rk[lv[i][j]][nowrk]=(tmp[nowrk])%mod,tmp[nowrk]=0;//                printf(&quot;rk[%lld][%lld]=%lld\n&quot;,lv[i][j],nowrk,rk[lv[i][j]][nowrk]);            &#125;        &#125;        for(ll j=0;j&lt;rcnt[i];j++)&#123;            for(ll j1=0;j1&lt;=lcnt[i];j1++)&#123;                for(ll j2=1;j2&lt;=rcnt[i];j2++)&#123;                    tmp[j1+j2]=(tmp[j1+j2]+rk[rv[i][j]][j2]*f[j1][j2][1]%mod)%mod;                &#125;            &#125;            for(ll nowrk=1;nowrk&lt;=lcnt[i]+rcnt[i];nowrk++)&#123;                rk[rv[i][j]][nowrk]=(tmp[nowrk])%mod,tmp[nowrk]=0;//                printf(&quot;rk[%lld][%lld]=%lld\n&quot;,rv[i][j],nowrk,rk[rv[i][j]][nowrk]);            &#125;        &#125;        lv[i].clear();rv[i].clear();lcnt[i]=rcnt[i]=0;    &#125;//    printf(&quot;l=%lld r=%lld\n&quot;,l,r);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;a[i]);    for(ll i=1;i&lt;=n;i++)        rk[i][1]=1;    merge_sort(1,n);    for(ll i=1;i&lt;=n;i++)        lcnt[a[i]]++;    for(ll i=1;i&lt;=1000;i++)        lcnt[i]+=lcnt[i-1];    for(ll i=1;i&lt;=n;i++)&#123;        ll ans=0;        for(ll j=1;j&lt;=lcnt[a[i]]-lcnt[a[i]-1];j++)&#123;//            printf(&quot;rk[%lld][%lld]=%lld\n&quot;,i,j,rk[i][j]);            ans=(ans+rk[i][j]*j)%mod;        &#125;        printf(&quot;%lld &quot;,ans+lcnt[a[i]-1]);    &#125;&#125;</code></pre><p>View Code</p><h2 id="naive"><a href="#naive" class="headerlink" title="naive"></a>naive</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>$Or-And+Min-Max$</p><p>暴力的话就是$st$表处理$Or-And+Min-Max$然后?$O1$处理</p><p>这里更新答案思想很不错,因为它还要至少包含某一个位置,用线段树维护,现在有一个区间$l,r$是合法的可以直接给$l,r$区间赋$max$</p><p>$Or-And$变化量很少只有$log$个,$Min-Max$又是递减的,于是可以在每一个$Or-And$相同区间内进行二分,找到最长符合$&gt;&#x3D;k$区间</p><p>维护$Or-And$用链表,支持合并</p><p>代码大致是这样</p><pre><code>    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=pre[i];j;j=pre[j])&#123;            if(ask(3,nxt[j],i)-ask(4,nxt[j],i)==ask(3,j,i)-ask(4,j,i))                del(j);        &#125;</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 1111111ll st[5][25][A],nxt[A],pre[A],a[A];ll t,n,k,nowans,tail;ll logg[A];void precl()&#123;    t=23;    for(ll i=1;i&lt;=n;i++)&#123;        st[1][0][i]=a[i];        st[2][0][i]=a[i];        st[3][0][i]=a[i];        st[4][0][i]=a[i];    &#125;    for(ll j=1;j&lt;=t;j++)        for(ll i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;            st[1][j][i]=max(st[1][j-1][i],st[1][j-1][i+(1&lt;&lt;(j-1))]);            st[2][j][i]=min(st[2][j-1][i],st[2][j-1][i+(1&lt;&lt;(j-1))]);            st[3][j][i]=st[3][j-1][i]|st[3][j-1][i+(1&lt;&lt;(j-1))];            st[4][j][i]=st[4][j-1][i]&amp;st[4][j-1][i+(1&lt;&lt;(j-1))];        &#125;&#125;ll ask(ll opt,ll l,ll r)&#123;    ll g=logg[r-l+1];    if(opt==1)        return max(st[opt][g][l],st[opt][g][r-((1&lt;&lt;g))+1]);    if(opt==2)        return min(st[opt][g][l],st[opt][g][r-((1&lt;&lt;g))+1]);    if(opt==3)        return st[opt][g][l]|st[opt][g][r-((1&lt;&lt;g))+1];    if(opt==4)        return st[opt][g][l]&amp;st[opt][g][r-((1&lt;&lt;g))+1];&#125;struct node&#123;    ll l,r,val,f;&#125;tr[A*4];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        tr[x].val=-1;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void down(ll x)&#123;    tr[x&lt;&lt;1].f=max(tr[x&lt;&lt;1].f,tr[x].f);    tr[x&lt;&lt;1|1].f=max(tr[x&lt;&lt;1|1].f,tr[x].f);    tr[x&lt;&lt;1].val=max(tr[x&lt;&lt;1].val,tr[x].f);    tr[x&lt;&lt;1|1].val=max(tr[x&lt;&lt;1|1].val,tr[x].f);    tr[x].f=0;&#125;void seg_add(ll x,ll l,ll r,ll val)&#123;//    printf(&quot;l=%d r=%d\n&quot;,l,r);    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        tr[x].val=max(val,tr[x].val);        tr[x].f=max(val,tr[x].f);        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_add(x&lt;&lt;1,l,r,val);    if(mid&lt;r) seg_add(x&lt;&lt;1|1,l,r,val);&#125;void ask_point(ll x,ll pla)&#123;    if(tr[x].l==tr[x].r)&#123;        nowans=tr[x].val;        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) ask_point(x&lt;&lt;1,pla);    else ask_point(x&lt;&lt;1|1,pla);&#125;ll cal(ll l,ll r)&#123;    return -ask(1,l,r)+ask(2,l,r)+ask(3,l,r)-ask(4,l,r);&#125;void del(ll x)&#123;//    printf(&quot;****\n&quot;);    ll nx=nxt[x],pr=pre[x];    nxt[pr]=nx;    pre[nx]=pr;&#125;void dfs(ll x)&#123;    if(tr[x].l==tr[x].r)&#123;        printf(&quot;%d &quot;,tr[x].val);        return ;    &#125;    if(tr[x].f) down(x);    dfs(x&lt;&lt;1);    dfs(x&lt;&lt;1|1);&#125;int main()&#123;//    freopen(&quot;naive105.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;zj.in&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    nxt[0]=1;    logg[0]=-1;    for(ll i=1;i&lt;=n;++i)logg[i]=logg[i&gt;&gt;1]+1;    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;a[i]),nxt[i]=i+1,pre[i]=i-1;    built(1,1,n);    precl();    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=pre[i];j;j=pre[j])&#123;            if(ask(3,nxt[j],i)-ask(4,nxt[j],i)==ask(3,j,i)-ask(4,j,i))                del(j);        &#125;        for(ll j=nxt[0];j&lt;=i;j=nxt[j])&#123;            ll l=pre[j]+1,r=j,R=i,ans=R;            while(l&lt;=r)&#123;                ll mid=(l+r)&gt;&gt;1;                if(cal(mid,R)&gt;=k)&#123;                    r=mid-1;                    ans=mid;                &#125;                else l=mid+1;            &#125;            if(cal(ans,R)&gt;=k)&#123;                seg_add(1,ans,R,R-ans+1);                break;            &#125;        &#125;    &#125;    dfs(1);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试90「光线追踪,临面合并」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9590%E3%80%8C%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA,%E4%B8%B4%E9%9D%A2%E5%90%88%E5%B9%B6%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9590%E3%80%8C%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA,%E4%B8%B4%E9%9D%A2%E5%90%88%E5%B9%B6%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-08 06:30</p><p>光线追踪</p><p>30分暴力就是看每个光线和每个矩形的下边界和左边界交点</p><p>发现询问很难,</p><p>离线下来操作,</p><p>可以把角度离散化,转化为区间赋值,单点查询问题</p><p>每次就是给属于下边界角度内赋max,左边界角度内赋max</p><p>我突然感觉没什么可写的</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 5471745struct node&#123;    ll ord,x;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b)&#123;ord=a,x=b;&#125;&#125;;    node Min(node a,node b)&#123;    return a.x&lt;b.x?a:a.x==b.x?(a.ord&lt;b.ord?b:a):b;&#125;ll pan(ll x)&#123;    if(x&gt;1e9) return 0;    return x;&#125;struct tree&#123;    node w[A];    ll cl[A],cr[A];    void built(ll x,ll l,ll r)&#123;        cl[x]=l,cr[x]=r;        w[x]=node(1e9+7,1e9+7);        if(l==r)&#123;            return ;        &#125;        ll mid=(l+r)&gt;&gt;1;        built(x&lt;&lt;1,l,mid);        built(x&lt;&lt;1|1,mid+1,r);    &#125;    void change(ll x,ll l,ll r,ll ord,ll val)&#123;        if(cl[x]&gt;=l&amp;&amp;cr[x]&lt;=r)&#123;//            printf(&quot;l=%lld r=%lld w[].val=%lld val=%lld\n&quot;,cl[x],cr[x],w[x].x,val);            w[x]=Min(w[x],node(ord,val));            return ;        &#125;        ll mid=(cl[x]+cr[x])&gt;&gt;1;        if(mid&gt;=l) change(x&lt;&lt;1,l,r,ord,val);        if(mid&lt;r) change(x&lt;&lt;1|1,l,r,ord,val);    &#125;    node ask(ll x,ll pla)&#123;        if(cl[x]==cr[x]) return w[x];        node p;        ll mid=(cl[x]+cr[x])&gt;&gt;1;        if(mid&gt;=pla) p=ask(x&lt;&lt;1,pla);        else p=ask(x&lt;&lt;1|1,pla);        return Min(p,w[x]);//标记永久化    &#125;&#125;X,Y;ll x[A],xx[A],y[A],yy[A],opt[A];ll mnx0=1e9+7,mnxid,mny0=1e9+7,mnyid,cnt,q;long double lsh[A];long double cl(ll x)&#123;    if(x) return 1.0*x;    return 1e-7L;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;q);    for(ll i=1;i&lt;=q;i++)&#123;        scanf(&quot;%lld&quot;,&amp;opt[i]);        if(opt[i]==1)&#123;            scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x[i],&amp;y[i],&amp;xx[i],&amp;yy[i]);            lsh[++cnt]=1.0L*y[i]/cl(x[i]),lsh[++cnt]=1.0L*yy[i]/cl(x[i]),lsh[++cnt]=1.0L*y[i]/cl(xx[i]);        &#125;        else &#123;            scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]);            if(x[i]) lsh[++cnt]=1.0L*y[i]/x[i];        &#125;    &#125;    sort(lsh+1,lsh+cnt+1);    ll len=unique(lsh+1,lsh+cnt+1)-lsh-1;    X.built(1,1,len),Y.built(1,1,len);    for(ll i=1;i&lt;=q;i++)&#123;        if(opt[i]==1)&#123;            if(!x[i])if(mnx0&gt;=y[i])mnx0=y[i],mnxid=i;            if(!y[i])if(mny0&gt;=x[i])mny0=x[i],mnyid=i;            ll x1=lower_bound(lsh+1,lsh+len+1,1.0L*y[i]/cl(x[i]))-lsh;            ll x3=lower_bound(lsh+1,lsh+len+1,1.0L*y[i]/cl(xx[i]))-lsh;            ll x2=lower_bound(lsh+1,lsh+len+1,1.0L*yy[i]/cl(x[i]))-lsh;//            printf(&quot;i=%lld\n&quot;,i);            X.change(1,x1,x2,i,x[i]),Y.change(1,x3,x1,i,y[i]);        &#125;        else &#123;            if(!x[i])&#123;printf(&quot;%lld\n&quot;,mnxid);continue;&#125;            if(!y[i])&#123;printf(&quot;%lld\n&quot;,mnyid);continue;&#125;//            printf(&quot;i=%lld lower_bound(lsh+1,lsh+1+len,1.0L*y[i]/x[i])-lsh=%lld\n&quot;,i,1ll*(lower_bound(lsh+1,lsh+1+len,1.0L*y[i]/x[i])-lsh));            node a1=X.ask(1,lower_bound(lsh+1,lsh+1+len,1.0L*y[i]/x[i])-lsh),              a2=Y.ask(1,lower_bound(lsh+1,lsh+1+len,1.0L*y[i]/x[i])-lsh);            ll fx=a1.x,fy=a2.x;//            printf(&quot;fx=%lld fy=%lld\n&quot;,fx,fy);            if(fx*y[i]==fy*x[i])printf(&quot;%lld\n&quot;,pan(max(a1.ord,a2.ord)));            else if(fx*y[i]&lt;fy*x[i])printf(&quot;%lld\n&quot;,pan(a1.ord));            else printf(&quot;%lld\n&quot;,pan(a2.ord));        &#125;    &#125;&#125;</code></pre><p>View Code</p><p>临面合并</p><p>奇怪的数据范围应该给了一定的提示,8以内就基本是明示状压了</p><p>状态定义挺神的二进制下有一个1代表以当前点为右端点向左延伸出一个矩形</p><p>例如(假设原图是1 1 1 1)那么当前是0 1 0 1 表示两个矩形</p><p>判断一下是否可以与上面合并,减去相同贡献</p><p>过程可以预处理</p><p>不要用单调指针处理,单调指针细节特别多,</p><p>预处理</p><pre><code>void fg(ll x)&#123;    for(ll i=0;i&lt;=maxn;i++)&#123;        if((i&amp;least[x])!=least[x]) continue ;        if((i|maxx[x])!=maxx[x]) continue ;        belong[x].push_back(i);        ll cnt=0;        for(ll j=1;j&lt;=m;j++)&#123;            if((i&gt;&gt;(j-1))&amp;1)                dl[++cnt]=j;        &#125;        for(ll j=1;j&lt;=cnt;j++)&#123;            if(j==1) v[x][i].push_back(base[dl[1]]&amp;a[x]);            else v[x][i].push_back((base[dl[j]]^base[dl[j-1]])&amp;a[x]);        &#125;    &#125;&#125;</code></pre><p>减去相同贡献</p><pre><code>                ll cnt=v[i][now].size();                for(ll j1=0;j1&lt;v[i][now].size();j1++)                    for(ll j2=0;j2&lt;v[i-1][last].size();j2++)&#123;                        ll tox=v[i][now][j1],toy=v[i-1][last][j2];                        if(tox==toy)&#123;//                            printf(&quot;tox=%lld toy=%lld\n&quot;,tox,toy);                            cnt--;                        &#125;                    &#125;</code></pre><p>出题人题解</p><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191108063231429-20029340.png"></p><p><img src="https://img2018.cnblogs.com/common/1708132/201911/1708132-20191108063303704-263377999.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试84「smooth·six·walker」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9584%E3%80%8Csmooth%C2%B7six%C2%B7walker%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9584%E3%80%8Csmooth%C2%B7six%C2%B7walker%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-26 17:10</p><p>好久没写过一整套题了</p><h2 id="smooth"><a href="#smooth" class="headerlink" title="smooth"></a>smooth</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意转化为用前15个素数凑出第k小的数(每个素数可以乘多次)</p><p>类似于蚯蚓,最简单的方法就是维护一个优先队列,但由于优先队列带$log$如何优化掉</p><p>十五个单调队列\十五个单调指针</p><h4 id="十五个单调指针-其实还有一个队列"><a href="#十五个单调指针-其实还有一个队列" class="headerlink" title="十五个单调指针(其实还有一个队列)"></a>十五个单调指针(其实还有一个队列)</h4><p>举个例子,挺难说的</p><p>初始队列里只有1,十五个单调指针都指向1,表示为2<em>1,3</em>1,5*1,,,,,,,</p><p>第一轮发现2最小将2放进队列,并将2指针前移 此时2<em>2 3</em>1 5*1,,,,,,</p><p>又发现3最小 把3放进队列3指针前移,此时2<em>2 3</em>2 5*1</p><p>每次前移都是前移到队列中下一个数</p><p>这样还会出现重复,去一下重即可(不去重会T(重复状态很多))</p><h4 id="十五个队列"><a href="#十五个队列" class="headerlink" title="十五个队列"></a>十五个队列</h4><p>和上面类似,不再重复叙述,队列里存最大质因子为$p_j$,同样需要去重</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 1234567891011121314ll it[20],prime[20]=&#123;0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47&#125;;ll ans[11111111];ll b,k,cnt,tmp;int main()&#123;    ans[0]=1;    scanf(&quot;%lld%lld&quot;,&amp;b,&amp;k);    ll mnid,minn;    while(cnt&lt;k-1)&#123;        mnid=1,minn=inf;        for(ll j=1;j&lt;=b;j++)&#123;            while(ans[it[j]]*prime[j]&lt;=ans[cnt])it[j]++;            tmp=prime[j]*ans[it[j]];            if(tmp&lt;minn&amp;&amp;ans[cnt]&lt;minn)&#123;                minn=tmp;                mnid=j;            &#125;        &#125;        ans[++cnt]=minn;        it[mnid]++;    &#125;    printf(&quot;%lld\n&quot;,minn);&#125;</code></pre><p>单调指针</p><h2 id="six"><a href="#six" class="headerlink" title="six"></a>six</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这里用的是Paris神的状态定义,先%%%为敬,</p><p>一个质因子最多会分6批加入</p><p>判断非法就非常简单了</p><p>例如现在加入的某个数(6)有两个质因子2,3</p><p>如果之前2,3在同一批加入是合法的,例如之前加入12,现在加入6是合法的</p><p>如果2,3不是同一批被加入是非法的</p><p>还有一个数已经被加入两次,现在又加入是非法的之前有2,2现在又加入2(第三次)</p><p>八进制压位</p><p>0表示没有被加入</p><p>1<del>6表示第1</del>6批被加入</p><p>7表示已经加入过两次</p><blockquote><p>还有一个数已经被加入两次,现在又加入是非法的之前有2,2现在又加入2(第三次)</p></blockquote><p>类似情况判定</p><pre><code>                for(ll p=1;p&lt;=cnt;p++)                    if(s2&amp;&amp;s1)&#123;                    if(s2==7) goto eat_lunch;</code></pre><blockquote><p>如果之前2,3在同一批加入是合法的,例如之前加入12,现在加入6是合法的</p></blockquote><p>类似情况判定</p><pre><code>                    else if(!m) m=s2;                    else if(m!=s2) goto eat_lunch;</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;stdio.h&gt;#define ll long long#define s1 ((k&gt;&gt;(p-1))&amp;1)#define s2 ((j&gt;&gt;(3*(p-1))&amp;7))ll n,cnt,ans;const ll mod=1e9+7;ll rate[67],f[852741],t[741];int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=2;i*i&lt;=n;i++)&#123;        if(n%i==0)&#123;            cnt++;            while(n%i==0) n/=i,t[cnt]++;        &#125;    &#125;    if(n!=1) t[++cnt]=1;    for(ll i=1;i&lt;1&lt;&lt;cnt;i++)&#123;        rate[i]=1;        for(ll j=1;j&lt;=cnt;j++)&#123;            if((i&gt;&gt;(j-1))&amp;1)                rate[i]*=t[j];        &#125;    &#125;    f[0]=1;    for(ll j=0;j&lt;(1&lt;&lt;(cnt*3));j++)&#123;        if(f[j])&#123;            ans=(ans+f[j])%mod;//            printf(&quot;f[%lld]=%lld\n&quot;,j,f[j]);            for(ll k=1;k&lt;1&lt;&lt;cnt;k++)&#123;                ll x=0,now=j,m=0;                for(ll p=1;p&lt;=cnt;p++)                    if(!s2&amp;&amp;s1)&#123;                        x=p;                        break;                    &#125;                for(ll p=1;p&lt;=cnt;p++)                    if(s2&amp;&amp;s1)&#123;                    if(s2==7) goto eat_lunch;                    else if(!m) m=s2;                    else if(m!=s2) goto eat_lunch;                &#125;                for(ll p=1;p&lt;=cnt;p++)&#123;                    if(s1)&#123;                        if(s2) now|=7&lt;&lt;(3*(p-1));                        else now|=x&lt;&lt;(3*(p-1));                    &#125;                &#125;                f[now]=(f[now]+f[j]*rate[k])%mod;                eat_lunch:;            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans-1);&#125;</code></pre><p>View Code</p><h2 id="walker"><a href="#walker" class="headerlink" title="walker"></a>walker</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>随机化</p><p>为什么随机化是正解</p><p>因为其中有一半是正确的随便选出来两个正确总概率是$\frac{1}{4}$</p><p>进行50次全部出错概率${\frac{1}{4}}^50$</p><p>为什么选出两个</p><p>只选一个解不出来,,,,,,,,,,,,,,,,,</p><p>推式子得高斯消元系数是这样</p><p>自己手动推一下,其实很简单</p><pre><code>    a[1][1]=p[ii].bex,a[1][2]=-p[ii].bey,a[1][3]=1,a[1][4]=0,a[1][5]=p[ii].afx;    a[2][1]=p[ii].bey,a[2][2]=p[ii].bex,a[2][3]=0,a[2][4]=1,a[2][5]=p[ii].afy;    a[3][1]=p[jj].bex,a[3][2]=-p[jj].bey,a[3][3]=1,a[3][4]=0,a[3][5]=p[jj].afx;    a[4][1]=p[jj].bey,a[4][2]=p[jj].bex,a[4][3]=0,a[4][4]=1,a[4][5]=p[jj].afy;</code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define eps 1e-4#define A 789456struct node&#123;    double bex,bey,afx,afy;&#125;p[A];double dx,dy,the,s;double a[50][50];void gauss(ll n,ll ii,ll jj)&#123;    a[1][1]=p[ii].bex,a[1][2]=-p[ii].bey,a[1][3]=1,a[1][4]=0,a[1][5]=p[ii].afx;    a[2][1]=p[ii].bey,a[2][2]=p[ii].bex,a[2][3]=0,a[2][4]=1,a[2][5]=p[ii].afy;    a[3][1]=p[jj].bex,a[3][2]=-p[jj].bey,a[3][3]=1,a[3][4]=0,a[3][5]=p[jj].afx;    a[4][1]=p[jj].bey,a[4][2]=p[jj].bex,a[4][3]=0,a[4][4]=1,a[4][5]=p[jj].afy;    for(ll i=1;i&lt;=n;i++)&#123;        ll r=i;        for(ll j=i+1;j&lt;=n;j++)            if(fabs(a[j][i])&gt;fabs(a[r][i])) r=j;        if(fabs(a[r][i])&lt;eps) continue ;        if(r!=i)            for(ll j=1;j&lt;=n+1;j++)                swap(a[r][j],a[i][j]);        for(ll j=1;j&lt;=n;j++)&#123;            if(j==i) continue ;            for(ll k=n+1;k&gt;=i;k--)&#123;                a[j][k]-=a[j][i]/a[i][i]*a[i][k];            &#125;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        if(fabs(a[i][i])&gt;eps)            a[i][n+1]=a[i][n+1]/a[i][i];    &#125;    s=sqrt(a[1][5]*a[1][5]+a[2][5]*a[2][5]);    the=atan(a[2][5]/a[1][5]);    if(fabs(a[2][5]/s-sin(the))&gt;eps) the+=3.1415926535;    dx=a[3][5],dy=a[4][5];&#125;ll n;ll check()&#123;    ll haf=(n+1)/2;    ll cnt=0;    for(ll i=1;i&lt;=n;++i)&#123;        if(fabs(cos(the)*s*p[i].bex-s*sin(the)*p[i].bey+dx-p[i].afx)&lt;eps&amp;&amp;fabs(sin(the)*s*p[i].bex+cos(the)*s*p[i].bey+dy-p[i].afy)&lt;eps) ++cnt;        if(cnt&gt;=haf) return 1;    &#125;    return 0;&#125;int main()&#123;    srand((unsigned)time(0));    scanf(&quot;%lld&quot;,&amp;n);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lf%lf%lf%lf&quot;,&amp;p[i].bex,&amp;p[i].bey,&amp;p[i].afx,&amp;p[i].afy);    &#125;    ll times=90;    while(times)&#123;        ll aa=rand()%n+1,bb=rand()%n+1;        gauss(4,aa,bb);        while(s&lt;0||s&gt;10)&#123;            aa=rand()%n+1,bb=rand()%n+1;            gauss(4,aa,bb);            times--;        &#125;        if(check()) break;    &#125;    printf(&quot;%.10lf\n&quot;,the);    printf(&quot;%.10lf\n&quot;,s);    printf(&quot;%.10lf %.10lf\n&quot;,dx,dy);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试77_78部分题解</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9577_78%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9577_78%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-22 06:38</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Day1T2"><a href="#Day1T2" class="headerlink" title="Day1T2"></a>Day1T2</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>集合求交,求并维护时间戳,整体+,-维护一个变量</p><p>其实都挺套路的,但我考场什么都没想到,竟然还有60</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 3444444const ll sz=5000000;ll a[sz];ll *b=a+2500000;ll ans,m,opt,mark,n,k,size,T=1;int main()&#123;//    freopen(&quot;ex_jihe3.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;zj.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld&quot;,&amp;m);    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld&quot;,&amp;opt);        if(opt==1)&#123;            scanf(&quot;%lld&quot;,&amp;k);            for(ll i=1;i&lt;=k;i++)&#123;                scanf(&quot;%lld&quot;,&amp;n);                if(b[n-mark]!=T)&#123;                    b[n-mark]=T;                    ans+=n-mark;                    size++;                &#125;            &#125;        &#125;        else if(opt==2)&#123;            ++T;ans=0;size=0;            scanf(&quot;%lld&quot;,&amp;k);            for(ll i=1;i&lt;=k;i++)&#123;                scanf(&quot;%lld&quot;,&amp;n);                if(b[n-mark]==T-1)&#123;                    b[n-mark]=T;                                    ans+=n-mark;                    size++;//                    printf(&quot;n-mark=%lld sz=%lld\n&quot;,n-mark,size);                &#125;            &#125;        &#125;        else if(opt==3)&#123;            mark++;        &#125;        else if(opt==4)&#123;            mark--;        &#125;        printf(&quot;%lld\n&quot;,ans+mark*size);    &#125;&#125;</code></pre><p>View Code</p><h2 id="Day1T3"><a href="#Day1T3" class="headerlink" title="Day1T3"></a>Day1T3</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>部分分有一部分是$C_m^2$提示</p><p>我们其他也可以这么做,找到每一个极大联通空地同时联通相同颜色每一对都会造成贡献</p><p>但是这样会有多个联通的情况</p><p>可能会出现最多会出现两个颜色之间四联通,会算重</p><p>必须容斥</p><p>记录下每个块被那个极大联通空地链接</p><p>f1[x][col]记录被x连接颜色为col的情况</p><p>f2[x][y][col]记录被x,y两个联通块链接颜色为col的情况</p><p>f3[x][y][z][col],f4[w][x][y][z][col]</p><p>奇加偶减,f1,f2,f3,f4用map存一下即可</p><p>相邻单独考虑</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111struct node&#123;    ll bl1,bl2,bl3,bl4,col;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b,const ll &amp;c,const ll &amp;d,const ll &amp;e)&#123;        bl1=a,bl2=b,bl3=c,bl4=d,col=e;    &#125;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        if(a.bl1!=b.bl1) return a.bl1&lt;b.bl1;        if(a.bl2!=b.bl2) return a.bl2&lt;b.bl2;        if(a.bl3!=b.bl3) return a.bl3&lt;b.bl3;        if(a.bl4!=b.bl4) return a.bl4&lt;b.bl4;        return a.col&lt;b.col;    &#125;&#125;;map&lt;node,ll&gt; mp;ll bl[5][A][A],vis[A][A],col[A][A];ll nowx[5]=&#123;0,1,-1,0,0&#125;;ll nowy[5]=&#123;0,0,0,1,-1&#125;;ll n,m,k,tim,ans;void dfs(ll x,ll y)&#123;    vis[x][y]=tim;    if(col[x][y])&#123;        if(!bl[1][x][y]) bl[1][x][y]=tim;        else if(!bl[2][x][y]) bl[2][x][y]=tim;        else if(!bl[3][x][y]) bl[3][x][y]=tim;        else if(!bl[4][x][y]) bl[4][x][y]=tim;        return ;    &#125;    for(ll i=1;i&lt;=4;i++)&#123;        ll xnow=nowx[i]+x,ynow=nowy[i]+y;        if(xnow&gt;=1&amp;&amp;xnow&lt;=n&amp;&amp;ynow&gt;=1&amp;&amp;ynow&lt;=m&amp;&amp;vis[xnow][ynow]!=tim)&#123;            dfs(xnow,ynow);        &#125;    &#125;&#125;int main()&#123;//    freopen(&quot;ex_link4.in&quot;,&quot;r&quot;,stdin);    ll kk;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;kk);    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            scanf(&quot;%lld&quot;,&amp;col[i][j]);    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)&#123;            if(!vis[i][j]&amp;&amp;col[i][j]==0)&#123;                tim++;                dfs(i,j);            &#125;        &#125;    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            if(col[i][j])&#123;                if(bl[1][i][j])&#123;                    ans+=mp[node(bl[1][i][j],0,0,0,col[i][j])]++;                &#125;                if(bl[2][i][j])&#123;                    ans+=mp[node(bl[2][i][j],0,0,0,col[i][j])]++;                    ans-=mp[node(bl[1][i][j],bl[2][i][j],0,0,col[i][j])]++;                &#125;                if(bl[3][i][j])&#123;                    ans+=mp[node(bl[3][i][j],0,0,0,col[i][j])]++;                    ans-=mp[node(bl[2][i][j],bl[3][i][j],0,0,col[i][j])]++;                    ans-=mp[node(bl[1][i][j],bl[3][i][j],0,0,col[i][j])]++;                    ans+=mp[node(bl[1][i][j],bl[2][i][j],bl[3][i][j],0,col[i][j])]++;                &#125;                if(bl[4][i][j])&#123;                    ans+=mp[node(bl[4][i][j],0,0,0,col[i][j])]++;                    ans-=mp[node(bl[1][i][j],bl[4][i][j],0,0,col[i][j])]++;                    ans-=mp[node(bl[2][i][j],bl[4][i][j],0,0,col[i][j])]++;                    ans-=mp[node(bl[3][i][j],bl[4][i][j],0,0,col[i][j])]++;                    ans+=mp[node(bl[1][i][j],bl[2][i][j],bl[4][i][j],0,col[i][j])]++;                    ans+=mp[node(bl[1][i][j],bl[3][i][j],bl[4][i][j],0,col[i][j])]++;                    ans+=mp[node(bl[2][i][j],bl[3][i][j],bl[4][i][j],0,col[i][j])]++;                    ans-=mp[node(bl[1][i][j],bl[2][i][j],bl[3][i][j],bl[4][i][j],col[i][j])]++;                &#125;//                printf(&quot;%lld bl 4=%lld 3=%lld 2=%lld 1=%lld\n&quot;,ans,bl[4][i][j],bl[3][i][j],bl[2][i][j],bl[1][i][j]);            &#125;//    printf(&quot;%lld\n&quot;,ans);    for(ll i=1;i&lt;=n;i++)        for(ll j=2;j&lt;=m;j++)            if(col[i][j-1]&amp;&amp;col[i][j]&amp;&amp;col[i][j]==col[i][j-1])&#123;                ll ok=1;                for(ll k=1;k&lt;=4;k++)                    for(ll e=1;e&lt;=4;e++)                        if(bl[k][i][j]&amp;&amp;bl[e][i][j-1]&amp;&amp;bl[k][i][j]==bl[e][i][j-1])                            ok=0;                ans+=ok;            &#125;    for(ll i=2;i&lt;=n;i++)        for(ll j=1;j&lt;=m;j++)            if(col[i-1][j]&amp;&amp;col[i][j]&amp;&amp;col[i][j]==col[i-1][j])&#123;                ll    ok=1;                for(ll k=1;k&lt;=4;k++)                    for(ll e=1;e&lt;=4;e++)                        if(bl[k][i][j]&amp;&amp;bl[e][i-1][j]&amp;&amp;bl[k][i][j]==bl[e][i-1][j])                            ok=0;            ans+=ok;        &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><h2 id="Day2T3"><a href="#Day2T3" class="headerlink" title="Day2T3"></a>Day2T3</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>假设环上点为黑点,其他点为白点,我们现在要统计的就是max(白点到最近黑点距离)</p><p>假设黑点中深度最小的为B</p><p>开这样几个数组ff[x]表示从x走到父亲后能走到最远距离</p><p>g[x]表示从x向下走到距离最远是多少</p><p>然而可能有最多两个黑点将路径堵塞,所以记录最大值,次大值,次次大值,</p><p>黑点即使将最大值次大值堵上,你可以走次次大值</p><p>然后贡献可以分为两部分</p><p>每个黑点g,最上点ff</p><p>这样复杂度仍然会炸</p><p>考虑优化求每个黑点g</p><p>发现lca路径上除了lca其他点只和一个儿子黑点相邻</p><p>q[x]表示从x走到父亲路径上向下走但不经过x达到最远点</p><p>然后倍增优化一下</p><p>现在贡献变成g[lca],g[x],g[y],q[lca路径上],ff[lca]</p><p>分别维护一下</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1111111ll n,tot=1,tim,m,t;ll head[A],ver[A],nxt[A],du[211111],deep[A],qjdis[A],zj[A];ll maxcost[A][25],f[A][25];ll ans=0;pair&lt;ll,ll&gt;g[A][3],dis[A],ff[A],q[A][25];pair&lt;ll,ll&gt;tmp;void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;ll lca(ll x,ll y)&#123;    pair&lt;ll,ll&gt; pr;ll now=0;    pr=make_pair(0,0);        if(deep[x]&gt;deep[y]) swap(x,y);    ll lastx=x,lasty=y;    for(ll i=t;i&gt;=0;i--)&#123;        if(deep[x]==deep[y]) break;        if(deep[x]&lt;=deep[f[y][i]]) &#123;            pr=max(pr,q[y][i]);            y=f[y][i];        &#125;    &#125;    if(x==y) &#123;        ll lcq=x;        return max(pr.first,max(ff[lcq].first,g[lasty][0].first));    &#125;    for(ll i=t;i&gt;=0;i--)&#123;        if(f[x][i]!=f[y][i]) &#123;            pr=max(pr,q[x][i]);            pr=max(pr,q[y][i]);            x=f[x][i],y=f[y][i];        &#125;    &#125;    ll lcq=f[x][0];    if((g[lcq][0].second==x&amp;&amp;g[lcq][1].second==y)||(g[lcq][1].second==x&amp;&amp;g[lcq][0].second==y))&#123;        now=max(g[lcq][2].first,pr.first);    &#125;    else if((g[lcq][0].second==x&amp;&amp;g[lcq][1].second!=y)||(g[lcq][0].second==y&amp;&amp;g[lcq][1].second!=x))&#123;        now=max(g[lcq][1].first,pr.first);    &#125;    else &#123;        now=max(g[lcq][0].first,pr.first);    &#125;    now=max(now,ff[lcq].first);    now=max(now,max(g[lastx][0].first,g[lasty][0].first));    return now;&#125;pair&lt;ll,ll&gt; dfs1(ll x,ll pre)&#123;    dis[x]=make_pair(0,0);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        f[y][0]=x;        deep[y]=deep[x]+1;        pair&lt;ll,ll&gt; d=dfs1(y,x);        dis[x]=max(dis[x],d);    &#125;    return make_pair(dis[x].first+1,dis[x].second);&#125;void dfs2(ll x,ll pre)&#123;    pair&lt;ll,ll&gt; fir,sec,thi,tmp;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        if((dis[y].first+1)&gt;fir.first)&#123;            thi=sec;sec=fir;fir=make_pair(dis[y].first+1,y);        &#125;        else if((dis[y].first+1)&gt;sec.first)&#123;            thi=sec;            sec=make_pair(dis[y].first+1,y);        &#125;        else if((dis[y].first+1)&gt;thi.first)&#123;            thi=make_pair(dis[y].first+1,y);        &#125;    &#125;    g[x][0]=make_pair(fir.first,fir.second);    g[x][1]=make_pair(sec.first,sec.second);    g[x][2]=make_pair(thi.first,thi.second);    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        if(dis[y].first+1==fir.first) q[y][0]=sec;        else q[y][0]=fir;    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dfs2(y,x);    &#125;&#125;void redfs(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        ff[y]=ff[x];        if(y==g[x][0].second)            ff[y]=max(ff[y],g[x][1]);        else ff[y]=max(ff[y],g[x][0]);        ff[y]=make_pair(ff[y].first+1,ff[y].second);    &#125;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        redfs(y,x);    &#125;&#125;void dfs3(ll x,ll pre)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dfs3(y,x);        ans=max(zj[x]+zj[y]+1,ans);        zj[x]=max(zj[x],zj[y]+1);    &#125;&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    t=log(n)/log(2)+1;    for(ll i=1;i&lt;n;i++)&#123;        ll a,b;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        add(a,b);        add(b,a);    &#125;    dfs1(1,0);    dfs2(1,0);    dfs3(1,0);    redfs(1,0);    f[1][0]=1;    for(ll j=1;j&lt;=t;j++)&#123;        for(ll i=1;i&lt;=n;i++)&#123;            f[i][j]=f[f[i][j-1]][j-1];            q[i][j]=max(q[f[i][j-1]][j-1],q[i][j-1]);        &#125;    &#125;    scanf(&quot;%lld&quot;,&amp;m);    for(ll i=1;i&lt;=m;i++)&#123;        ll a,b;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        if(a==b)&#123;            printf(&quot;%lld\n&quot;,(ans)/2+1);            continue ;        &#125;        printf(&quot;%lld\n&quot;,lca(a,b));    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试44「D·E·F」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9544%E3%80%8CD%C2%B7E%C2%B7F%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9544%E3%80%8CD%C2%B7E%C2%B7F%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-17 16:36</p><p>用心出题,用脚造数据</p><p>乱搞场</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 #define re register 3 #define int long long 4 #define inf 0x7ffffffffffffff 5 using namespace std; 6 int n,a[100010],b[100010],ans=inf; 7 double st,ed; 8 inline int read()&#123; 9     re int a=0,b=1; re char ch=getchar();10     while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)11         b=(ch==&#39;-&#39;)?-1:1,ch=getchar();12     while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)13         a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48),ch=getchar();14     return a*b;15 &#125;16 inline int max(re int x,re int y)&#123;if(x&gt;y) return x; return y;&#125;17 inline int min(re int x,re int y)&#123;if(x&lt;y) return x; return y;&#125;18 inline void dfs(re int x,re int l,re int r,re int ll,re int rr)&#123;19     if(1ll*(r-l)*(rr-ll)&gt;ans) return ;20     if(x&gt;n)&#123;21         ans=1ll*(r-l)*(rr-ll); 22         ed=clock();23         if((ed-st)/1e6&gt;=1.99)&#123;24             printf(&quot;%lld\n&quot;,ans);25             exit(0);26         &#125;27         return ; 28     &#125;29     dfs(x+1,max(l,a[x]),min(r,a[x]),max(ll,b[x]),min(rr,b[x]));30     dfs(x+1,max(l,b[x]),min(r,b[x]),max(ll,a[x]),min(rr,a[x]));31 &#125;32 signed main()&#123;33 //    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);34     n=read();if(n==1)&#123;puts(&quot;1&quot;);return 0;&#125;35     for(re int i=1;i&lt;=n;++i)&#123;36         a[i]=read(),b[i]=read();37         if(a[i]&lt;b[i]) a[i]^=b[i]^=a[i]^=b[i];38     &#125;39     st=clock();40     dfs(1,0,inf,0,inf);41     printf(&quot;%lld\n&quot;,ans);42     return 0;43 &#125;</code></pre><p>随机化</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;algorithm&gt; 4 #include&lt;cstring&gt; 5 #include&lt;bits/stdc++.h&gt; 6 #define reg register 7 using namespace std; 8 typedef long long ll; 9 const int maxn=1e5+5,INF=2e9;10 inline void read(int &amp;x)11 &#123;12     x=0;char c=getchar();13     while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;) c=getchar();14     while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-48,c=getchar();15 &#125;16 ll ans;17 int S,T,n,tot,L[maxn][2],R[maxn][2],L2[2],R2[2],tmp[2],yet[maxn];18 struct ball&#123;19     int x[2];20 &#125;c[maxn];21 struct wh&#123;22     int x,id,f;23     bool friend operator &lt; (const wh a,const wh b) &#123;return a.x&lt;b.x;&#125;24 &#125;g[maxn&lt;&lt;1];25 void dfs(int x)26 &#123;27     T=clock();28     if(T-S&gt;1500000) &#123;printf(&quot;%lld\n&quot;,ans);exit(0);&#125;29     if(x!=1&amp;&amp;1LL*(L[x-1][1]-L[x-1][0])*(R[x-1][1]-R[x-1][0])&gt;ans) return ;30     if(x==n+1) &#123;ans=1LL*(L[x-1][1]-L[x-1][0])*(R[x-1][1]-R[x-1][0]);return ;&#125;31     if(c[x].x[0]&gt;c[x].x[1]) swap(c[x].x[0],c[x].x[1]);32     for(reg int j=0;j&lt;=1;++j)    33     &#123;34         L[x][0]=min(L[x-1][0],c[x].x[j]);35         L[x][1]=max(L[x-1][1],c[x].x[j]);36         R[x][0]=min(R[x-1][0],c[x].x[j^1]);37         R[x][1]=max(R[x-1][1],c[x].x[j^1]);38         dfs(x+1);39     &#125;40 &#125;41 int main()42 &#123;43     srand(time(NULL));44     S=clock();45 //    freopen(&quot;ans.in&quot;,&quot;r&quot;,stdin);46 //    freopen(&quot;b.out&quot;,&quot;w&quot;,stdout);47     read(n);48     for(reg int i=1;i&lt;=n;++i)49     &#123;50         read(c[i].x[0]),read(c[i].x[1]);51         g[++tot]=(wh)&#123;c[i].x[0],i,0&#125;;52         g[++tot]=(wh)&#123;c[i].x[1],i,1&#125;;53     &#125;54     reverse(c+1,c+n+1);55     sort(g+1,g+tot+1);56     ans=1e18;ans+=5;57     int l=1,r=tot,k=0;58     memset(yet,0xFF,sizeof(yet));59     while(k&lt;n)60     &#123;61         while(yet[g[l].id]!=-1) ++l;62         yet[g[l].id]=g[l].f;++k;63         if(k==n) break;64         while(yet[g[r].id]!=-1) --r;65         yet[g[r].id]=g[r].f;++k;66     &#125;67     L[0][0]=R[0][0]=L2[0]=R2[0]=INF;68     for(reg int i=1;i&lt;=n;++i)69     &#123;70         L2[0]=min(L2[0],c[i].x[yet[i]]);71         L2[1]=max(L2[1],c[i].x[yet[i]]);72         R2[0]=min(R2[0],c[i].x[yet[i]^1]);73         R2[1]=max(R2[1],c[i].x[yet[i]^1]);74     &#125;75     ans=1LL*(L2[1]-L2[0])*(R2[1]-R2[0]);76     dfs(1);77     printf(&quot;%lld\n&quot;,ans);78     return 0;79 &#125;</code></pre><p>clock</p><p>垃圾zzn当然什么也不会啦,乱搞什么也没打</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>考试时想到正解,没打,觉得这仅仅是个简单的剪枝,没想到啊</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求$(r-l+1)*gcd(a[l],a[l+1],…..,a[r])$最大值</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>垃圾zzn没打正解,类正解多$log$用来二分了,常数较小</p><p>$gcd$总需要求,求次数太多了</p><p>考虑二分,维护$gcd$从$mid$前缀和后缀和</p><p>这样你就有$50$分了</p><p>考虑$gcd$变化次数小于是维护单调队列,很简单</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 #define ll long long 4 #define A 333333 5 ll a[A],suml[A],sumr[A],dll[A],dlr[A]; 6 ll ans=0,n; 7 ll gcd(ll x,ll y)&#123; 8     if(y==0) return x; 9     return gcd(y,x%y);10 &#125;11 void solve(ll l,ll r)&#123;12     if(l==r) return ;13     ll mid=(l+r)&gt;&gt;1,rnow=mid+1,lnow=mid;14     suml[lnow]=a[lnow],sumr[rnow]=a[rnow];15     dll[0]=0,dlr[0]=0;16     while(lnow&gt;l)&#123;17         lnow--;18         suml[lnow]=gcd(suml[lnow+1],a[lnow]);19         if(suml[lnow]!=suml[lnow+1])20             dll[++dll[0]]=lnow+1;21     &#125;22     dll[++dll[0]]=l;23     while(rnow&lt;r)&#123;24         rnow++;25         sumr[rnow]=gcd(sumr[rnow-1],a[rnow]);26         if(sumr[rnow]!=sumr[rnow-1])27             dlr[++dlr[0]]=rnow-1;28     &#125;29     dlr[++dlr[0]]=r;30     for(ll lh=1;lh&lt;=dll[0];lh++)31         for(ll rh=1;rh&lt;=dlr[0];rh++)&#123;32             ll nowl=dll[lh],nowr=dlr[rh];33             ll g=gcd(suml[nowl],sumr[nowr]);34 //            printf(&quot;nowl=%lld nowr=%lld =%lld\n&quot;,dll[lh],dlr[rh],g*(nowr-nowl+1));35             if(g==1) break;36             ans=max(ans,g*(nowr-nowl+1));37         &#125;38     ans=max(ans,gcd(suml[l],sumr[r])*(r-l+1));39     solve(l,mid);solve(mid+1,r);40 &#125;41 //10 10 101 10 10 42 int main()&#123;43 //    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);44 //    freopen(&quot;ans.sol&quot;,&quot;w&quot;,stdout);45     scanf(&quot;%lld&quot;,&amp;n);46     for(ll i=1;i&lt;=n;i++)&#123;47         scanf(&quot;%lld&quot;,&amp;a[i]);48     &#125;49     solve(1,n);50     printf(&quot;%lld\n&quot;,ans);51 &#125;</code></pre><p>View Code</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="这个题真的很迷"><a href="#这个题真的很迷" class="headerlink" title="这个题真的很迷"></a>这个题真的很迷</h3><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190917162820457-57754892.png"></p><p>垃圾zzn考试时打的第二个贪心,然后只有$60$分,事实上单纯第一个贪心就可以$100$分,数据特别水,第一个贪心明明连样例都过不去</p><p>没遇到数据这么水的,</p><p>正确性垃圾zzn当然不会验证啦</p><p>代码也懒的放了</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>0分算法</p><p>直接暴力$dp$</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 #define ll long long 4 ll f[2][2019][2019],w[2019]; 5 ll a,b,n,q; 6 int main()&#123; 7     scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;q,&amp;a,&amp;b); 8     memset(f,0x7f,sizeof(f)); 9     for(ll i=1;i&lt;=q;i++)10         scanf(&quot;%lld&quot;,&amp;w[i]);11     f[1][a][w[1]]=abs(b-w[1]);12     f[1][w[1]][b]=abs(a-w[1]);13     for(ll i=2;i&lt;=q;i++)&#123;14         memset(f[i&amp;1],0x7f,sizeof(f[i&amp;1]));15         for(ll j=1;j&lt;=n;j++)&#123;16         f[i&amp;1][j][w[i]]=min(f[i&amp;1][j][w[i]],f[(i-1)&amp;1][j][w[i-1]]+abs(w[i]-w[i-1]));//w[i-1]移动到w[i]17         f[i&amp;1][w[i]][w[i-1]]=min(f[i&amp;1][w[i]][w[i-1]],f[(i-1)&amp;1][j][w[i-1]]+abs(j-w[i]));//j移动到w[i]18         f[i&amp;1][w[i]][j]=min(f[i&amp;1][w[i]][j],f[(i-1)&amp;1][w[i-1]][j]+abs(w[i]-w[i-1]));//w[i-1]移动到w[i]19         f[i&amp;1][w[i-1]][w[i]]=min(f[i&amp;1][w[i-1]][w[i]],f[(i-1)&amp;1][w[i-1]][j]+abs(j-w[i]));//j移动到w[i]20         &#125;21     &#125;22     ll ans=0x7fffffff;23     for(ll j=1;j&lt;=n;j++)&#123;24         ans=min(ans,min(f[q&amp;1][j][w[q]],f[q&amp;1][w[q]][j]));25     &#125;26     printf(&quot;%lld\n&quot;,ans);27 &#125;</code></pre><p>View Code</p><p>30分算法</p><p>有一维一定是$w[i]$</p><p>考虑去掉一维</p><p>$f[i][j]&#x3D;f[i-1][j]+abs(w[i]-w[i-1])$另一个指针从$w[i-1]$移动到$w[i]$</p><p>$f[i][w[i-1]]&#x3D;f[i-1][j]+abs(j-w[i])$从$j$移动到$w[i]$</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll f[2][2019],w[2019];ll a,b,n,q;int main()&#123;    scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;q,&amp;a,&amp;b);    memset(f,0x7f,sizeof(f));    for(ll i=1;i&lt;=q;i++)        scanf(&quot;%lld&quot;,&amp;w[i]);    f[1][a]=abs(b-w[1]);    f[1][b]=abs(a-w[1]);    for(ll i=2;i&lt;=q;i++)&#123;        memset(f[i&amp;1],0x7f,sizeof(f[i&amp;1]));        for(ll j=1;j&lt;=n;j++)&#123;        f[i&amp;1][j]=min(f[i&amp;1][j],f[(i-1)&amp;1][j]+abs(w[i]-w[i-1]));        f[i&amp;1][w[i-1]]=min(f[i&amp;1][w[i-1]],f[(i-1)&amp;1][j]+abs(j-w[i]));        f[i&amp;1][j]=min(f[i&amp;1][j],f[(i-1)&amp;1][j]+abs(w[i]-w[i-1]));        f[i&amp;1][w[i-1]]=min(f[i&amp;1][w[i-1]],f[(i-1)&amp;1][j]+abs(j-w[i]));        &#125;    &#125;    ll ans=0x7fffffff;    for(ll j=1;j&lt;=n;j++)&#123;        ans=min(ans,min(f[q&amp;1][j],f[q&amp;1][j]));    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>100分算法</p><p>两个转移式子</p><p>$f[i][j]&#x3D;f[i-1][j]+abs(w[i]-w[i-1])$</p><p>$f[i][w[i-1]]&#x3D;f[i-1][j]+abs(j-w[i])$</p><p>发现第一个式子就是区间加,第二个式子单点赋值</p><p>单点赋值赋的就是$min$,有个$abs$怎么办维护$f-j$最小值和$f+j$最小值</p><pre><code>        memset(askmin,0x7f,sizeof(askmin));        seg_min(1,1,w[i],2);//p[i]比当前点大,那么取p[i]-l        seg_min(1,w[i],n,1);//p[i]比当前值小,取l-p[i]    //    printf(&quot;ask=%lld %lld\n&quot;,askmin[1],askmin[2]);        askmin[1]-=w[i];        askmin[2]+=w[i];        ll nowmin=min(askmin[1],askmin[2]);</code></pre><p>线段树优化一下</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 using namespace std; 3 #define ll long long 4 ll w[1010101],askmin[4]; 5 ll a,b,n,q; 6 struct tree&#123; 7     ll l,r,f,minn[4]; 8 &#125;tr[1010101]; 9 void up(ll x)&#123;10     for(ll i=1;i&lt;=3;i++)11         tr[x].minn[i]=min(tr[x&lt;&lt;1].minn[i],tr[x&lt;&lt;1|1].minn[i]);12 &#125;13 void down(ll x)&#123;14     tr[x&lt;&lt;1].f+=tr[x].f;15     tr[x&lt;&lt;1|1].f+=tr[x].f;16     for(ll i=1;i&lt;=3;i++)17         tr[x&lt;&lt;1].minn[i]+=tr[x].f,tr[x&lt;&lt;1|1].minn[i]+=tr[x].f;18     tr[x].f=0;19 &#125;20 void built(ll x,ll l,ll r)&#123;//printf(&quot;builx=%lld\n&quot;,x);21     tr[x].l=l,tr[x].r=r;22     if(l==r)&#123;23         if(l==a||l==b)&#123;24             tr[x].minn[3]=abs(a+b-l-w[1]);25 //            printf(&quot;tr3=%lld\n&quot;,tr[x].minn[3]);26             tr[x].minn[1]=tr[x].minn[3]+l;27             tr[x].minn[2]=tr[x].minn[3]-l;28         &#125;29         else tr[x].minn[1]=tr[x].minn[2]=tr[x].minn[3]=0x7ffffffffff;30         return ;31     &#125;32     ll mid=(l+r)&gt;&gt;1;33     built(x&lt;&lt;1,l,mid);34     built(x&lt;&lt;1|1,mid+1,r);35     up(x);36 &#125;37 void seg_min(ll x,ll l,ll r,ll zl)&#123;38 //    printf(&quot;l=%lld r=%lld\n&quot;,l,r);39     if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;40 //        printf(&quot;tr[%lld].minn[%lld]=%lld l=%lld r=%lld\n&quot;,x,zl,tr[x].minn[zl],tr[x].l,tr[x].r);41         askmin[zl]=min(askmin[zl],tr[x].minn[zl]);42         return ;43     &#125;44     down(x);45     ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;46     if(mid&gt;=l) seg_min(x&lt;&lt;1,l,r,zl);47     if(mid&lt;r) seg_min(x&lt;&lt;1|1,l,r,zl);48     up(x);49 &#125;50 void add(ll x,ll point,ll val)&#123;51     if(tr[x].l==tr[x].r)&#123;52         tr[x].minn[3]=min(tr[x].minn[3],val);53         tr[x].minn[1]=tr[x].minn[3]+tr[x].l;54         tr[x].minn[2]=tr[x].minn[3]-tr[x].l;55         return ;56     &#125;57     down(x);58     ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;59     if(point&lt;=mid) add(x&lt;&lt;1,point,val);60     else add(x&lt;&lt;1|1,point,val);61     up(x);62 &#125;63 int main()&#123;64     scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;q,&amp;a,&amp;b);65     for(ll i=1;i&lt;=q;i++)66         scanf(&quot;%lld&quot;,&amp;w[i]);67     built(1,1,n);68     for(ll i=2;i&lt;=q;i++)&#123;69         memset(askmin,0x7f,sizeof(askmin));70         seg_min(1,1,w[i],2);//p[i]比当前点大,那么取p[i]-l71         seg_min(1,w[i],n,1);//p[i]比当前值小,取l-p[i]72     //    printf(&quot;ask=%lld %lld\n&quot;,askmin[1],askmin[2]);73         askmin[1]-=w[i];74         askmin[2]+=w[i];75         ll nowmin=min(askmin[1],askmin[2]);76     //    printf(&quot;nowmin=%lld\n&quot;,nowmin);77         tr[1].f+=abs(w[i]-w[i-1]);78         for(ll j=1;j&lt;=3;j++)79             tr[1].minn[j]+=abs(w[i]-w[i-1]);80         add(1,w[i-1],nowmin);81     &#125;82     printf(&quot;%lld\n&quot;,tr[1].minn[3]);83 &#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试42「世界线·时间机器·密码」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9542%E3%80%8C%E4%B8%96%E7%95%8C%E7%BA%BF%C2%B7%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%C2%B7%E5%AF%86%E7%A0%81%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9542%E3%80%8C%E4%B8%96%E7%95%8C%E7%BA%BF%C2%B7%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%C2%B7%E5%AF%86%E7%A0%81%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-13 11:30</p><p>$t3$不会</p><h2 id="世界线"><a href="#世界线" class="headerlink" title="世界线"></a>世界线</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目让求的就是每个点能到点的数量$-$出度</p><p>设每个点能到的点为$f[x]$</p><p>则$f[x]&#x3D;x \sum\limits_{y}^{y\in son[x]} U f[y]$</p><p>用$bitset$优化一下即可,但单纯这样会炸内存,随意$yy$一下,时间换空间,像平衡树一样开个垃圾桶都行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 60001ll dl[A],ans[A],head[A*5],nxt[A*5],ver[A*5],out[A],in[A];ll n,m,tot,sbzzn=0;bitset&lt;5005&gt; bit[A];void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void top()&#123;    deque&lt;ll&gt; q;    for(ll i=1;i&lt;=n;i++)        if(in[i]==0) q.push_back(i);    while(!q.empty())&#123;        ll top_now=q.front();//        printf(&quot;dl[0]=%d top_now=%d\n&quot;,dl[0],top_now);        dl[++dl[0]]=top_now;        q.pop_front();        for(ll i=head[top_now];i;i=nxt[i])&#123;            ll y=ver[i];    //        printf(&quot;top_now=%d y=%d in[y]=%d\n&quot;,top_now,y,in[y]);            in[y]--;            if(in[y]==0) q.push_back(y);        &#125;    &#125;&#125;void count()&#123;    for(ll l=1,r=5000;l&lt;=n;l=r+1,r+=5000)&#123;        for(ll i=1;i&lt;=n;i++)            bit[i].reset();        for(ll i=dl[0];i&gt;=1;i--)&#123;            ll x=dl[i];            for(ll j=head[x];j;j=nxt[j])&#123;                ll y=ver[j];                bit[x]|=bit[y];            &#125;            ans[x]+=bit[x].count();            if(x&gt;=l&amp;&amp;x&lt;=r) bit[x][x-l]=1;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        sbzzn+=ans[i]-out[i];    &#125;    printf(&quot;%d\n&quot;,sbzzn);&#125;int main()&#123;//freopen(&quot;worldline2.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;haha2.in&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(ll i=1,a,b;i&lt;=m;i++)&#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        in[b]++;        out[a]++;        add(a,b);    &#125;    top();    count();&#125;</code></pre><p>View Code</p><h2 id="时间机器"><a href="#时间机器" class="headerlink" title="时间机器"></a>时间机器</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>贪心,简单线段覆盖贪心,按照左端点排序,从左端点找到右端点最靠左且能覆盖的解</p><p>验证正确性</p><p>每次枚举到左端点之前所有比当前左端点还靠左的端点都已经考虑完,若当前取不是最符合的一定不会使结果变优,若当前点放不了一定无解</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 501010ll T;ll n,m;struct node&#123;    ll l,r,cnt,op;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;            return (a.l==b.l)?a.op&lt;b.op:a.l&lt;b.l;    &#125;&#125;t[A];map&lt;ll,ll&gt; mp;map&lt;ll,ll&gt; :: iterator it;ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c)) &#123;        if(c==&#39;-&#39;) f=-1;        c=getchar();    &#125;    while(isdigit(c))&#123;        x=x*10+c-&#39;0&#39;;        c=getchar();    &#125;    return f*x;&#125;int main()&#123;    T=read();    while(T--)&#123;        n=read();m=read();        mp.clear();        ll cnt=0;//先节点,再电阻        for(ll i=1;i&lt;=n;i++)            t[++cnt].l=read(),t[cnt].r=read(),t[cnt].cnt=read(),t[cnt].op=1;        for(ll i=1;i&lt;=m;i++)            t[++cnt].l=read(),t[cnt].r=read(),t[cnt].cnt=read(),t[cnt].op=-1;        ll ok=1;//printf(&quot;oo\n&quot;);        sort(t+1,t+1+cnt);        //存节点,拿节点匹配电阻        for(ll i=1;i&lt;=cnt;i++)&#123;            //printf(&quot;t.op=%lld\n&quot;,t[i].op);            if(t[i].op==-1)                mp[t[i].r]+=t[i].cnt;            else&#123;                while(t[i].cnt)&#123;                    it=mp.lower_bound(t[i].r);            //        printf(&quot;mp[%lld]=%lld\n&quot;,t[i].r,mp[t[i].r]);                    if(it==mp.end())&#123;                        ok=0;                        break;                    &#125;                    if(t[i].cnt&gt;=it-&gt;second) t[i].cnt-=it-&gt;second,mp.erase(it);                    else it-&gt;second-=t[i].cnt,t[i].cnt=0;                //    printf(&quot;mp[%lld]=%lld\n&quot;,t[i].r,mp[t[i].r]);                &#125;                if(!ok)break;            &#125;        &#125;        if(ok==0) printf(&quot;No\n&quot;);        else printf(&quot;Yes\n&quot;);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-s模拟测试41「夜莺与玫瑰·玫瑰花精·影子」</title>
      <link href="/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9541%E3%80%8C%E5%A4%9C%E8%8E%BA%E4%B8%8E%E7%8E%AB%E7%91%B0%C2%B7%E7%8E%AB%E7%91%B0%E8%8A%B1%E7%B2%BE%C2%B7%E5%BD%B1%E5%AD%90%E3%80%8D/"/>
      <url>/2025/03/14/csp-s%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9541%E3%80%8C%E5%A4%9C%E8%8E%BA%E4%B8%8E%E7%8E%AB%E7%91%B0%C2%B7%E7%8E%AB%E7%91%B0%E8%8A%B1%E7%B2%BE%C2%B7%E5%BD%B1%E5%AD%90%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-09 21:42</p><h2 id="夜莺与玫瑰"><a href="#夜莺与玫瑰" class="headerlink" title="夜莺与玫瑰"></a>夜莺与玫瑰</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>联赛$T1$莫比乌斯$%%%$</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190909211940433-1431131172.png"></p><p>$dead$ $line$是直线</p><p>首先横竖就是$n+m$这比较显然</p><p>枚举方向向量</p><p>首先我们枚举方向向量时只枚举右下方向,显然贡献$*2$就是所有斜着的直线</p><p>$i,j$表示当自己向右$i$个单位长度,向下$j$单位长度</p><p>我们相同斜率下只算最短的线贡献,(因为其他长度下方案数都包含在最短里面了)</p><p>我们方向向量$i$,$j$的$gcd(i,j)&#x3D;&#x3D;1$时我们枚举的才是当前斜率最短长度,</p><p>然后考虑贡献</p><p>考虑容斥,先算出来当前长度下所有线段再减去重合的</p><p>$(n-a)*(m-b)$是总方案数,考虑重合部分</p><p>假设我们有一个4*4点阵</p><p>. . . .</p><p>. . . .</p><p>. . . .</p><p>. . . .</p><p>我们算1,1方向向量贡献</p><p>\ \ \ .</p><p>\ \ \ \</p><p>\ \ \ \</p><p>. \ \ \</p><p>只有</p><p>\ \ \ .</p><p>\ \ \ \</p><p>\ \ \ \</p><p>. \ \ \</p><p>标蓝才有贡献,别的都是算重的</p><p>定义前趋为$x-1$ $y-1$,后继$x+1$ $y+1$</p><p>观察这些线发现符合条件就是前趋不在点阵而后继在点阵数量</p><p>例如$1$,$1$这个点$+$方向向量得到$-1$ $-1$ 和$2$ $2$</p><p>因为$-1$ $-1$不在点阵内所以是合法的</p><p>,我们把他们都提到与边界相重</p><p>看他们相减后是否在边界中即可</p><p>重复的部分就是$max((n-2*a),0)<em>max((m-2</em>b),0)$</p><p>$\sum\limits_ {a&#x3D;1}^{a&lt;&#x3D;n} \sum\limits_{b&#x3D;1}^{b&lt;&#x3D;m}<br><a href="n-a">gcd(a,b)&#x3D;&#x3D;1</a><em>(m-b)-max((n-2</em>a),0)<em>max((m-2</em>b),0)$</p><p>这样我们还是$AC$不了$T&#x3D;10000$稍巨</p><p>所以我们预处理一下,让查询变成$O(n)$的$(其实可以是O(1))然而出题人还卡空间$</p><p>把原式子拆成$(n-a)*m-(n-a)<em>b$每一个$gcd(a,b)&#x3D;&#x3D;1$都会对第一个式子造成贡献,而后面那个式子就是$(n-a)</em>{\sum\limits_{b&#x3D;1}^{b&lt;&#x3D;m}<br>[gcd(a,b)&#x3D;&#x3D;1] b}$</p><p>维护前缀和$tot(a,m)$表示$b&#x3D;1–m所有数中$与$a$,$gcd&#x3D;&#x3D;1$的个数和为$tot(a,m)$,</p><p>$sum(a,m)$表示$b&#x3D;1–m$中所有$gcd(a,b)&#x3D;&#x3D;1$对应$\sum\limits_{b&#x3D;1}^{b&lt;&#x3D;m} [gcd(a,b)&#x3D;&#x3D;1]<br>b$和为$sum(a,m)$</p><p>所以式子$\sum\limits_ {a&#x3D;1}^{a&lt;&#x3D;n} \sum\limits_{b&#x3D;1}^{b&lt;&#x3D;m}<br><a href="n-a">gcd(a,b)&#x3D;&#x3D;1</a><em>(m-b)$可以化为$(n-a)</em>(tot(a,m)*m-sum(a,m))$</p><p>后面这个式子类似</p><p>首先如果$(n-2<em>a)&lt;&#x3D;0$或$(m-2</em>b)&lt;&#x3D;0$就不用减了</p><p>所以$m-2*b&gt;0$才可以即$b&lt;\frac{m}{2}$</p><p>所以后面式子可以化为$(n-2<em>a)</em>(tot(a,\frac{m}{2})<em>m-2</em>sum(a,\frac{m}{2}))$</p><p>总式子就是$\sum\limits_{a&#x3D;1}^{a&lt;&#x3D;n}<br>(n-a)<em>(tot(a,m)<em>m-sum(a,m))-(n-2</em>a)</em>(tot(a,\frac{m}{2})<em>m-2</em>sum(a,\frac{m}{2}))$</p><p>单单是这样你还是$AC$不了$4000*4000$枚举$gcd$很慢,你需要递推</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int T,n,m,sum[4100][4100];const int mod=1073741824;short num[4100][4100],g[4100][4100];int gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125;int main()&#123;    for(register int i=1;i&lt;=4001;i++)&#123;        g[i][i]=g[0][i]=g[i][0]=i;        for(register int j=1;j&lt;i;j++)&#123;            g[i][j]=g[j][i]=g[j][i%j];        &#125;    &#125;    for(register int i=1;i&lt;=4001;i++)&#123;        for(register int j=1;j&lt;=4001;j++)&#123;            sum[i][j]=sum[i][j-1];            num[i][j]=num[i][j-1];            if(g[i][j]==1) sum[i][j]=(sum[i][j]+j)%mod,num[i][j]++;        &#125;    &#125;    scanf(&quot;%d&quot;,&amp;T);    while(T--)&#123;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        long long ans=0;        for(register int i=1;i&lt;n;i++)&#123;            ans=(ans+(num[i][m]*m%mod-sum[i][m]%mod)*(n-i)%mod)%mod;            if(2*i&lt;n) ans=ans-(num[i][m/2]*m%mod-2*sum[i][m/2]%mod)*(n-i*2)%mod;        &#125;        ans=(ans*2%mod+n+m)%mod;        printf(&quot;%lld\n&quot;,(ans+mod)%mod);    &#125;&#125;</code></pre><p>View Code</p><p>夜莺</p><h2 id="玫瑰花精"><a href="#玫瑰花精" class="headerlink" title="玫瑰花精"></a>玫瑰花精</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>抱歉,题解没时间写了</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>对于 100%的数据可以考虑线段树。首先我们对区间[1..n]建立一棵线段树。对于每一个节点,维护 4 个值。分别是 l,r,mid,p。l 表示在当前结点线段树所在区间最左边的花精所在的位置,r 表示最右边的花精所在的位置。mid 表示在这个小区间[l,r]中的两只花精之间的最长距离除以 2 后的值。p 表示取 mid 值时所在的紧邻的两只花精的中间位置,也就是在[l,r]中的答案值。对于 1 询问:访问线段树的第一个节点,我们比较 l-1,n-r,mid 的值哪个更大,就选哪个,它们的答案依次是 1,n,p。假设我们求得的位置是 fairy[x]。然后访问[fairy[x],fairy[x]]所在的线段树的叶子节点,初始化它的值,然后回溯,进行合并。对于 tr[x].l 与 tr[x].r 可以通过两个儿子的 l,r 信息得出。对于 tr[x].mid值,首先在左右儿子的 mid 值中去一个最大的值。其次考虑一种情况,就是夹在两个线段之间的距离,可以通过(tr[x+x+1].l-tr[x+x].r) / 2 的值得出在于 mid进行比较,然后 p 就随着 mid 的值的更新而更新。对于 2 询问:访问询问花精所在的位置,直接将它的叶子节点[fairy[x],fairy[x]]删除,然后回溯时,再做一次合并操作。</code></pre><p>View Code</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1010101struct tree&#123;    ll l,r,mid,ql,qr,p;&#125;tr[A];ll n,m;ll in[A];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        return ;    &#125;    ll mid=(l+r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void update(ll x)&#123;//    printf(&quot;ql=%lld qr=%lld\n&quot;,tr[x].ql,tr[x].qr);    if(tr[x&lt;&lt;1].ql) tr[x].ql=tr[x&lt;&lt;1].ql;    else  tr[x].ql=tr[x&lt;&lt;1|1].ql;    if(tr[x&lt;&lt;1|1].qr) tr[x].qr=tr[x&lt;&lt;1|1].qr;    else  tr[x].qr=tr[x&lt;&lt;1].qr;    tr[x].mid=tr[x&lt;&lt;1].mid;    tr[x].p=tr[x&lt;&lt;1].p;    if(tr[x&lt;&lt;1].qr&amp;&amp;tr[x&lt;&lt;1|1].ql)&#123;//        ll minn=tr[x].mid;        if((tr[x&lt;&lt;1|1].ql-tr[x&lt;&lt;1].qr)/2&gt;tr[x].mid)&#123;            tr[x].mid=(tr[x&lt;&lt;1|1].ql-tr[x&lt;&lt;1].qr)&gt;&gt;1;            tr[x].p=(tr[x&lt;&lt;1].qr+tr[x&lt;&lt;1|1].ql)&gt;&gt;1;//            minn=tr[x].mid;        &#125;        if(tr[x&lt;&lt;1|1].mid&gt;tr[x].mid)&#123;            tr[x].mid=tr[x&lt;&lt;1|1].mid;            tr[x].p=(tr[x&lt;&lt;1|1].p);//            minn=tr[x].mid;        &#125;    &#125;    //    printf(&quot;x=%lld l%lld--r%lld &lt;&lt;1%lld %lld |1%lld %lld区间 leftson mid=%lld mid=%lld x.mid=%lld p=%lld p=%lld p=%lld \n&quot;,x,tr[x].ql,tr[x].qr,tr[x&lt;&lt;1].ql,tr[x&lt;&lt;1].qr,tr[x&lt;&lt;1|1].ql,tr[x&lt;&lt;1|1].qr,tr[x&lt;&lt;1].mid,tr[x&lt;&lt;1|1].mid,tr[x].mid,tr[x].p,tr[x&lt;&lt;1].p,tr[x&lt;&lt;1|1].p);    return ;&#125;void change(ll x,ll pla,ll val)&#123;    if(tr[x].l==tr[x].r)&#123;        if(val==1)&#123;            tr[x].ql=tr[x].l;            tr[x].qr=tr[x].r;//            printf(&quot;x=%lld l=%lld r=%lld\n&quot;,x,tr[x].l,tr[x].r);            tr[x].p=0;            tr[x].mid=0;            return ;        &#125;        else &#123;            tr[x].ql=0,            tr[x].qr=0,            tr[x].p=0,            tr[x].mid=0;//            printf(&quot;x=%lld ql=%lld qr=%lld\n&quot;,x,tr[x].ql,tr[x].qr);            return ;        &#125;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) change(x&lt;&lt;1,pla,val);    else change(x&lt;&lt;1|1,pla,val);    update(x);&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    built(1,1,n);    for(ll i=1,opt,a,b;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;opt,&amp;a);        if(opt==1)&#123;            if(tr[1].ql==0)&#123;                in[a]=1;                printf(&quot;%lld\n&quot;,in[a]);                change(1,in[a],1);                continue ;            &#125;            ll minn=-0x7ffffff;//            printf(&quot;mid=%lld ql-1=%lld n-qr=%lld\n&quot;,tr[1].mid,tr[1].ql-1,n-tr[1].qr);            if(tr[1].ql-1&gt;minn)&#123;                minn=tr[1].ql-1;                in[a]=1;            &#125;            if(tr[1].mid&gt;minn)&#123;                minn=tr[1].mid;                in[a]=tr[1].p;            &#125;            if(n-tr[1].qr&gt;minn)&#123;                minn=n-tr[1].qr;                in[a]=n;            &#125;            printf(&quot;%lld\n&quot;,in[a]);            change(1,in[a],1);        &#125;        else change(1,in[a],-1);    &#125;&#125;</code></pre><p>View Code</p><h2 id="影子"><a href="#影子" class="headerlink" title="影子"></a>影子</h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>以为是神仙$dp$,然后是神仙并查集,</p><p>觉得官方题解写的很明白</p><p>将所有点按照权值从大到小排序,对于当前点和比当前点权值大的点和并到一个集合内,并查集维护当前集合直径和对应端点,</p><p>合并两个并查集时当前直径可以是其中一个集合中直径或两个集合交叉取</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201909/1708132-20190914140917410-509091470.png"></p><p>例如集合$AEB$ $CDF$ 合并时直径可以是$A-C$ $A-D$ $B-C$ $B-D$ (交叉取)$A-B$,$C-D$(原本集合)</p><p>需要用到两点之间距离$lca$在线回答就行了</p><p>合并并查集时$ans&#x3D;max(ans,直径长度*a[i])$</p><p>一个问题是当前点是否在集合内,其实并不会造成影响,你已经将点从大到小排好序了,你当前枚举如果之前出现过那么已经在之前处理过了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 500000struct moo&#123;    ll l,r,len,fa;&#125;fa[A];struct vvv&#123;    ll v,id;    friend bool operator &lt; (const vvv &amp; a,const vvv &amp; b)&#123;        return a.v&gt;b.v;    &#125;&#125;v[A];ll dis[A],f[A][25],head[A],nxt[A],ver[A],edg[A],deep[A],va[A];ll t,n,m,ans=0,tot=0;void add(ll x,ll y,ll z)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y,edg[tot]=z;&#125;ll find(ll x)&#123;//    printf(&quot;%lld.fa=%lld\n&quot;,x,fa[x].fa);    if(x!=fa[x].fa)        fa[x].fa=find(fa[x].fa);    return fa[x].fa;&#125;inline ll lca(ll x,ll y)&#123;    if(deep[x]&gt;deep[y])swap(x,y);    for(ll i=t;i&gt;=0;i--)    &#123;        if(deep[x]==deep[y]) break;        if(deep[x]&lt;=deep[f[y][i]]) y=f[y][i];    &#125;    if(x==y) return x;    for(ll i=t;i&gt;=0;i--)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];&#125;void merge(ll x,ll y,ll edgval,ll now)&#123;    ll maxx=0;    x=find(fa[x].fa),y=find(fa[y].fa);    fa[y].fa=x;    ll l1=fa[x].l,r1=fa[x].r,l2=fa[y].l,r2=fa[y].r;    ll dis1=fa[x].len,       dis2=fa[y].len,       dis3=dis[l1]+dis[l2]-2*dis[lca(l1,l2)],       dis4=dis[l1]+dis[r2]-2*dis[lca(l1,r2)],       dis5=dis[r1]+dis[l2]-2*dis[lca(r1,l2)],       dis6=dis[r1]+dis[r2]-2*dis[lca(r1,r2)];    if(dis2&gt;fa[x].len)&#123;        fa[x].l=l2,fa[x].r=r2;        fa[x].len=dis2;    &#125;    if(dis3&gt;fa[x].len)&#123;        fa[x].l=l1,fa[x].r=l2;        fa[x].len=dis3;    &#125;    if(dis4&gt;fa[x].len)&#123;        fa[x].l=l1,fa[x].r=r2;        fa[x].len=dis4;    &#125;    if(dis5&gt;fa[x].len)&#123;        fa[x].l=r1,fa[x].r=l2;        fa[x].len=dis5;    &#125;    if(dis6&gt;fa[x].len)&#123;        fa[x].l=r1,fa[x].r=r2;        fa[x].len=dis6;    &#125;    ans=max(ans,fa[x].len*va[now]);//    printf(&quot;l1=%lld r1=%lld l2=%lld r2=%lld  dis1=%lld dis2=%lld dis3=%lld dis4=%lld dis5=%lld dis6=%lld fa[x].len*va[now]=%lld dis[l1]=%lld+dis[l2]=%lld-2*dis[lca(l1,l2)]=%lld %lld lca=%lld ve[%lld]=%lld\n&quot;,l1,r1,l2,r2,dis1,dis2,dis3,dis4,dis5,dis6,fa[x].len*va[now],dis[r1],dis[r2],2*dis[lca(r1,r2)],dis[r1]+dis[r2]-2*dis[lca(r1,r2)],lca(r1,r2),now,va[now]);&#125;void dfs(ll x,ll pre,ll de)&#123;    deep[x]=de;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==pre) continue ;        dis[y]=dis[x]+edg[i];        f[y][0]=x;        dfs(y,x,de+1);    &#125;&#125;void mem()&#123;    memset(head,0,sizeof(head));    memset(fa,0,sizeof(fa));    tot=0;    ans=0;&#125;int main()&#123;    //    freopen(&quot;b.in&quot;,&quot;r&quot;,stdin);    ll T;    scanf(&quot;%lld&quot;,&amp;T);    while(T--)&#123;        scanf(&quot;%lld&quot;,&amp;n);        mem();        t=log(n)/log(2)+1;        for(ll i=1;i&lt;=n;i++)&#123;            scanf(&quot;%lld&quot;,&amp;v[i].v);            v[i].id=i;            va[i]=v[i].v;            fa[i].fa=i;            fa[i].l=fa[i].r=i;        &#125;    //    printf(&quot;n=%lld\n&quot;,n);        for(ll i=1,a,b,c;i&lt;=n-1;++i)&#123;            scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);            add(a,b,c),add(b,a,c);        &#125;                dfs(1,0,0);        f[1][0]=1;        for(ll j=1;j&lt;=t;j++)            for(ll i=1;i&lt;=n;i++)                f[i][j]=f[f[i][j-1]][j-1];        sort(v+1,v+n+1);        for(ll i=1;i&lt;=n;i++)&#123;            ll x=v[i].id,val=v[i].v;            for(ll j=head[x];j;j=nxt[j])&#123;                ll y=ver[j];                if(va[y]&gt;=va[x])&#123;                    merge(x,y,edg[j],x);                                    &#125;            &#125;        &#125;        printf(&quot;%lld\n&quot;,ans);    &#125;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S2019退役记</title>
      <link href="/2025/03/14/CSP-S2019%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
      <url>/2025/03/14/CSP-S2019%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-18 17:43</p><p>美国加州大西梅，内蒙古高钙奶片，限量版高铁模型巧克力<br>DAY0<br>火车上遇到感人的销售员，“美国加州大西梅，内蒙古高钙奶片，限量版高铁模型巧克力”<br>和lsc坐在一起，没什么事干，平安突然想起一个流言（传说），高铁上把硬币竖起来不会倒，就摆硬币，让硬币竖起来，然而实验很多会最多只会竖5秒左右<br>下午赶上试机，打了个线段树，听说lyl利用二十分钟打了全套高精+平衡树+线段树<br>我对拍还拍出错了线段树都打不对了<br>晚上去的燕大食堂，饭还不错<br>吃完饭和yushi宾馆里看电影，不知道看了飞驰人生后半段，之后又看了动物世界？？？<br>DAY1<br>上午看题<br>决策出现重大失误，我以为我T2想不出来了，近几年NOIP，DAY1T3我做的都挺顺手，于是开T3了，然而用了1.5小时没有任何收获，跟吃了shi一样，1.5小时收获了暴力分10分<br>中午还是燕大食堂，饭还不错<br>吃完饭和yushi宾馆看电影，中途toot，milk_feng，来了又走了，yushi也走了<br>和wangdrinkgrass，duanyue看了血战钢锯岭，楚门的世界，看血战钢锯岭时还停电了，和咩萌出去走了走<br>走了一会，谈了很多东西，都挂分挂成sb了<br>回来时恰好来电，咩萌回自己屋了，我接着看血战钢锯岭<br>到5.00左右去skyh屋，和shyh看了饥饿游戏后半段<br>晚上出去和wangdrinkgrass，zyyyyyy吃，饭还不错<br>吃完饭接着看电影，网drinkgrass，duanyue都回去了，我看完了生化危机终章<br>DAY2<br>上午做题又又又又出现重大错误，DAY1刚T3，DAY2刚T2，不用说我就一傻子<br>主要是我看T2得分空间还很足，然而到考试结束还是傻逼\(n^3\)<br>然后就回衡水了<br>高铁和衡实学弟坐在一起，只见学弟掏出一个笔记本，一会又掏出一个手机，一会又掏出白kuku<br>我非常无聊，看了看辽宁杂志，又红又专，全是好人好事</p><p>我应该是没戏了<br>然而即使我有幸成为400+，我也不会继续参加OI了<br>95+50+10<br>64+36+55<br>310</p><p>再见HZOI2018<br>再见OI<br>真心祝愿所有OIER能够在OI路上越走越远</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-c模拟测试43「A·B·C」</title>
      <link href="/2025/03/14/csp-c%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9543%E3%80%8CA%C2%B7B%C2%B7C%E3%80%8D/"/>
      <url>/2025/03/14/csp-c%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%9543%E3%80%8CA%C2%B7B%C2%B7C%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-15 20:32</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$f[i][(gcd(prime[j]*prime[k]%P,P))]&#x3D;\sum\limits_{k&#x3D;1}^{k&lt;&#x3D;num}<br>f[i-1][k]*phi(\frac{P}{prime[j]})$</p><p>关于$phi(\frac{P}{prime[j]})$理解</p><p>$phi(\frac{P}{prime[j]})$是求$prime[j]$代表的数的个数</p><p>$P&#x3D;k_0*prime[j]$</p><p>$x_1&#x3D;k_1*prime[j]$</p><p>$x_2&#x3D;k_2*prime[j]$</p><p>…….</p><p>要求代表$prime[j]$数个数就是求$k_1$,$k_2$个数$(k_0,k_1,k_2等互质)$(不互质$gcd就是别的数了$)</p><p>移项显然与$k_0$互质数个数就是$phi(\frac{P}{prime[j]})$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 55const ll mod=1e9+7;ll f[A][23333],phi[A*A],prm[A*A],to[A*A][A*A];ll n,m,P;ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%mod)        if(k&amp;1)            ans=ans*x%mod;    return ans;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;ll p(ll x)&#123;    ll ans=x;    for(ll i=2;i*i&lt;=x;i++)&#123;        if(x%i==0)&#123;            ans=ans/i*(i-1);            while(x%i==0) x/=i;        &#125;    &#125;    if(x&gt;1) ans=ans/x*(x-1);    return ans;&#125;void fen(ll x)&#123;    for(ll i=1;i*i&lt;=x;i++)&#123;        if(x%i==0)&#123;            prm[++prm[0]]=i;            if(i*i!=x) prm[++prm[0]]=x/i;        &#125;    &#125;    sort(prm+1,prm+prm[0]+1);&#125;void pre_work()&#123;    fen(P);    for(ll i=1;i&lt;=prm[0];i++)        phi[i]=p(P/prm[i]);    for(ll j=1;j&lt;=prm[0];j++)&#123;        for(ll pre=1;pre&lt;=prm[0];pre++)&#123;            ll g=gcd(prm[j]*prm[pre]%P,P);            to[j][pre]=lower_bound(prm+1,prm+prm[0]+1,g)-prm;        &#125;    &#125;&#125;void work()&#123;    for(ll i=2;i&lt;=n;i++)        for(ll j=1;j&lt;=prm[0];j++)            for(ll pre=1;pre&lt;=prm[0];pre++)                (f[i][to[j][pre]]+=f[i-1][pre]*phi[j]%mod)%=mod;&#125;void sub_task()&#123;    pre_work();    for(ll j=1;j&lt;=prm[0];j++)        f[1][j]=phi[j];    work();    for(ll i=1,a;i&lt;=m;i++)&#123;        scanf(&quot;%lld&quot;,&amp;a);            a=lower_bound(prm+1,prm+prm[0]+1,gcd(a,P))-prm;        printf(&quot;%lld &quot;,f[n][a]*meng(phi[a],mod-2)%mod)%mod;    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;P);    sub_task();    return 0;&#125;</code></pre><p>View Code</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>三分,对于怎么看出来三分,这可能是个套路,你觉得这个题你用贪心做不了** <em>(但非常像贪心),</em>** 二分答案会被hack** <em>,</em>**<br>然后你$dp$也难以做,你三分就可以了</p><p>三分$check$贪心做,很水,瞎jb差分一下,我会说贪心我考试时就写对了吗?</p><p>注意细节,细节很多,不要死于细节</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>/*n*log^2*/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 222222struct node&#123;    ll l,r;    friend bool operator &lt; (const node &amp; a,const node &amp;b)&#123;        return a.l==b.l?a.r&gt;b.r:a.l&lt;b.l;    &#125;&#125;wat[A];ll n,m,t,ans=0x7fffffffffffff,maxx=0,cnt=0;ll p[A],lef[A],now[A],c[A];ll check(ll x)&#123;    ll sum=0;    for(ll i=1;i&lt;=n;i++)&#123;        now[i]=max(p[i]-x,0ll);        c[i]=0;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        ll nowid=lef[i];        c[i]+=c[i-1];        if(lef[i]==0) continue ;        ll cha=c[i];//        printf(&quot;i=%lld c[i]=%lld c[i-1]=%lld\n&quot;,i,c[i],c[i-1]);//        printf(&quot;i=%lld now+cha=%lld\n&quot;,i,now[i]+cha);        if(now[i]+cha&gt;0)&#123;            sum+=now[i]+cha;            c[i]-=(now[i]+cha);            c[wat[nowid].r+1]+=now[i]+cha;            now[i]=0;        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        ll cha=c[i];//        printf(&quot;now=%lld x=%lld cha=%lld\n&quot;,now[i],x,cha);        if(now[i]+cha&gt;0) return 0x7fffffffff;     &#125;    return sum+x*t;&#125;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.bf&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;t);    for(ll i=1;i&lt;=n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;p[i]);        maxx=max(maxx,p[i]);    &#125;    for(ll i=1;i&lt;=m;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;wat[i].l,&amp;wat[i].r);    &#125;    sort(wat+1,wat+m+1);    for(ll i=1;i&lt;=m;i++)&#123;        if(!lef[wat[i].l])            lef[wat[i].l]=i;    &#125;    for(ll i=1;i&lt;=n;i++)        if(wat[lef[i-1]].r&gt;=i)&#123;            if(wat[lef[i-1]].r&gt;wat[lef[i]].r)                lef[i]=lef[i-1];         &#125;    ll l=0,r=maxx;    while(l&lt;r)&#123;        ll len=(r-l);        ll lmid=l+len/3,rmid=r-len/3;                ll lnow=check(lmid),rnow=check(rmid);//        printf(&quot;l=%lld r=%lld\n&quot;,l,r);        if(lnow&gt;=rnow) l=lmid+1;        else r=rmid-1;            ans=min(ans,lnow);        ans=min(ans,rnow);    &#125;//    printf(&quot;%lld\n&quot;,check(5));    printf(&quot;%lld\n&quot;,ans);&#125;    </code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csp-c模拟测试「set·read·」</title>
      <link href="/2025/03/14/csp-c%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%E3%80%8Cset%C2%B7read%C2%B7%E3%80%8D/"/>
      <url>/2025/03/14/csp-c%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%E3%80%8Cset%C2%B7read%C2%B7%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-19 10:20</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>只要求一组特解</p><p>像入阵曲一样就好了(入阵曲真是好题啊$!$)</p><p>$(sum[r]-sum[l])%n&#x3D;&#x3D;0$</p><p>拆成$sum[r]%n&#x3D;&#x3D;sum[l]%n$桶里存$sum[l]%n$每次找$sum[r]$桶里有没有对应的#sum[l]#</p><p>存$tong[0]&#x3D;1$,别的先查后存</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明一下正确性</p><p>$0$自己合法$(sum[r]%n)&#x3D;&#x3D;0$不需要找对应</p><p>其他都要找一个来匹配</p><p>假设我们有$n+1$个$sum’$值,(这里假设$sum[0]$也要找一个匹配)</p><p>$%n$意义下$sum$范围取遍$[0,n-1]$</p><p>$n+1$个$sum$,$n$种取值一定有一种合法</p><p>故得证</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>要求$max(cnt[k])-$$\sum \limits_{i&#x3D;1}^{N &amp;i!&#x3D;maxid} cnt[i]$ $ -1$</p><p>然后式子稍微一化$maxcnt*2-n-1$求$maxcnt$</p><p>然而$n$实在是太巨了$50000000$,出题人卡空间$16MB$$1000ms$怎么办</p><p>主要解决空间问题</p><p>事实上我们设$id$和$cnt$,$cnt&#x3D;&#x3D;0$时$id设为now$$cnt&#x3D;1$</p><p>$id&#x3D;&#x3D;now$ $cnt++$</p><p>$id!&#x3D;now$ $cnt–$</p><p>最后$id$就是$max$,</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2025/03/14/Codeforces%20Round%20#594%20(Div.%201A)%20lvan%20the%20Fool%20and%20Probability%20Theory/"/>
      <url>/2025/03/14/Codeforces%20Round%20#594%20(Div.%201A)%20lvan%20the%20Fool%20and%20Probability%20Theory/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-31 13:52</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191031121250603-595709901.png"></p><p>题意,一个只有黑白两色的矩阵</p><p>称概率图为满足每一个方格上下左右四个方向只有一个方格颜色和当前方格颜色相同的图</p><p>题解</p><p>打表</p><table><thead><tr><th>-0</th><th>2*1</th><th>2*2</th><th>2*3</th><th>2*5</th><th>2*8</th><th>2*13</th></tr></thead><tbody><tr><td>-1</td><td>2*2</td><td>2*3</td><td>2*4</td><td>2*6</td><td>2*9</td><td>2*14</td></tr><tr><td>-2</td><td>2*3</td><td>2*4</td><td>2*5</td><td>2*7</td><td>2*10</td><td>2*15</td></tr><tr><td>-4</td><td>2*5</td><td>2*6</td><td>2*7</td><td>2*9</td><td>2*11</td><td></td></tr><tr><td>-7</td><td>2*8</td><td>2*9</td><td>2*10</td><td>2*12</td><td>2*15</td><td></td></tr><tr><td>-12</td><td>2*13</td><td>2*14</td><td>2*15</td><td>2*17</td><td></td><td></td></tr></tbody></table><p>发现每一行符合$f[i]&#x3D;f[i-1]+f[i-2]-c$形式</p><p>$c$符合$abs(c[i])&#x3D;abs(c[i-1])+abs(c[i-2])+1$形式</p><p>前两列也符合$f[i]&#x3D;f[i-1]+f[i-2]-c$形式</p><p>递推</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define A 1111111const ll mod=1e9+7;ll n,m,c;ll cha[A],thefirst[A],thesecond[A],ans[A];int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    cha[1]=0;cha[2]=1;    thefirst[1]=1;thefirst[2]=2;    thesecond[1]=2;thesecond[2]=3;//最后统一    for(ll i=3;i&lt;=100000;i++)        cha[i]=(cha[i-1]+cha[i-2]+1)%mod;    for(ll i=3;i&lt;=100000;i++)        thefirst[i]=(thefirst[i-1]+thefirst[i-2])%mod;    for(ll i=3;i&lt;=100000;i++)        thesecond[i]=(thesecond[i-1]+thesecond[i-2]-1)%mod;    ans[1]=thefirst[n]%mod;ans[2]=thesecond[n]%mod;    c=cha[n];//  printf(&quot;1=%lld 2=%lld c=%lld\n&quot;,ans[1],ans[2],c);    for(ll i=3;i&lt;=100000;i++)        ans[i]=(ans[i-1]+ans[i-2]-c)%mod;    printf(&quot;%lld\n&quot;,(ans[m]*2%mod+mod)%mod);&#125;</code></pre><p>View Code</p><p>证明我当然不会</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>chess「dp」</title>
      <link href="/2025/03/14/chess%E3%80%8Cdp%E3%80%8D/"/>
      <url>/2025/03/14/chess%E3%80%8Cdp%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-12 21:05</p><p>根本就没想第$i+k*n$列与$i$列放棋子数相同,然后挂了</p><p>$dp$怎么表示都不完全,看到数据范围,我想的是推一个$dp$然后矩阵快速幂优化,陷进套路里了</p><p>想到了这种定义但是转移超过$n$列会挂,于是打了傻逼状压,还re了</p><p>定义$f[x][i]$为前$x$列一共放了$i$个棋子</p><p>$n&#x3D;&#x3D;m$时答案就是$f[n][c]$</p><p>$n!&#x3D;m$仍然可以转移$f[i][d]&#x3D;\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;n}f[i-1][d-j]*{C_{n}^{j}}^{\large<br>\lfloor \frac {m-i}{n}+1 \rfloor}$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ceoi「chase」</title>
      <link href="/2025/03/14/ceoi%E3%80%8Cchase%E3%80%8D/"/>
      <url>/2025/03/14/ceoi%E3%80%8Cchase%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-07 19:58</p><p>虽然原题是磁铁,我还是说面包屑吧</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191007193715131-1093947071.png"></p><p>图稍小</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$70$分$dp$,</p><p>$f_{x,i}$表示走到$x$为止用了$i$次,枚举起点进行转移</p><p>转移$f_{x,i}&#x3D;max(f_{pre,i},f_{pre,i-1}+sz_{x})$,这里$sz$表示的是儿子的权值和,不包括当前点</p><p>为什么这样转移,考虑你在当前撒下面包屑那么走到任意一个儿子差值都是这些,</p><p>不考虑父亲,在当前撒下面包屑儿子节点鸽子被吸引过来,走到儿子节点旅行家遇到鸽子数量不变,小学生遇到鸽子比旅行家多的就是儿子权值和</p><p>为什么不考虑父亲,父亲的贡献被父亲的父亲考虑了,</p><p>换种方法思考,分为三部分考虑</p><p>1.当前点,这一部分学生和旅行家都走了</p><p>2.自己走的儿子,这一部分学生走了,旅行家走的时候鸽子已经被吸引走了</p><p>3.没走的儿子,这一部分是学生直接多出来的</p><p>关于自己父亲,丢给上面节点考虑就行了,</p><p>$100$分$dp$</p><p>在这里,我先推荐一篇<a href="https://blog.csdn.net/stevensonson/article/details/81866046">极好的博客</a></p><p>上面$dp$计算冗余太多,极限就是这些分了</p><p>首先根据上面$dp$经验,放面包屑只会让权值变大,那么这样我们先贪心考虑,放完所有面包屑一定比不放完更优</p><p>发现一段路径一定是由两部分组成的,首先$up$表示从儿子走到当前节点最大贡献,$down$表示从当前点走到子树内最大贡献,</p><p>考虑初始化你不能重复考虑父亲,于是有了</p><pre><code>    for(ll i=1;i&lt;=v;i++)        up[x][i]=sum[x],down[x][i]=sum[x]-val[fa[x]];</code></pre><p>考虑两部分拼接成答案,那么答案就是</p><pre><code>        for(ll i=1;i&lt;v;i++)             ans=max(up[x][i]+down[y][v-i],ans);</code></pre><p>考虑为什么不是$up[x][i]+down[x][v-i]$好吧,其实挺显然的,</p><p>然后考虑转移,</p><p>$up$从下往上转移所以$-val[y]$,$down$从上往下转移所以$+val[fa[x]]$</p><p>至于为什么要-,跟上面原因类似,你在上面节点计算贡献时已经计算当前点父亲了,你全丢给了父亲以上考虑</p><p>还有很多很多很多细节,我不再一一细说了,</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 500000ll fa[A],ver[A],nxt[A],head[A],sta[A],val[A],sum[A],up[A][101],down[A][101];ll n,ans,tot,v,top;void add(ll x,ll y)&#123;    nxt[++tot]=head[x],head[x]=tot,ver[tot]=y;&#125;void dfs(ll x)&#123;    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa[x]) continue ;        fa[y]=x;        dfs(y);    &#125;    for(ll i=1;i&lt;=v;i++)        up[x][i]=sum[x],down[x][i]=sum[x]-val[fa[x]];    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(y==fa[x]) continue ;        sta[++top]=y;        for(ll i=1;i&lt;v;i++)             ans=max(up[x][i]+down[y][v-i],ans);        for(ll i=1;i&lt;=v;i++)            up[x][i]=max(up[x][i],max(up[y][i-1]+sum[x]-val[y],up[y][i])),            down[x][i]=max(down[x][i],max(down[y][i-1]+sum[x]-val[fa[x]],down[y][i]));    &#125;    ans=max(ans,max(up[x][v],down[x][v]));    for(ll i=1;i&lt;=v;i++)        up[x][i]=sum[x],down[x][i]=sum[x]-val[fa[x]];    while(top)&#123;        ll y=sta[top--];        for(ll i=1;i&lt;v;i++)             ans=max(up[x][i]+down[y][v-i],ans);        for(ll i=1;i&lt;=v;i++)            up[x][i]=max(up[x][i],max(up[y][i-1]+sum[x]-val[y],up[y][i])),            down[x][i]=max(down[x][i],max(down[y][i-1]+sum[x]-val[fa[x]],down[y][i]));    &#125;    ans=max(ans,max(up[x][v],down[x][v]));&#125;int main()&#123;    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;v);    for(ll i=1;i&lt;=n;i++)        scanf(&quot;%lld&quot;,&amp;val[i]);    for(ll i=1,a,b;i&lt;n;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);        sum[a]+=val[b];        sum[b]+=val[a];    &#125;    dfs(1);    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bzoj5147&amp;&amp;bzoj2121&amp;&amp;loj6701 字符串游戏</title>
      <link href="/2025/03/14/bzoj5147&amp;&amp;bzoj2121&amp;&amp;loj6701%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B8%B8%E6%88%8F/"/>
      <url>/2025/03/14/bzoj5147&amp;&amp;bzoj2121&amp;&amp;loj6701%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-09-24 16:48</p><p>做不出来杂题,到处找题做</p><p>看到$loj$上新出了一道题,觉得很神仙不错,</p><p>还记得Censoring吗(一个AC自动机的题)</p><p>这个题求最优解,数据范围$150$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>数据范围非常小,首先贪心肯定不行,考虑AC自动机上$dp$?</p><p>好吧其实是区间$dp$</p><p>一个直接的想法是维护$f[l][r]&#x3D;0&#x2F;1$表示是否可以清空$l$,$r$这一段子段</p><p>然而转移起来很难转移,考虑再定义一个数组$g[l][r][i][w]&#x3D;0&#x2F;1$表示是否可以清成第$i$个模式串的前$w$位</p><p>考虑$g$转移,</p><p>1.直接匹配$g[l][r][i][w]|&#x3D;g[l][r-1][i][w-1]$其中主串$str[r]&#x3D;&#x3D;c[i][w]$表示若$l,r-1$可以清成第$i$个模式串前$w-1$位那么若当前两个可以匹配上必然$l,r$可以清成第$i$个模式串前$w$位</p><p>2.由几部分拼凑$g[l][r][i][w]|&#x3D;g[l][q-1][i][w]&amp;f[q][r]$表示$q-r$被清空那么$g$显然可以转移</p><p>那么根据$f$定义$f[l][r]|&#x3D;g[l][r][i][len[i]]$</p><p>举个例子$momooo$ 模式串$moo$</p><p>先$g[3][5][1][3]&#x3D;1$,得$f[3][5]&#x3D;1$得$g[1][5][1][2]&#x3D;1$(由$f[3][5]$)转移<br>再进行一步匹配$f[3][6][1][3]&#x3D;1$得$f[1][6]&#x3D;1$可以全部清空</p><p>那么$ans$根据类似最长上升子序列求</p><p>$ans[i]&#x3D;min(ans[i-1]+1,ans<a href="f%5Bl%5D%5Bi%5D==1">l-1</a>)$两层循环枚举</p><p>考虑炸内存?</p><p>状压,怎么状压,压掉一维,这里不再解释,因为数据点足够水,这已经足以通过测试点</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define A 152#define ll long longll len[A],ans[A];bool f[A][A],g[A][A][52][52];ll n,cnt;char c[A][A],str[A];int main()&#123;    scanf(&quot;%s&quot;,str+1);    n=strlen(str+1);    scanf(&quot;%lld&quot;,&amp;cnt);    for(ll i=1;i&lt;=cnt;i++)&#123;        scanf(&quot;%s&quot;,c[i]+1);        len[i]=strlen(c[i]+1);    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        f[i][i-1]=1;        for(ll j=1;j&lt;=cnt;j++)&#123;            g[i][i-1][j][0]=1;        &#125;    &#125;    for(ll k=1;k&lt;=n;k++)&#123;//枚举当前长度        for(ll l=1;l&lt;=n-k+1;l++)&#123;            ll r=l+k-1;            for(ll w=1;w&lt;=cnt;w++)&#123;                for(ll now=1;now&lt;=len[w];now++)&#123;                    if(c[w][now]==str[r])                        g[l][r][w][now]|=g[l][r-1][w][now-1];                &#125;                for(ll now=1;now&lt;=len[w];now++)&#123;                    for(ll i=l;i&lt;=r;i++)&#123;                        g[l][r][w][now]|=g[l][i-1][w][now]&amp;f[i][r];                    &#125;                &#125;            &#125;            for(ll w=1;w&lt;=cnt;w++)                f[l][r]|=g[l][r][w][len[w]];        &#125;    &#125;    for(ll i=1;i&lt;=n;i++)&#123;        ans[i]=ans[i-1]+1;        for(ll j=1;j&lt;=i;j++)&#123;            if(f[j][i])&#123;                ans[i]=min(ans[i],ans[j-1]);            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans[n]);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bzoj2839 集合计数（容斥+组合）</title>
      <link href="/2025/03/14/bzoj2839%20%E9%9B%86%E5%90%88%E8%AE%A1%E6%95%B0%EF%BC%88%E5%AE%B9%E6%96%A5+%E7%BB%84%E5%90%88%EF%BC%89/"/>
      <url>/2025/03/14/bzoj2839%20%E9%9B%86%E5%90%88%E8%AE%A1%E6%95%B0%EF%BC%88%E5%AE%B9%E6%96%A5+%E7%BB%84%E5%90%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-04 12:18</p><h1 id="集合计数"><a href="#集合计数" class="headerlink" title="集合计数"></a>集合计数</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个有N个元素的集合有2^N个不同子集(包含空集)，现在要在这2^N个集合中取出若干集合(至少一个)，使得它们的交集的元素个数为K，求取法的方案数，答案模1000000007。(是质数喔~)</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一行两个整数N,K</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一行为答案。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>3 2</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>6</code></pre><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><h4 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h4><p>假设原集合为{A,B,C}</p><p>则满足条件的方案为：{AB,ABC},{AC,ABC},{BC,ABC},{AB},{AC},{BC}</p><h4 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h4><p>对于100%的数据，1≤N≤1000000；0≤K≤N；</p><p>一道很好的数论题(反正我看题解才做出来的 %%%%*ZJ <a href="https://www.cnblogs.com/zj75211/p/8029343.html">https://www.cnblogs.com/zj75211/p/8029343.html</a>)<br>我有点菜，各种错误。</p><p>思路很奇妙，第一步：首先选出来C(n，k)个数，第二步：然后我们要做的就是让剩余集合交集为空。注意，我们选的剩余集合是除了C以外还选了什么(C上再加这个集合)</p><p>解释一下</p><p>例如 3 1</p><p>假设我们通过第一步选出来的数为A</p><p>而第二步我们选出来 C，B</p><p>那么我们最终选的集合为AB ，AC</p><p>再比如我们第二步选 空集，C</p><p>那么我们最终选出来的集合为 A，AC</p><p>既然如此我们需要求的就是所有满足的情况</p><p>正确性验证被我鸽了。。。。。。</p><p>然后我们要做的就是求出方案</p><p>设f[i]为当前集合<strong>至少</strong> 选出i个数的方案数</p><p>设m为n-i(即剩余个数)</p><p>对于剩余n-i个数可以构成$2^{(n-i)}$个集合</p><p>而对于这些集合每个都可以进行选或不选(即$2{^{2^{(n-i)}}}$)种情况</p><p>而不能都不选(对于选了空集也是一种)</p><p>则</p><p>$f[i]&#x3D;C(n,i)*(2{^{2^{n-i}}}-1)$</p><p><strong>显然我们算多了，然后我们需要容斥掉</strong> 容斥系数，首先我们发现在所有f[k+1]中我们都多算了C(k+1，k)次</p><p>例如我们固定了四个数ABCD</p><p>我们在k+1中每种都多算了一次</p><p>ABC D&#x3D;&#x3D;ACD B&#x3D;&#x3D;ABD C&#x3D;&#x3D;BCD A</p><p>得到对于f[k+1]:-C(k+1，k)</p><p>同理f[k+2]:+C(k+2，k+1)*C(k+1，k)&#x3D;&#x3D;C(k+2，k)</p><p>依次类推</p><p>得到</p><pre><code>for(ll i=k;i&lt;=n;i++)    ans=(C(i,k)*f[i]%p*((i-k)&amp;1?-1:1)+ans)%p;</code></pre><p>实际上就类似于多项容斥</p><p>而且这题因为N&lt;&#x3D;1000000</p><p>如果算C现算肯定不行，考虑到用多次，打表(阶乘及阶乘逆元)，但求逆元带log仍然超时</p><p>所以还要线性求逆元</p><pre><code>    ni[n]=meng(jie[n],p-2);    for(ll i=n-1;i&gt;=1;i--)ni[i]=ni[i+1]*(i+1)%p;</code></pre><p>理解一下逆元实际上就是1&#x2F;？</p><p>而$1&#x2F;(n+1)！*(n+1)$其实就是$1&#x2F;(n)！ $就求出来逆元了</p><p><strong>两个注意点</strong></p><p><code>：for(ll i=1;i&lt;=maxn;i++) ermi[i]=2*ermi[i-1]%(p-1);//2^ermi[i]%p!=2^ermi[i]%p调两节课</code></p><p><code>：for(ll i=0;i&lt;=n;i++)又一节半课，实在是菜</code></p><p>：ermi[0]又二十分钟，</p><p>除了第一个是稍微有一点思维的错，别的都是低错。实不应该</p><p><code>首先关于为什么mod (p-1)而不是mod (p)</code></p><p>这其实要推出来，首先我们必须知道${2^{2^i mod p}}{!&#x3D;2^{2^i}{mod p}}$</p><p>怎么办 设${2^i}&#x3D;&#x3D;(kφ(p)+t)$，则原式就为$(2^{k*φ(p)}*2^t) {mod p}$</p><p>根据欧拉定理</p><p>$2^{φ(p)} mod p$同余于1，${2^i}&#x3D;&#x3D;kφ(p)+t$t就等于$2^i mod φ(p)$，又φ(质数)&#x3D;&#x3D;p-1</p><p>故%(p-1)而非%p</p><p>以下依然是本人丑陋的还带着调试的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 #define ll long long 3 #define A 1100000 4 #define maxn 1000010 5 #define p 1000000007 6 using namespace std; 7 ll m,n,k,f[A],jie[A],ermi[A],ans,ni[A]; 8 inline ll read() 9 &#123;10     ll f=1,x=0;char c=getchar();11     while(!isdigit(c))&#123;if(c==&#39;-&#39;) f=-1;c=getchar();&#125;12     while(isdigit(c))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;c=getchar();&#125;13     return f*x;14 &#125;15 ll meng(ll x,ll k)16 &#123;17     ll ans=1;18     for(;k;k&gt;&gt;=1,x=x*x%p)19         if(k&amp;1)20             ans=x%p*ans%p;21     return ans;22 &#125;23 ll C(ll n,ll m)24 &#123;25     if(m==0) return 1;26     if(m&gt;n) return 0;27     else return (jie[n]*ni[m]%p*ni[n-m])%p;28 &#125;29 void init()30 &#123;31     n=read(),k=read();32     m=n-k;33     jie[0]=1;ni[0]=1;ermi[0]=1;34     for(ll i=1;i&lt;=maxn;i++)    ermi[i]=2*ermi[i-1]%(p-1);//2^ermi[i]%p!=2^ermi[i]%p35     for(ll i=1;i&lt;=n;i++)    jie[i]=jie[i-1]*i%p;36     ni[n]=meng(jie[n],p-2);37     for(ll i=n-1;i&gt;=1;i--)ni[i]=ni[i+1]*(i+1)%p;38     for(ll i=0;i&lt;=n;i++)    f[i]=C(n,i)%p*(meng(2,ermi[n-i])%p-1)%p;39 &#125;40 int main()41 &#123;42 //    freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);freopen(&quot;vio.out&quot;,&quot;w&quot;,stdout);43     ans=0;44     init();45     for(ll i=k;i&lt;=n;i++)46     ans=(C(i,k)*f[i]%p*((i-k)&amp;1?-1:1)+ans)%p;47     cout&lt;&lt;(ans%p+p)%p&lt;&lt;endl;48 &#125;</code></pre><p>View Code</p><p>以及对拍</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code> 1 #include&lt;bits/stdc++.h&gt; 2 int main()  3 &#123; 4     while(true)  5     &#123; 6         system(&quot;./mkd&quot;),puts(&quot;mkd runs out&quot;); 7         system(&quot;./std&quot;),puts(&quot;std runs out&quot;); 8         system(&quot;./vio&quot;),puts(&quot;vio runs out&quot;); 9         if(system(&quot;diff std.out vio.out&quot;)) while(true);10         puts(&quot;&quot;);11     &#125;12     return 0;13 &#125;</code></pre><p>View Code</p><p>嗯，完了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bzoj2427 软件安装！ 树dp</title>
      <link href="/2025/03/14/bzoj2427%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%81%20%E6%A0%91dp/"/>
      <url>/2025/03/14/bzoj2427%20%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%81%20%E6%A0%91dp/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-11 21:27</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>现在我们的手头有N个软件，对于一个软件i，它要占用Wi的磁盘空间，它的价值为Vi。我们希望从中选择一<br>些软件安装到一台磁盘容量为M计算机上，使得这些软件的价值尽可能大(即Vi的和最大)。</p><p>但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件j(包括软件j的直接或间接依赖)的情况下才能正确工作(软件i依赖软件j)。幸运的<br>是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为0。</p><p>我们现在知道了软件之间的依赖关系：软件i依赖软件Di。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一<br>次，如果一个软件没有依赖则Di&#x3D;0，这时只要这个软件安装了，它就能正常工作。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行：N，M (0&lt;&#x3D;N&lt;&#x3D;100．0&lt;&#x3D;M&lt;&#x3D;500)</p><p>第2行：W1，W2，…，Wi，…，Wn(0&lt;&#x3D;Wi&lt;&#x3D;M)</p><p>第3行：V1，V2，…，Vi，…，Vn(0&lt;&#x3D;Vi&lt;&#x3D;1000)</p><p>第4行：D1，D2，…，Di，…，Dn(0&lt;&#x3D;Di&lt;&#x3D;N，Di≠i)</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数，代表最大价值。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>3 105 5 62 3 40 1 1</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>5</code></pre><p>没什么好说的。</p><p>非常简单的树dp</p><p>10分算法</p><p>其实是你dp打错了才会10分。</p><p>1个注意点（由于博主沙雕打法导致的）</p><pre><code>    if(x!=0)    &#123;            for(ll j=m;j&gt;=w1[x];j--)            f[x][j]=f[x][j-w1[x]]+v1[x];        for(ll j=w1[x]-1;j;j--)            f[x][j]=0;    &#125;</code></pre><p>没清零！（上面给它赋值了但实施上它本来就不该有值）</p><p>40分算法</p><p>没打tarjan就会40分。</p><p>事实上当你发现你一直40wrong ans并且改不出来时就应该想想tarjan</p><p>100分</p><p>如果打了tarjan就100分了。</p><p>和某个叫「选课」的题特别像。</p><p>选课会打这个就会。</p><p>以下是本人丑陋的代码。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 2100using namespace std;ll ver[A],f[A][A],fa[A],dis[A],deep[A],chatot=0,root,sum[A],w[A],d[A],v[A],num=0,top=0,ins[A],sta[A],dfn[A],low[A],cnt=0,scc[110][110],belong[A];ll head2[A],head[A],nxt[A],nxt2[A],ver2[A],tot2=0,tot=0,du[A],v1[A],w1[A];bool flag[A],vis[A];ll n,m,k,t,xx,yy,zz;inline ll read()&#123;ll f=1,x=0;char ch=getchar();while(!isdigit(ch))&#123;if(ch==&#39;-&#39;) f=-1;ch=getchar();&#125;while(isdigit(ch))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125;return x*f;&#125;inline void add(ll x,ll y)&#123;fa[y]=x,ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;inline void add2(ll x,ll y)&#123;ver2[++tot2]=y,nxt2[tot2]=head2[x],head2[x]=tot2;&#125;inline void rebuilt()&#123;    for(ll i=1;i&lt;=n;i++)    &#123;        for(ll j=head[i];j;j=nxt[j])        &#123;            ll y=ver[j];            if(belong[y]!=belong[i])                add2(belong[i],belong[y]),du[belong[y]]++;        &#125;    &#125;&#125;inline ll tarjan(ll x)&#123;    dfn[x]=low[x]=++num;    sta[++top]=x;ins[x]=1;    for(ll i=head[x];i;i=nxt[i])    &#123;        ll y=ver[i];        if(dfn[y]==0)        &#123;            tarjan(y);            low[x]=min(low[x],low[y]);        &#125;        else if(ins[y])            low[x]=min(low[x],dfn[y]);    &#125;    if(dfn[x]==low[x])    &#123;        ++cnt;        ll yy=0;        while(1)        &#123;            yy=sta[top--];            ins[yy]=0;                        belong[yy]=cnt;            v1[cnt]+=v[yy];            w1[cnt]+=w[yy];            if(yy==x)                break;                    &#125;    &#125;&#125;void dfs(ll x)&#123;    f[x][0]=0;    for(ll i=head2[x];i;i=nxt2[i])    &#123;        ll y=ver2[i];        dfs(y);        for(ll j=m;j&gt;=0;j--)            for(ll k=j;k&gt;=0;k--)                f[x][j]=max(f[x][j],f[x][j-k]+f[y][k]);    &#125;    if(x!=0)    &#123;            for(ll j=m;j&gt;=w1[x];j--)            f[x][j]=f[x][j-w1[x]]+v1[x];        for(ll j=w1[x]-1;j;j--)            f[x][j]=0;    &#125;&#125;int main()&#123;    n=read(),m=read();    for(ll i=1;i&lt;=n;i++)        w[i]=read();    for(ll i=1;i&lt;=n;i++)        v[i]=read();    for(ll i=1;i&lt;=n;i++)    &#123;        d[i]=read();        add(d[i],i);    &#125;    for(ll i=1;i&lt;=n;i++)        if(!dfn[i]) tarjan(i);    rebuilt();    for(ll i=1;i&lt;=cnt;i++)    &#123;        if(!du[i])            add2(0,i);    &#125;    dfs(0);    cout&lt;&lt;f[0][m]&lt;&lt;endl;&#125;</code></pre><p>View Code</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201907/1708132-20190711212823471-2001587685.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bzoj2111 perm 排列计数</title>
      <link href="/2025/03/14/bzoj2111%20perm%20%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/"/>
      <url>/2025/03/14/bzoj2111%20perm%20%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-02 11:36</p><h1 id="Perm-排列计数"><a href="#Perm-排列计数" class="headerlink" title="Perm 排列计数"></a>Perm 排列计数</h1><p>内存限制：512 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;&#x3D;i&lt;&#x3D;N时，Pi&gt;Pi&#x2F;2.<br>计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件的第一行包含两个整数 n和p，含义如上所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件中仅包含一个整数，表示计算1,2,N的排列中， Magic排列的个数模 p的值。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>20 23</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>16</code></pre><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p>100%的数据中，1 ≤ N ≤ 106, P ≤ 10^9，p是一个质数。 数据有所加强</p><p>事实上题目少说一句i为奇数&#x2F;2就向下取整（虽然说不说都可以推断，说了比较严谨）</p><p>既然这样我们可以把它想象成一个 二叉堆（小根堆） 满足magic 就是满足二叉堆 那么magic的方案数就是满足二叉堆的方案数。</p><p>但如果暴力计算方式会TLE，我们需要用一种别的方式计算</p><p>于是就有了树形dp 设f[i]为以i为根的方案数显然可以由两个儿子贡献过来</p><p>当前点因为根是最小的所以size[i]-1表示剩余的节点数 然后是在size[i]-1的范围内选size[left]数量的数分配给左儿子</p><p>于是</p><blockquote><p>**$f[i]&#x3D;f[(i &lt;&lt;1)]<em>f[(i&lt;&lt;1|1)]</em>{C_{size[i]-1}^{size[i&lt;&lt;1]}}$**</p></blockquote><p>由于n比较大然后要用lucas定理</p><p>然后注意当前点不能大于n转移就完了</p><p>下面依然是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1100000#define maxn 1000010#define p 1000000007using namespace std;ll m,n,k,f[A],jie[A],ermi[A],ans,ni[A];inline ll read()&#123;    ll f=1,x=0;char c=getchar();    while(!isdigit(c))&#123;if(c==&#39;-&#39;) f=-1;c=getchar();&#125;    while(isdigit(c))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;c=getchar();&#125;    return f*x;&#125;ll meng(ll x,ll k)&#123;    ll ans=1;    for(;k;k&gt;&gt;=1,x=x*x%p)        if(k&amp;1)            ans=x%p*ans%p;    return ans;&#125;ll C(ll n,ll m)&#123;    if(m==0) return 1;    if(m&gt;n) return 0;    else return (jie[n]*ni[m]%p*ni[n-m])%p;&#125;void init()&#123;    n=read(),k=read();    m=n-k;    jie[0]=1;ni[0]=1;ermi[0]=1;    for(ll i=1;i&lt;=maxn;i++)    ermi[i]=2*ermi[i-1]%(p-1);//2^ermi[i]%p!=2^ermi[i]%p    for(ll i=1;i&lt;=n;i++)    jie[i]=jie[i-1]*i%p;    ni[n]=meng(jie[n],p-2);    for(ll i=n-1;i&gt;=1;i--)ni[i]=ni[i+1]*(i+1)%p;    for(ll i=0;i&lt;=n;i++)    f[i]=C(n,i)%p*(meng(2,ermi[n-i])%p-1)%p;&#125;int main()&#123;//    freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);freopen(&quot;vio.out&quot;,&quot;w&quot;,stdout);    ans=0;    init();    for(ll i=k;i&lt;=n;i++)    ans=(C(i,k)*f[i]%p*((i-k)&amp;1?-1:1)+ans)%p;    cout&lt;&lt;(ans%p+p)%p&lt;&lt;endl;&#125;</code></pre><p>View Code</p><p>当然也可以线性转移</p><pre><code>    for(int i=n;i;--i)    &#123;        if(sz[i]&lt;3) dp[i]=1;        else dp[i]=1ll*dp[lch]*dp[rch]%mod*lucas(sz[i]-1,sz[lch])%mod;        //不能给右儿子算组合数，可能越界    &#125;</code></pre><p>会快很多</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bzoj1925 地精部落</title>
      <link href="/2025/03/14/bzoj1925%20%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/"/>
      <url>/2025/03/14/bzoj1925%20%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-05 13:56</p><p>神题！</p><h1 id="地精部落"><a href="#地精部落" class="headerlink" title="地精部落"></a>地精部落</h1><p>内存限制：128 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>传说很久以前，大地上居住着一种神秘的生物：地精。 地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 N 的山脉 H可分 为从左到右的 N<br>段，每段有一个独一无二的高度 Hi，其中Hi是1到N 之间的正 整数。 如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边<br>缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。 类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。<br>地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆 不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。<br>地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮 流担当瞭望工作，以确保在第一时间得知外敌的入侵。 地精们希望这N<br>段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足 这个条件的整座山脉才可能有地精居住。 现在你希望知道，长度为N<br>的可能有地精居住的山脉有多少种。两座山脉A 和B不同当且仅当存在一个 i，使得 Ai≠Bi。由于这个数目可能很大，你只对它 除以P的余数感兴趣。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>仅含一行，两个正整数 N, P。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>仅含一行，一个非负整数，表示你所求的答案对P取余 之后的结果。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>4 7</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>3</code></pre><h4 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h4><p><img src="http://hzoj.com/images/190618_h8DAEFPck6.png" alt="image"><br>对于 20%的数据，满足 N≤10；<br>对于 40%的数据，满足 N≤18；<br>对于 70%的数据，满足 N≤550；<br>对于 100%的数据，满足 3≤N≤4200，P≤10910^910​9​​</p><p>题目大意</p><p>规定一个数如果比其左边右边数都小则称之为山谷，如果都大则称之为山峰。给定1-n（1-n不重复出现）的一个数列。求使山峰山谷交替出现的数列方案数</p><p>计数dp？</p><p>引理1</p><p>如果一个序列每个数ai置换为（n-ai）+1我们可以得到一个符合题意新数列，并且若原队列先降后增，则新数列先增后降</p><p>引理2</p><p>所有先降后增的方案数之和等于先增后降方案数之和</p><p>这两个引理非常重要</p><p>由因引理二可得：如果设f[i]为长度为i的山（固定j为山峰）并且前两个山分别为山峰和山谷（先降后增）时方案数，那么我们得出最后结果f[n]只需要*2就可得ans</p><p>你可能会疑问j是什么，别着急</p><p>固定j为山峰，那么j只有为奇数时才能转移。</p><p>fi可以由每一个固定j为山峰的位置转移。</p><p>首先因为先降后增那么f偶数项末尾一定为山谷，</p><p>然后我们从i-1个数中选择j-1个数，再让他们*f[j-1]，即可将他们固定为先降后增。</p><p>然后又由于引理二得到后i-j个数中先增后降其实就是先降后增方案。</p><blockquote><p>**$f[i]&#x3D;\sum_{j为奇数}^{j &lt;&#x3D;i} f[j-1]<em>f[i-j]</em>$ $C_{i-1}^{j-1}$**</p></blockquote><p>转移就完了。</p><p>以下是本人（常数极大+丑陋+刻意压行）的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 3000000ll C[4][A],f[A],n,p;int main()&#123;        cin&gt;&gt;n&gt;&gt;p;f[0]=C[1][1]=C[0][0]=C[1][0]=1;        for(ll i=1;i&lt;=n;i++)                for(ll j=1;j&lt;=i;j++)                &#123;                        if(j&amp;1)                                f[i]=(f[i]+f[j-1]%p*f[i-j]%p*C[(i-1)&amp;1][j-1])%p;                        C[i&amp;1][j]=(C[(i-1)&amp;1][j]+C[(i-1)&amp;1][j-1])%p;                &#125;        cout&lt;&lt;(2*f[n])%p&lt;&lt;endl;&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLO</title>
      <link href="/2025/03/14/BLO/"/>
      <url>/2025/03/14/BLO/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-17 15:02</p><h1 id="BLO"><a href="#BLO" class="headerlink" title="BLO"></a>BLO</h1><p>内存限制：162 MiB 时间限制：1000 ms 标准输入输出</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Byteotia城市有n个 towns m条双向roads. 每条 road 连接 两个不同的 towns ,没有重复的road. 所有towns连通。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入n&lt;&#x3D;100000 m&lt;&#x3D;500000及m条边</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出n个数，代表如果把第i个点去掉，将有多少对点不能互通。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><pre><code>5 51 22 31 33 44 5</code></pre><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>8816148</code></pre><p>首先如果这个点不是割点，那么显然该点删去后对除了此点以外所有点之间的点对关系不造成影响，影响的只是当前点与其他点之间点对。所以贡献$2*(n-1)$</p><p>然后如果这个点是个割点，这个点可以分割后具体可以分成这几部分，</p><p>一，直接与原图相连的连通块</p><p>二，图剩余部分</p><p>三，节点自身</p><p>考虑这三部分的贡献</p><p>对于二：</p><p>它与除了连通块外点构成点对都被拆散</p><p>那么贡献为$size[y]\times (n-size[y])$</p><p>我们算的是单方向点对</p><p>对于三：</p><p>它分割以后与其他所有点点对都被拆散</p><p>对于一：</p><p>我们用一个小容斥，然后贡献类似于二</p><p>完了</p><p>以下依然是本人丑陋的代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;#define ll long long#define A 1000000#define read(a) scanf(&quot;%lld&quot;,&amp;a)#define put(a) printf(&quot;%lld\n&quot;,a)using namespace std;ll low[A],size[A],dfn[A],head[A],ver[A],nxt[A],tot=0,cut[A],ans[A];ll n,m,num=0,root;void add(ll x,ll y)&#123;    ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;return ;&#125;void tarjan(ll x)&#123;    low[x]=dfn[x]=++num;size[x]=1;    ll flag=0,sum=0;    //若不为割点ans可以被其他n-1个点贡献    //若为割点ans可以由剩余n-sum-1个点贡献以及这个点不能到达其他任何点以及其他与x直接连接点到达不了其他点    for(ll i=head[x];i;i=nxt[i])&#123;        ll y=ver[i];        if(!dfn[y])&#123;            tarjan(y);            size[x]+=size[y];                        low[x]=min(low[x],low[y]);            if(low[y]&gt;=dfn[x])&#123;                flag++;sum+=size[y];ans[x]+=size[y]*(n-size[y]);                if(x!=root||flag&gt;1)&#123;                    cut[x]=1;                &#125;            &#125;        &#125;        else low[x]=min(low[x],dfn[y]);    &#125;    if(cut[x]) ans[x]+=(n-sum-1)*(sum+1)+n-1;//,printf(&quot;贡献ans[%lld]=%lld\n&quot;,x,ans[x]);    else ans[x]=2*(n-1);//,printf(&quot;贡献ans[%lld]=%lld 2*(n-1)=%lld\n&quot;,x,ans[x],2*n-1);&#125;int main()&#123;        read(n),read(m);        for(ll i=1;i&lt;=m;i++)&#123;            ll xx,yy;read(xx),read(yy);add(xx,yy);add(yy,xx);        &#125;        for(ll i=1;i&lt;=n;i++)            if(!dfn[i])root=i,tarjan(i);        for(ll i=1;i&lt;=n;i++)&#123;            //printf(&quot;size[i]=%lld cut[%lld]=%lld\n&quot;,size[i],i,cut[i]);            put(ans[i]);        &#125;&#125;</code></pre><p>View Code</p><p>注意</p><pre><code>            if(low[y]&gt;=dfn[x])&#123;                flag++;sum+=size[y];ans[x]+=size[y]*(n-size[y]);                if(x!=root||flag&gt;1)&#123;                    cut[x]=1;                &#125;            &#125;</code></pre><p>中sum ans都要放在判断割点之上，因为我们算的在根上也要照常计算</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bird</title>
      <link href="/2025/03/14/bird/"/>
      <url>/2025/03/14/bird/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-26 06:32</p><p>这个题其实挺好的(除了条件没给清)</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最显然的dp,f[i]表示在i打了一枪最多得到多少只鸟,$f[i]&#x3D;\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;i-k}f[j]+cnt[i]$然而如果一只鸟长度跨越几次开枪一只鸟会被重复算很多次,比如1秒开次枪,鸟100000长度,会多算</p><p>所以实际dp应该是$f[i]&#x3D;\sum\limits_{j&#x3D;1}^{j&lt;&#x3D;i-k} f[j]+cnt[i]-chongfu$,</p><p>可以利用差分思想,假设一只鸟覆盖[l,r],在鸟来之前[l,r]-1鸟走之后[l,r]+1,每多算一次[l,r]区间的鸟,也会被多减一次1,最后统一给[l,r]+1就得到了实际的值!</p><p>用线段树维护区间+,-,区间max,set维护每只鸟即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 2001101struct tree&#123;    ll l,r,maxx,f;&#125;tr[A];struct node&#123;    ll l,r;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b)&#123;        l=a,r=b;    &#125;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.r&lt;b.r;    &#125;&#125;qujian[A];ll cmp(const node &amp;a,const node &amp;b)&#123;    return a.l&lt;b.l;&#125;multiset&lt;node&gt; st;multiset&lt;node&gt; :: iterator it;ll maxx,tot,k,n,mx,ans;ll cnt[A],in[A],f[A];void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);&#125;void up(ll x)&#123;    tr[x].maxx=max(tr[x&lt;&lt;1].maxx,tr[x&lt;&lt;1|1].maxx);&#125;void down(ll x)&#123;    tr[x&lt;&lt;1].maxx+=tr[x].f;    tr[x&lt;&lt;1|1].maxx+=tr[x].f;    tr[x&lt;&lt;1].f+=tr[x].f;    tr[x&lt;&lt;1|1].f+=tr[x].f;    tr[x].f=0;&#125;void seg_add(ll x,ll l,ll r,ll d)&#123;//    printf(&quot;l=%lld r=%lld tr[x].l=%lld .r=%lld\n&quot;,l,r,tr[x].l,tr[x].r);    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        tr[x].maxx+=d;        tr[x].f+=d;        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_add(x&lt;&lt;1,l,r,d);    if(mid&lt;r) seg_add(x&lt;&lt;1|1,l,r,d);    up(x);&#125;void seg_max(ll x,ll l,ll r)&#123;    if(l&gt;r) return ;//    printf(&quot;tr[x].l=%lld r=%lld l=%lld r=%lld\n&quot;,tr[x].l,tr[x].r,l,r);    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        maxx=max(maxx,tr[x].maxx);        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_max(x&lt;&lt;1,l,r);    if(mid&lt;r) seg_max(x&lt;&lt;1|1,l,r);    up(x);&#125;void insert(ll x,ll pla,ll val)&#123;//    printf(&quot;***l=%lld r=%lld pla=%lld val=%lld\n&quot;,tr[x].l,tr[x].r,pla,val);    if(tr[x].l==tr[x].r)&#123;        tr[x].maxx+=val;        return ;    &#125;    if(tr[x].f) down(x);    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) insert(x&lt;&lt;1,pla,val);    else insert(x&lt;&lt;1|1,pla,val);    up(x);&#125;void print(ll x)&#123;    printf(&quot;l=%lld r=%lld f=%lld maxx=%lld\n&quot;,tr[x].l,tr[x].r,tr[x].f,tr[x].maxx);    if(tr[x].l==tr[x].r) return ;    print(x&lt;&lt;1),print(x&lt;&lt;1|1);&#125;int main()&#123;//    freopen(&quot;da.in&quot;,&quot;r&quot;,stdin);//    freopen(&quot;ans.sol&quot;,&quot;w&quot;,stdout);    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);    for(ll i=1;i&lt;=n;i++)&#123;        ll l,r;        scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);        if(r&lt;0) continue ;        l=max(0ll,l);        qujian[++tot]=node(l,r);        mx=max(mx,r);        cnt[l]++,cnt[r+1]--;        in[l]++;    &#125;    for(ll i=1;i&lt;=mx;i++)        cnt[i]+=cnt[i-1];    built(1,0,mx);    sort(qujian+1,qujian+tot+1,cmp);    ll ita=1,now=0;    for(ll i=0;i&lt;=mx;i++)&#123;//        printf(&quot;i=%lld\n&quot;,i);        while(qujian[ita].l==i)&#123;            st.insert(qujian[ita]);            ita++;now++;        &#125;        maxx=0;        seg_max(1,0,i-k);        maxx+=cnt[i];        ans=max(ans,maxx);//        printf(&quot;***maxn=%lld\n&quot;,maxx);        insert(1,i,maxx-now);        it=st.lower_bound(node(0,0));        while(it!=st.end()&amp;&amp;it-&gt;r&lt;=i)&#123;            ll l=it-&gt;l,r=it-&gt;r;            node tmp=*it;            seg_add(1,l,r,1);            it++;            now--;            st.erase(tmp);        &#125;//        print(1);    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>async await重新理解</title>
      <link href="/2025/03/14/async%20await%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3/"/>
      <url>/2025/03/14/async%20await%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>归档于  2023-06-01 21:18</p><p>去年python学async await时候完全没有理解，写出来很多伪异步代码，现在重新理解</p><p>await是挂起当前协程，然后运行其他携程</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><pre><code># 定义一个异步函数async def count_up_to(number):    print(&quot;开始计数&quot;)    for i in range(1, number + 1):        print(i)        await asyncio.sleep(1)  # 模拟耗时操作    print(&quot;计数完成&quot;)# 创建一个异步任务并执行async def main():    task = asyncio.create_task(count_up_to(5))  # 创建异步任务    # input()    print(&quot;执行其他任务&quot;)    await asyncio.sleep(2)  # 模拟执行其他任务的耗时    print(&quot;完成其他任务&quot;)    await task  # 等待异步任务完成asyncio.run(main())</code></pre><p>如果await后面接的是一个异步函数，那它会挂起当前而运行其他协程，按照这样的理解，main里面创建了一个新的携程任务task，当运行到await<br>asyncio.sleep(2)时运行task（执行另一个任务）<br>实际上上面那段代码等于</p><pre><code>import asyncioimport time# 定义一个异步函数async def count_up_to(number):    print(&quot;开始计数&quot;)    for i in range(1, number + 1):        print(i)        await asyncio.sleep(1)  # 模拟耗时操作    print(&quot;计数完成&quot;)# 创建一个异步任务并执行async def main():    # input()    print(&quot;执行其他任务&quot;)    await asyncio.sleep(2)  # 模拟执行其他任务的耗时    print(&quot;完成其他任务&quot;)    await task  # 等待另一个异步任务完成async def tasks():    tasks = []    tasks.append(asyncio.create_task(main()))    tasks.append(asyncio.create_task(count_up_to(5)))    await asyncio.gather(*tasks)# 运行主程序asyncio.run(tasks())</code></pre><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><pre><code># 定义一个异步函数async def count_up_to(number):    print(&quot;开始计数&quot;)    for i in range(1, number + 1):        print(i)        await asyncio.sleep(1)  # 模拟耗时操作    print(&quot;计数完成&quot;)# 创建一个异步任务并执行async def main():    await count_up_to(5)  # 创建异步任务    # input()    print(&quot;执行其他任务&quot;)    await asyncio.sleep(2)  # 模拟执行其他任务的耗时    print(&quot;完成其他任务&quot;)    await task  # 等待异步任务完成</code></pre><p>再看这段，await运行count_up_to时实际是挂起然后没有别的协程可以运行，所以直接阻塞等待count_up_to(5)运行完之后运行后面代码</p><p>所以我们运行aiohttp请求多个url要生成一串任务然后请求，而不是for直接套await（绷不住了）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>array「单调栈」</title>
      <link href="/2025/03/14/array%E3%80%8C%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%8D/"/>
      <url>/2025/03/14/array%E3%80%8C%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-12 21:18</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191012210825867-1090709998.png"></p><p>范围$1e7$,$a&lt;&#x3D;1e9$</p><p>让求得就是对于每个$i$,找到比$i$靠左,而$a[j]$比$a[i]$大的第一个位置,找到最小值下标</p><p>然后最简单维护方法是线段树</p><h3 id="60分代码"><a href="#60分代码" class="headerlink" title="60分代码"></a>60分代码</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 11111111ll a[A],lsh[A],tong[A];ll ida,minn,maxpla,nowval;struct tree&#123;    ll l,r,id,val,mx;&#125;tr[A];struct node&#123;    ll val,id;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b)&#123;val=a,id=b;&#125;    friend bool operator &lt; (const node &amp;a,const node &amp;b)&#123;        return a.val&lt;b.val;    &#125;&#125;now,pre;ll n,id,ans;set&lt;node&gt;st;set&lt;node&gt;::iterator it;void built(ll x,ll l,ll r)&#123;    tr[x].l=l,tr[x].r=r;    if(l==r)&#123;        scanf(&quot;%lld&quot;,&amp;a[l]);        tr[x].val=a[l];        tr[x].id=l;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    built(x&lt;&lt;1,l,mid);    built(x&lt;&lt;1|1,mid+1,r);    if(tr[x&lt;&lt;1].val&lt;=tr[x&lt;&lt;1|1].val)&#123;        tr[x].val=tr[x&lt;&lt;1].val;        tr[x].id=tr[x&lt;&lt;1].id;    &#125;    else &#123;        tr[x].val=tr[x&lt;&lt;1|1].val;        tr[x].id=tr[x&lt;&lt;1|1].id;    &#125;&#125;void seg_min(ll x,ll l,ll r)&#123;    if(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)&#123;        if(tr[x].val==minn)&#123;            ida=min(ida,tr[x].id);        &#125;        else if(tr[x].val&lt;minn)&#123;            minn=tr[x].val;            ida=tr[x].id;        &#125;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=l) seg_min(x&lt;&lt;1,l,r);    if(mid&lt;r) seg_min(x&lt;&lt;1|1,l,r);&#125;void find(ll x)&#123;    if(tr[x].mx&lt;=nowval) return ;    if(tr[x].l==tr[x].r)&#123;        maxpla=max(tr[x].l,maxpla);        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(tr[x&lt;&lt;1|1].mx&gt;nowval) find(x&lt;&lt;1|1);    else if(tr[x&lt;&lt;1].mx&gt;nowval)find(x&lt;&lt;1);&#125;void chose(ll x,ll ql,ll qr)&#123;    if(tr[x].l&gt;=ql&amp;&amp;tr[x].r&lt;=qr)&#123;        find(x);        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=ql) chose(x&lt;&lt;1,ql,qr);    if(mid&lt;qr) chose(x&lt;&lt;1|1,ql,qr);&#125;void change(ll x,ll pla,ll val)&#123;    if(tr[x].l==tr[x].r)&#123;        tr[x].mx=val;        return ;    &#125;    ll mid=(tr[x].l+tr[x].r)&gt;&gt;1;    if(mid&gt;=pla) change(x&lt;&lt;1,pla,val);    else change(x&lt;&lt;1|1,pla,val);    tr[x].mx=max(tr[x&lt;&lt;1].mx,tr[x&lt;&lt;1|1].mx);&#125;int main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    built(1,1,n);    for(ll i=1;i&lt;=n;i++)&#123;        ida=0,minn=0x7ffffffffffff;        maxpla=0,nowval=a[i];        chose(1,1,i-1);        change(1,i,a[i]);        seg_min(1,maxpla+1,i);//        printf(&quot;maxpla=%lld nowval=%lld minn=%lld i-ida+1=%lld\n&quot;,maxpla,nowval,minn,i-ida+1);        ans=max(i-ida+1,ans);    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191012211740510-1303030068.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>APIO2015雅加达的摩天楼</title>
      <link href="/2025/03/14/APIO2015%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC/"/>
      <url>/2025/03/14/APIO2015%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-10-27 11:30</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="https://img2018.cnblogs.com/blog/1708132/201910/1708132-20191027111958751-1563340755.png"></p><p>n&lt;&#x3D;30000,m&lt;&#x3D;30000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力的话就是直接建边跑spfa最短路</p><p>然而直接建边看上去复杂度正确,实际最多会建$n^2$条边,</p><p>看上去复杂度正确如何不试一试,</p><p>$dis[x][y]$表示位置$x$有一只跳跃长度为y的狗</p><p>炸空间十分严重30000*30000开不下</p><p>,考虑分块,这样就不炸空间了</p><p>$dis[0][x][y]$表示位置$x$有一只跳跃长度为y的狗</p><p>$dis[1][x][y]$表示$id$为$x$的狗目前跳到了能跳的第$y$个位置</p><p>以200为分界线dis[2][30000][200]就行了</p><p>由于数据比较水,你分块完就AC了,只是一种优化的暴力就可以水过这个题</p><h3 id="但这实在不失为优化空间的一种好方法"><a href="#但这实在不失为优化空间的一种好方法" class="headerlink" title="但这实在不失为优化空间的一种好方法"></a>但这实在不失为优化空间的一种好方法</h3><h2 id="水过的代码"><a href="#水过的代码" class="headerlink" title="水过的代码"></a>水过的代码</h2><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 31000#define maxn 215ll dis[2][A][maxn],vis[A][maxn],rec[A],b[A],p[A],st[A];ll flag[2][A][maxn];ll n,m,ans;vector &lt;ll&gt; v[A];vector &lt;ll&gt; dog[A];struct node&#123;    ll opt,pla,x;    node()&#123;&#125;    node(const ll &amp;a,const ll &amp;b,const ll &amp;c)&#123;opt=a,pla=b,x=c;&#125;&#125;;queue&lt;node&gt; q;void update(ll x,ll d)&#123;//    printf(&quot;x=%lld d=%lld\n&quot;,x,d);    if(!rec[x])&#123;        for(ll i=0;i&lt;dog[x].size();i++)&#123;            ll h=dog[x][i];            if(dis[1][h][st[h]]&gt;d)&#123;                dis[1][h][st[h]]=d;                q.push(node(1,h,st[h]));            &#125;        &#125;        for(ll i=1;i&lt;200;i++)&#123;            if(vis[x][i])&#123;                if(dis[0][x][i]&gt;d)&#123;                    dis[0][x][i]=d;//                    printf(&quot;**********i=%lld\n&quot;,i);                    q.push(node(0,x,i));                &#125;            &#125;        &#125;        rec[x]=1;    &#125;&#125;void spfa()&#123;    memset(dis,0x3f,sizeof(dis));    if(p[0]&gt;=200)&#123;        q.push(node(1,0,st[p[0]]));        dis[1][0][st[p[0]]]=0;    &#125;    else &#123;        q.push(node(0,b[0],p[0]));        dis[0][b[0]][p[0]]=0;    &#125;    update(b[0],0);    while(!q.empty())&#123;        node u=q.front();        q.pop();        flag[u.opt][u.pla][u.x]=0;        ll d=dis[u.opt][u.pla][u.x];//        printf(&quot;dis=%lld opt=%lld pla=%lld x=%lld\n&quot;,dis[u.opt][u.pla][u.x],u.opt,);        if(u.opt==0)&#123;            if(u.pla+u.x&lt;=n)                if(dis[0][u.pla+u.x][u.x]&gt;d+1)&#123;                    dis[0][u.pla+u.x][u.x]=d+1;                    if(!flag[0][u.pla+u.x][u.x])&#123;                        flag[0][u.pla+u.x][u.x]=1;                        q.push(node(0,u.pla+u.x,u.x));                    &#125;                    update(u.pla+u.x,d+1);                &#125;            if(u.pla-u.x&gt;=0)                if(dis[0][u.pla-u.x][u.x]&gt;d+1)&#123;                    dis[0][u.pla-u.x][u.x]=d+1;                    if(!flag[0][u.pla-u.x][u.x])&#123;                        flag[0][u.pla-u.x][u.x]=1;                        q.push(node(0,u.pla-u.x,u.x));                    &#125;                    update(u.pla-u.x,d+1);                &#125;        &#125;        else&#123;            if(u.x&gt;=1)                if(dis[1][u.pla][u.x-1]&gt;d+1)&#123;                    dis[1][u.pla][u.x-1]=d+1;                    if(!flag[1][u.pla][u.x-1])&#123;                        flag[1][u.pla][u.x-1]=1;                        q.push(node(1,u.pla,u.x-1));                    &#125;                    update(v[u.pla][u.x-1],d+1);                &#125;            if(u.x+1&lt;v[u.pla].size())                if(dis[1][u.pla][u.x+1]&gt;d+1)&#123;                    dis[1][u.pla][u.x+1]=d+1;                    if(!flag[1][u.pla][u.x+1])&#123;                        flag[1][u.pla][u.x+1]=1;                        q.push(node(1,u.pla,u.x+1));                    &#125;                    update(v[u.pla][u.x+1],d+1);                &#125;        &#125;    &#125;&#125;int main()&#123;        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);    for(ll i=0;i&lt;m;i++)&#123;        scanf(&quot;%lld%lld&quot;,&amp;b[i],&amp;p[i]);        if(p[i]&gt;=200)&#123;            dog[b[i]].push_back(i);            ll k=b[i];            while(k&gt;=p[i]) k-=p[i];            while(k&lt;=n)&#123;                v[i].push_back(k);                if(k==b[i])&#123;                    st[i]=v[i].size()-1;                &#125;                k+=p[i];            &#125;        &#125;        else vis[b[i]][p[i]]=1;    &#125;    spfa();    ans=0x3f3f3f3f;    if(p[1]&gt;=200)&#123;        ans=min(ans,dis[1][1][st[1]]);    &#125;    else &#123;        ans=min(ans,dis[0][b[1]][p[1]]);    &#125;    if(ans&gt;=1000000)        printf(&quot;-1\n&quot;);    else printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>然而当p很小还是会建很多条边,如果p全是1你会挂仍然会被卡成sb</p><p>作为一个有脸的人是需要打正解的</p><p>正解是分块+建虚点</p><p>建边最多会达到$n^2$,通常遇到建边很多的题都可以建虚点解决</p><p>这个题也可以建虚点</p><p>每只狗能跳长度是确定的,一直狗起始点$b[i]$,它能跳的就是$b[i]+p[i]*1$,$b[i]+p[i]*2$,$b[i]+p[i]*3$</p><p>类似于同余系最短路,我们可以在p[i]-&gt;p[i]*2,p[i]*2之-&gt;p[i]间建代价为1的边</p><p>在b[i]-&gt;底层建代价为0的边,每个虚点向外界连代价0的边</p><p>考虑每个&gt;200的点最多建$\sqrt{n}$个边,&lt;200建完虚点也只会最多$\sqrt{n}$个边</p><p>总建边数量$n*\sqrt{n}$可过</p><p>建边代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>    for (ll i=1;i&lt;=t;i++)        for (ll j=0;j&lt;i;j++)            for (ll k=j;k&lt;n;k+=i)&#123;                pos[i][k]=++cnt;                add(cnt,k,0);                if (k&gt;=i)&#123;                    add(cnt,cnt-1,1);                    add(cnt-1,cnt,1);                &#125;            &#125;    for(ll i=0;i&lt;m;i++)&#123;        if(p[i]&lt;=t)&#123;            add(b[i],pos[p[i]][b[i]],0);        &#125;        else &#123;                        for(ll j=1;j;j++)&#123;                if(b[i]+p[i]*j&gt;=n) break;                add(b[i],p[i]*j+b[i],j);            &#125;            for(ll j=1;j;j++)&#123;                if(b[i]-p[i]*j&lt;0) break;                add(b[i],b[i]-p[i]*j,j);            &#125;        &#125;    &#125;</code></pre><p>View Code</p><p>总代码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll int#define A 16100000#define maxn 215ll dis[A],flag[A],b[30100],p[30100],pos[maxn][30100],head[A],nxt[A],edg[A],ver[A];ll n,m,ans,cnt,t,tot;void add(ll x,ll y,ll z)&#123;//    printf(&quot;tot=%d\n&quot;,tot);//    if(tot&gt;10000000) printf(&quot;tot=%d\n&quot;,tot);    nxt[++tot]=head[x],head[x]=tot,edg[tot]=z,ver[tot]=y;&#125;void spfa(ll w)&#123;    for(ll i=0;i&lt;=cnt;i++)        dis[i]=1e9;    queue&lt;ll&gt; q;    q.push(w);    dis[w]=0;    while(!q.empty())&#123;        ll x=q.front();        q.pop();        flag[x]=0;        for(ll i=head[x];i;i=nxt[i])&#123;            ll y=ver[i];            if(dis[y]&gt;dis[x]+edg[i])&#123;                dis[y]=dis[x]+edg[i];                if(!flag[y])&#123;                    flag[y]=1;                    q.push(y);                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;//    freopen(&quot;zj.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(ll i=0;i&lt;m;i++)&#123;        scanf(&quot;%d%d&quot;,&amp;b[i],&amp;p[i]);    &#125;    t=min((ll)sqrt(n),100);    cnt=n-1;    for (ll i=1;i&lt;=t;i++)        for (ll j=0;j&lt;i;j++)            for (ll k=j;k&lt;n;k+=i)&#123;                pos[i][k]=++cnt;                add(cnt,k,0);                if (k&gt;=i)&#123;                    add(cnt,cnt-1,1);                    add(cnt-1,cnt,1);                &#125;            &#125;    for(ll i=0;i&lt;m;i++)&#123;        if(p[i]&lt;=t)&#123;            add(b[i],pos[p[i]][b[i]],0);        &#125;        else &#123;                        for(ll j=1;j;j++)&#123;                if(b[i]+p[i]*j&gt;=n) break;                add(b[i],p[i]*j+b[i],j);            &#125;            for(ll j=1;j;j++)&#123;                if(b[i]-p[i]*j&lt;0) break;                add(b[i],b[i]-p[i]*j,j);            &#125;        &#125;    &#125;    spfa(b[0]);    ans=dis[b[1]];    if(ans&gt;1000000) printf(&quot;-1\n&quot;);    else printf(&quot;%d\n&quot;,ans);&#125;</code></pre><p>View Code</p><p>ps:极限数据还是会建15000000条边,需要对空间做很好把控</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AFO小记</title>
      <link href="/2025/03/14/AFO%E5%B0%8F%E8%AE%B0/"/>
      <url>/2025/03/14/AFO%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-17 20:44</p><p>罪有应得<br>away from OI and already forget OI</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A</title>
      <link href="/2025/03/14/A/"/>
      <url>/2025/03/14/A/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-11-14 09:30</p><p>给定N个形如$f_i(x)&#x3D;a_i<em>x^2+b_i</em>x$的二次函数</p><p>有Q次询问每次给出一个$x$,求$max{f_i(x)}$</p><p>再菜也只是菜这么一两天了</p><p>过了这几天,奥赛就与我无关了</p><p>可能退役之前最后一篇?</p><p>观察到二次函数没有c</p><p>二次函数可以转化成$x(a*x+b)$</p><p>就可以分类讨论了,分成$x&gt;0,x&lt;0$</p><p>只讨论$&gt;0$($&lt;0$同理)</p><p>$&gt;0$时按照$a$升序,$b$升序排序</p><p>排序后,对于每一个值域预处理,回答时$O1$</p><p>假设值域上两个值$x,x+1$</p><p>$x$取到最大值为$mxid$,那么$x+1$取到最大值一定大于等于$mxid$</p><p>证明</p><p>$(x+1)<em>a+b&#x3D;x</em>a+b+a$</p><p>$a$排序后是单调递增的</p><p>因为$mxid$之前a都$&lt;&#x3D;a_{mxid}$,本来就$&lt;&#x3D;mxid$现在增加量$&lt;&#x3D;mxid$</p><p>所以可以链表乱搞</p><p>复杂度$O(值域ln(值域))$</p><p>复杂度证明</p><p>经过去重之后</p><p>假设最后一个值为$a_{mxid},b_{mxid}$</p><p>极限情况就是一直跳$a_1$,最大是$a_1$</p><p>会跳多少次解不等式</p><p>$a_{lst}<em>x</em>x+b_{lst}<em>x&gt;a_1</em>x<em>x+b_1</em>x$</p><p>假设x&gt;0</p><p>$a_{lst}<em>x+b_{lst}&gt;a_1</em>x+b_1$</p><p>于是有了</p><p>$x&gt;\frac{b_1-b_{lst}}{a_{lst}-a_1}$</p><p>然后设分母为$delta_a$</p><p>仍然考虑极限情况$delta_a$为$6e4$,</p><p>$b_1-b_{lst}&#x3D;6e4$</p><p>n每次减少1</p><p>于是复杂度就是$\frac{6e4}{6e4}\frac{6e4}{6e4-1},,,,,\frac{6e4}{1}$</p><p>调和级数$O(值域ln(值域))$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>123</title>
      <link href="/2025/03/14/123/"/>
      <url>/2025/03/14/123/</url>
      
        <content type="html"><![CDATA[<p>归档于  2024-06-09 22:52</p><pre><code>package mainimport (&quot;github.com/hyperledger/fabric/core/chaincode/shim&quot;&quot;github.com/hyperledger/fabric/protos/peer&quot;&quot;log&quot;)type HelloWorld struct &#123;&#125;func (this *HelloWorld) Init( stub shim.ChaincodeStubInterface) peer.Response &#123;args := stub.GetStringArgs()err := stub.PutState(args[0], []byte(args[1]))if err != nil &#123;shim.Error(err.Error())&#125;return  shim.Success(nil)&#125;func (this *HelloWorld)Invoke(stub shim.ChaincodeStubInterface) peer.Response  &#123;fn, args := stub.GetFunctionAndParameters()if fn == &quot;set&quot;&#123;return this.set(stub, args)&#125;else if fn == &quot;get&quot;&#123;return this.get(stub, args)&#125;return shim.Error(&quot;Invoke func error&quot;)&#125;func (this *HelloWorld)set(stub shim.ChaincodeStubInterface,  args  []string)  peer.Response &#123;err := stub.PutState(args[0], []byte(args[1]))if err != nil&#123;return shim.Error(err.Error())&#125;return shim.Success(nil)&#125;func (this *HelloWorld)get(stub shim.ChaincodeStubInterface, args []string) peer.Response  &#123;value, err := stub.GetState(args[0])if err != nil&#123;return shim.Error(err.Error())&#125;return shim.Success(value)&#125;func main()&#123;err := shim.Start(new(HelloWorld))if err != nil &#123;log.Println(err)return&#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.6</title>
      <link href="/2025/03/14/11.6/"/>
      <url>/2025/03/14/11.6/</url>
      
        <content type="html"><![CDATA[<p>归档于  2022-10-24 09:30</p><h2 id="小m的朋友圈"><a href="#小m的朋友圈" class="headerlink" title="小m的朋友圈"></a>小m的朋友圈</h2><p>前两个图通过谷歌识图，最后一个图先找到有个像瓜子壳一样的标志物，那是珠海大剧院，珠海大剧院周围一个一个枚举，从港湾大道情侣中路试到海天公园。<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221025155306386-476964407.png" alt="image"></p><h2 id="easy-misc"><a href="#easy-misc" class="headerlink" title="easy_misc"></a>easy_misc</h2><p><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024112951190-260301643.png" alt="image"><br>有个pdf 全选后发现最后一页有个东西被选中了，拖到一个地发现是xxencode，解码第二个文件得到是祖冲之密码<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024113139476-297074761.png" alt="image"></p><p><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024093658049-1040000112.png" alt="image"><br>丢到里面运行得结果</p><h2 id="sstv降临到我身边"><a href="#sstv降临到我身边" class="headerlink" title="sstv降临到我身边"></a>sstv降临到我身边</h2><p>题干里给出了提示sstv<br>搜索sstv ctf，buuctf有一个类似的题，下载相关sstv工具，用手机播放sstv<br>左上角二维码被遮住一部分，用画图工具复制右上角的二维码填补到左上角<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221025161949203-1289034245.png" alt="image"></p><h2 id="very-easy-ecc"><a href="#very-easy-ecc" class="headerlink" title="very_easy_ecc"></a>very_easy_ecc</h2><p><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221025155505896-1867864826.png" alt="image"></p><p>这个题放到百度发现是原题，只有密钥改变了。<br>point发现是圆锥曲线密码，然后丢到现成工具</p><h2 id="细狗"><a href="#细狗" class="headerlink" title="细狗"></a>细狗</h2><p>因为e很小，尝试直接开方，试了matlab不行，找了网上的脚本<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024112204988-2125773673.png" alt="image"><br>（放进matlab都inf</p><h2 id="有点臭的base全家桶"><a href="#有点臭的base全家桶" class="headerlink" title="有点臭的base全家桶"></a>有点臭的base全家桶</h2><p>上半个flag:<br>base128包含0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\xb5\xb6\xb7\xbc\xbd\xbe\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff</p><p>有base128标识：类似\x1这样，并且末尾有[2]是分块之后缺少字节为多少，另外还有分块</p><p>丢进base128<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024090703451-563749656.png" alt="image"></p><pre><code>b&#39;&lt;c)qe@PUf+;cm^8@Rb&lt;5&lt;\RQu@r,1f9ij&gt;h9ic3e&gt;&quot;)IG@9#$`@RO*t&lt;``.B=_hP@;JS!e&lt;,&gt;`P&lt;^p7J=&amp;r3h=]I&gt;$;eoE7@RaO?&lt;Gcu)@PM%V&gt;!u7i@THYd&lt;_%75=%&gt;kQ;enBn&lt;btrA&lt;,&gt;`AAO]^@&lt;,HGH;FXhJ&lt;\ebu@PUDS;f#W5&lt;bk&lt;.&lt;c*(i9egHB;Jem&lt;&lt;btBS&lt;\cBd&lt;\Q7/@mt39&lt;btr[=_^E7@r!f%&lt;GctZ&lt;\e&gt;j&lt;c&#39;QJ=)CfZ=)2JaASbOL&lt;*!0q9ib;:9ij&gt;U9gh&lt;(&lt;,5B!&lt;\[3f@n9d,&lt;^fJ7=Yb&amp;C&lt;\[d!&lt;,HGb9h7TQ&lt;\[cV;DM!h&lt;bu;K@5:__=_q,I&lt;AA&lt;1&lt;c2GL9ib:P&lt;*![.=%&gt;kQ@n:Q&gt;9iak[&lt;bb*4A4BU@@7FF%ASYID=&#39;0E3;_h6Q;eooD@Rj&lt;l&lt;c*(b9l+!S@7Xp/9iWo*&lt;AJZ3=%&gt;l&#39;:02+0@T5cM=_^E)=%+uI&lt;,H_P&lt;c15\&lt;bl2&quot;=]SFA;f#KK;Jng(=]@k7ASbLn=)2nm9iX&amp;*&lt;AJfC@9-!A@5DFq=%GYK=&amp;rL.AO]F;&lt;,&gt;TKASlZl&lt;bas0;_Tq-=)LoN;HQ7]&lt;btZ(;DD&#39;j@7&gt;9O9iZ.9=]K-&amp;&lt;\d9M@7&gt;EE9l=WD&lt;\RNu=%5f(@Rk65@Rb/l&lt;\ebu=]SOI@Rb$4@VeYT&lt;GaI/&lt;buSP;JUAj@RkZh&lt;\ec*@RaOB;eeX-&lt;``.B=_hP@=&#39;%j_@7FdA;J^;T=)1](=]S9f;f53A;DUX==_q87A8GF&gt;&lt;GQ\P;DCWt&lt;\\9/&lt;,&gt;/r=):o&lt;@TZNA&lt;c*(i=%+uJ&lt;,H;_;DCd:&lt;`W`f;))lg=&#39;0ET;b05V&lt;bbBJ&lt;(9o1AOgiX&lt;blZ#&lt;`_&quot;s@9-o0@7Ndg@TZNA=_^E$A2#`&gt;&gt;&quot;28$@RY6==&amp;s!Y@kpeL&lt;GY]8@T7/D&lt;GaHIASbmt@7XpC;J^;u&lt;\ec8&lt;btob;/:D[&lt;c(`.&gt;&quot;)FK&lt;`W7B@mr7R@Rrg\&lt;\\,==]\IG&lt;*3g4@RaO&quot;=_qV*@PM\&gt;&lt;c2)9&lt;c(`[=]K-N&lt;\d-&amp;;/0!4@;@`@&lt;bb6&quot;@r,[s&lt;,&gt;T:ASbOM&lt;bl5&amp;@5:Q%&gt;&quot;DCg@Rb&lt;U&lt;Glbr9l+!7&gt;!t\P;J^/+&lt;\eo.=%6^kAO^33@T5fn&lt;,5Z@A2.V;&lt;,H_Y@&lt;ts3&lt;_%CCA26bJ;eooF@;JP=&lt;c*(i@7F:;;JUAh9iZ-e&lt;`_&quot;0&lt;A@*K;/AR#@TYrn&lt;_&quot;lG;DLj7&lt;btfN@5C5I&lt;`_&quot;0A2#`&gt;@5DFp@&lt;u`l=_h2bASbLpA40&lt;s@Rb&lt;,&lt;\cO*&lt;btr/=)(K2@Rb&lt;1&lt;btr0@kgl&amp;@7F!e&lt;`h[^&lt;c&#39;O89h&amp;r#;HRI)&lt;c)MN=_hPd=&amp;s-?@n(!/9ic4X&lt;AJMh&lt;,G5uA40U)9h/kj&lt;_%4U=%,,L=);DGASXal&lt;c*(i=)Cu?&lt;bkl&gt;@RaNs&lt;GFur;c[F/;JgMU9iX&amp;A&lt;c&#39;]e=%&gt;kc&lt;GZ&gt;M9h&amp;;V&gt;!thq=%?:^:KMX5@&lt;ts4&lt;c&#39;QF=]S[M=)1u=@RWmk=_h2L@7F9t;J]*D;H-+e=)1u4@9-Q5@mj3r@;B%i&gt;!ttPAO]R&lt;=)0Zm;aj;^&lt;c&#39;O8&lt;AIHn@5D^p&lt;`i7?&lt;c*(i9ic(2=)CE,@T?Gc=YO#p&lt;\[d!;eo92&lt;``0m&lt;c)n4&lt;\d-7@7P!+&lt;`h[i&lt;btZ$@PL&gt;o&lt;bu;K@V[i&amp;=]fWa@odDd=)CE/@RaNT&gt;#f)e&lt;c(H!@n(!/@5;M&gt;=&amp;rKt;J]ld=);hW;H@aT=)1uJ&lt;&amp;.0m@msp-@&lt;tsM&lt;c*(b9l+!S&lt;GQ\P;JT;i&lt;AJZ3=%&gt;])@7F-u@Rj9L&lt;c*(_@kpME:KC4c=%,_a&lt;\ec*=]SR)&lt;btf3;Fbdg&#39;</code></pre><p>去掉最前面b’和最后面’</p><p>之后丢到<img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024083030411-677911414.png" alt="image"></p><p>字符集85，丢到<img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024091015976-1032531595.png" alt="image"></p><pre><code>Vmtab2QySXhXbFpPV0VwclVtMW9iMVp0ZEV0aU1WbDRZVWQwYkdKRk1UTlZiVFZ2WVRGYU5tSkVVbFZpUmxwb1ZGZDRWbVZ0VGtWWGJGSk9UVlZXTlZZeFVrTmlNRFZ6V2tWb2FWSlZOVkJVVmxaM1l6RmFjVlJzV214V01VcElXVlZrYjFack1YUmxSV2hXVm14WmQxWkhjelZTTVZKMVVtMW9VMDB3TkRCV1JscHZZVEF4Y2sxV1ZsTmlhMHBXV1ZSR2NtVldXa2RXYlVaU1lrVndWMVV5TVhOWGJGcHpVMVJLVjFadFVsaFZWekZMWXpGS2RXSkdUbGROVmxZMlZsaHdUMU15U2tkWGJrNWhVbTE0YjFSWE5VTmtNVnB4Vkc1YVRsSlViRnBYYTFwelYwWktjMU51U2xwaVJsa3dWWHBHWVZZeFNuTlVhemxUVjBaS01WWnRjRXBOVlRGR1RsaEthMUpZYUhCV2JYaExZMnhTV0UxWFJtbGlSbFl6V2tWYVUxbFhWblJoUm1oVllURktlbGxzV2tabFZsSjBaVWQwYkdKWWFIaFdiRlpYWkRGYVNGSnJiR3BTYlZKdlZGUktOR1F4V1hsTlJFWlVVbXRhVmxaWE5WTmhiR1JKVVd4Q1lWWXphSHBWVjNoTFVteGtkVkpzVW1saVdHaGFWbXRhYjFNd01WZFNibEpYWVhwc2NGUlVTbTlUUm14eldraHdiRlpzV2toVlYzQkxZVmRLZEU5VVVscE5SbHBNV1d0YWQyTXhSbFZSYld4b1lrVnZNVmRyYUhkV2F6QjRZak5rVjJKcldsTlVWelZUVkd4a2MxZHNUbFppUnprMlZWZDBNRll4V2xaWFdHeFdWbTFPTkZZd1duTmtWazV5VGxad2JHSkdWalJYVmxaaFVqRktjMUp1VW10U1JYQlBWbXBPVG1WR2JGVlVia3BQVW10d01Wa3dVazlXYkZwelYydDRWbFpGV25KVlZFWjNVbFpLVlZGc1RsaFNNVXBLVm0xMFlWRXdNVmhVYkdoWVlYcFdUMVpxU2pOTmJHdDZZMGhLVGsxWE9UWldSekF4VmxaWmVXVkZVbFZOUjFKSVdURmtUMU5HVm5KWGJYUlhWMFZGZDFkWGVHOWtNazV6Vm10YVYxWkZTbEJXYkZaaFVURlNkRTFWWkZKaVZWcDRWakZvZDJFeFRrWk5TSEJZVm0xU2Rsa3lNVXRrVmxaMVlVWmFUbUV4Y0ZkV1ZsSkRUVWRLVms1V2FGaGhNVXBWVlRCb1FtVldXbk5WYXpscVlrWmFXbFZ0ZUd0VmJGcFdUa2hvWVZKRlduWlpWRVpoWkZaT2MxcEdTazVOVmxZMlZsUktORkV4U2tkWGEyaFRZbGQ0VmxWc2FHOVNNWEJYV2taYVVWVlVNRGs9</code></pre><p>丢到工具硬跑，五轮base64，四轮base58，一轮base32，一轮base16<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024091539647-796036701.png" alt="image"></p><p><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024091644147-780930045.png" alt="image"></p><p>工具：<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024091747521-736462185.png" alt="image"></p><p>下半个flag：</p><p>还是用上面的脚本base91解码跑9轮</p><pre><code>203696893666692597026492988</code></pre><p>base36编码得flag<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024092211804-583348053.png" alt="image"></p><h2 id="ezjs"><a href="#ezjs" class="headerlink" title="ezjs"></a>ezjs</h2><p>开源代码，搜索js相关编码发现jother，放到解码器没有反应，再还通过找别的博客知道这是jsfuck，那个js函数jsfuck可以直接运行<br>放到f12控制台有个弹窗得到flag</p><h2 id="easy序列化"><a href="#easy序列化" class="headerlink" title="easy序列化"></a>easy序列化</h2><p>序列化我做过有类似的题，这个题直接序列化做不出来</p><h2 id="红包题"><a href="#红包题" class="headerlink" title="红包题"></a>红包题</h2><p>f12看到图片用了路径试了试&#x2F;..&#x2F;不行<br>还有&#x2F;icons&#x2F;..&#x2F;也不行<br>搜了下版本apache<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024174829337-689485144.png" alt="image"><br>一搜出漏洞<br>丢到网上下的工具里跑得到路径，丢到burp suite<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221025161516046-2113932584.png" alt="image"></p><h2 id="致整数溢出的你"><a href="#致整数溢出的你" class="headerlink" title="致整数溢出的你"></a>致整数溢出的你</h2><p>三问<br>第一问直接利用0-最大值<br>第二问暴力，编写利用脚本<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024095027975-801012624.png" alt="image"><br>第三问利用int最小值比最大值大1<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024095349751-403951112.png" alt="image"></p><h2 id="very-easy-re"><a href="#very-easy-re" class="headerlink" title="very_easy_re"></a>very_easy_re</h2><p>ida直接看flag，{hacking_for_fun}<br>然后main函数里执行了替换<br>替换即可<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024110936606-831132264.png" alt="image"></p><h2 id="easy-re"><a href="#easy-re" class="headerlink" title="easy_re"></a>easy_re</h2><p>逆向，丢到exeinfope.exe发现套了层壳<br>upx脱壳可以分析<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024095616904-696197508.png" alt="image"><br>发现是换表base64<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024095718309-212483630.png" alt="image"></p><h2 id="超逆向pyc"><a href="#超逆向pyc" class="headerlink" title="超逆向pyc"></a>超逆向pyc</h2><p>这里应当是</p><pre><code>else :res+=c</code></pre><p>它逆向的有问题<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024103459692-428969049.png" alt="image"><br>rail_fence是栅栏密码，有2，4，7，8，14，28<br>caesar是凯撒密码3-17暴力一遍<br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024103920991-262937484.png" alt="image"><br><img src="https://img2022.cnblogs.com/blog/1708132/202210/1708132-20221024103931259-829240860.png" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「PKUWC2018」Slay the Spire</title>
      <link href="/2025/03/14/%E3%80%8CPKUWC2018%E3%80%8DSlay%20the%20Spire/"/>
      <url>/2025/03/14/%E3%80%8CPKUWC2018%E3%80%8DSlay%20the%20Spire/</url>
      
        <content type="html"><![CDATA[<p>归档于  2019-07-24 15:40</p><p>杀戮尖塔</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先题目中要求的期望是假期望,结合题目中所给的阶乘就可以看出这其实是从$2*n$张牌中选择$m$张牌使用,并且所有情况都取最大值时的和</p><p>首先排序贪心最大</p><p>再说一个非常显然的结论,有强化牌就用,强化牌上数大于2,所以打出强化牌一定收益&gt;&#x3D;比打出一张攻击牌带来(保证最后一定要出至少一张攻击牌就行)</p><p>例如 你有强化牌 2 2 攻击牌 4 4 限制出2张</p><p>那么你先打一张2再打一张4和 先打4 再打4 收益一样</p><p>那么如果强化牌比k张要小,那么要把所有强化牌都用了,最后打输出.如果强化牌比k还要大,那么最后留一张攻击牌打出来就行了</p><p>我们可以假设$F(i,j)$表示你有i张强化牌时打出j张时收益,$G(i,j)$表示你有i张攻击牌时打出j张时收益</p><p>那么最后答案就是</p><p>$\sum\limits_{i&#x3D;0}^{k-1} F(i,i)*G(m-i,k-i)+\sum\limits_{i&#x3D;k}^{k&#x3D;min(n,m)}<br>F(i,k-1)*G(m-i,1)$</p><p>那么我们现在的任务就是快速求出来F和G</p><p>考虑直接求非常难求,我们这时一般要开几个别的数组</p><p>首先开$f[i][j]$ $g[i][j]$表示当你抽到i张牌必打第i张一共打了j张时收益</p><p>那么可以推出来$f[i][j]&#x3D;w_i\times \sum f[l][j-1]$和$g[i][j]&#x3D;C_{i-1}^{j-1}w_i + \sum<br>g[l][j-1]$ (这里的组合数表示一共有$C_{i-1}^{j-1}$种方式转移过来,每种转移都要加一个w)</p><p>然后得到$F(i,j)&#x3D;\sum_{l&#x3D;j}^{n} C_{n-l}^{i-j} f[l][j]$</p><p>解释一下 F可以从l中使用j张(这j张都是大牌)再从剩余n-l中选择i-j张不打共同构成F的i张打了j张</p><p>G同理得到$G(i,j)&#x3D;\sum{l&#x3D;j}^{n} C_{n-l}^{i-j} g[i][j]$</p><p>然后转移就完了</p><p>本题稍卡常</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define A 1510#define py printf(&quot;f**k\n&quot;)#define mod 998244353ll n,m,t,k,ans=0,f[1510][1510],g[1510][1510],C[3010][3010],sum1[A],sum2[A],wg[A],wq[A];inline ll read()&#123;    ll x=0; char c=getchar();    while(isdigit(c))&#123;x=x*10+c-&#39;0&#39;;c=getchar();&#125;    return x;&#125;ll gcd(ll x,ll y)&#123;    if(y==0) return x;    return gcd(y,x%y);&#125;inline ll F(ll i,ll j)&#123;    ll r=0;    for(ll l=j;l&lt;=n;l++)&#123;        r=(r+C[n-l][i-j]*f[l][j]%mod)%mod;//表示含义为首先从前l张选出j张再从n-l中选出l-j张    &#125;    return r;&#125;inline bool cmp(const ll &amp; a,const ll &amp; b)&#123;    return a&gt;b;&#125;inline ll G(ll i,ll j)&#123;    ll r=0;    for(ll l=j;l&lt;=n;l++)&#123;        r=(r+C[n-l][i-j]*g[l][j]%mod)%mod;//含义同上    &#125;    return r;&#125;inline void re()&#123;    memset(sum1,0,sizeof(sum1));    memset(sum2,0,sizeof(sum2));&#125;inline void init()&#123;    n=read(),m=read(),k=read();    f[0][0]=1;    for(ll i=1;i&lt;=n;i++)        wq[i]=read();    sort(wq+1,wq+n+1,cmp);    for(ll i=1;i&lt;=n;i++)        wg[i]=read();    sort(wg+1,wg+n+1,cmp);    for(ll i=1;i&lt;=n;i++)        f[i][1]=wq[i],g[i][1]=wg[i];    for(ll i=1;i&lt;=n;i++)&#123;        for(ll j=2;j&lt;=i;j++)&#123;            sum1[j-1]=(sum1[j-1]+f[i-1][j-1])%mod;            f[i][j]=wq[i]*sum1[j-1]%mod;            sum2[j-1]=(sum2[j-1]+g[i-1][j-1])%mod;            g[i][j]=(C[i-1][j-1]*wg[i]+(sum2[j-1]))%mod;        &#125;    &#125;/*    for(ll i=1;i&lt;=n;i++)        for(ll j=1;j&lt;=i;j++)            printf(&quot;f[%lld][%lld]=%lld g[%lld][%lld]=%lld\n&quot;,i,j,f[i][j],i,j,g[i][j]);*/&#125;inline void work()&#123;    ll ans=0;    for(ll i=min(n,m);i&gt;=0;i--)&#123;        if(i&lt;k)ans=(ans+F(i,i)*G(m-i,k-i)%mod)%mod/*,printf(&quot;F=%lld G=%lld\n&quot;,F(i,i),G(m-i,k-i))*/;        else ans=(ans+F(i,k-1)*G(m-i,1)%mod)%mod/*,printf(&quot;F=%lld G=%lld\n&quot;,F(i,k-1),G(m-i,1))*/;//        printf(&quot;ans=%lld\n&quot;,ans);    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123;    for(ll i=0;i&lt;=3000;i++)        C[i][0]=1;    for(ll i=1;i&lt;=3000;i++)        for(ll j=1;j&lt;=i;j++)            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;    t=read();    while(t--)&#123;        re();init();work();    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
